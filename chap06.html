<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from www.omnithreadlibrary.com/book/chap06.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 19 Oct 2025 22:28:33 GMT -->
<head>
  <meta charset="utf-8">
  <title>3. High-level multi-threading</title>
  <link href="stylesheet.css" rel="stylesheet" />
</head>
<body dir="ltr" class="kramdown">
<div id="leanpub-toc">
<h2></h2>
<ol class="toc">
<ul class='toc no-parts'>
  <li>
    <a href='chap00.html#intro-advert'>About me</a>
  </li>
  <li>
    <a href='chap01.html#credits'>Credits</a>
  </li>
  <li>
    <a href='chap02.html#introduction'>Introduction</a>
    <ul>
      <li>
        <a href='chap02.html#leanpub-auto-formatting-conventions'>Formatting conventions</a>
      </li>
      <li>
        <a href='chap02.html#leanpub-auto-learn-more'>Learn more</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap03.html#leanpub-auto-release-notes'>Release notes</a>
  </li>
  <li>
    <a href='chap04.html#intro-mt'><span class="section-number">1. </span>Introduction to multi-threading</a>
    <ul>
      <li>
        <a href='chap04.html#leanpub-auto-multi-threading-as-a-source-of-problems'><span class="section-number">1.1 </span>Multi-threading as a source of problems</a>
        <ul>
          <li>
            <a href='chap04.html#leanpub-auto-reading-and-writing-shared-data'><span class="section-number">1.1.1 </span>Reading and writing shared data</a>
          </li>
          <li>
            <a href='chap04.html#leanpub-auto-modifying-shared-data'><span class="section-number">1.1.2 </span>Modifying shared data</a>
          </li>
          <li>
            <a href='chap04.html#leanpub-auto-writes-masquerading-as-reads'><span class="section-number">1.1.3 </span>Writes masquerading as reads</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap05.html#intro-otl'><span class="section-number">2. </span>Introduction to OmniThreadLibrary</a>
    <ul>
      <li>
        <a href='chap05.html#leanpub-auto-requirements'><span class="section-number">2.1 </span>Requirements</a>
      </li>
      <li>
        <a href='chap05.html#leanpub-auto-license'><span class="section-number">2.2 </span>License</a>
      </li>
      <li>
        <a href='chap05.html#installation'><span class="section-number">2.3 </span>Installation</a>
        <ul>
          <li>
            <a href='chap05.html#appendix-installing-getit'><span class="section-number">2.3.1 </span>Installing with GetIt</a>
          </li>
          <li>
            <a href='chap05.html#appendix-installing-delphinus'><span class="section-number">2.3.2 </span>Installing with Delphinus</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-installing-design-package'><span class="section-number">2.3.3 </span>Installing design package</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap05.html#leanpub-auto-why-use-omnithreadlibrary'><span class="section-number">2.4 </span>Why use OmniThreadLibrary?</a>
      </li>
      <li>
        <a href='chap05.html#introotl-tasksvsthreads'><span class="section-number">2.5 </span>Tasks vs. threads</a>
      </li>
      <li>
        <a href='chap05.html#introotl-lockingvsmessaging'><span class="section-number">2.6 </span>Locking vs. messaging</a>
      </li>
      <li>
        <a href='chap05.html#introotl-messagelooprequired'><span class="section-number">2.7 </span>Message loop required</a>
        <ul>
          <li>
            <a href='chap05.html#introotl-messagelooprequired-console'><span class="section-number">2.7.1 </span>OmniThreadLibrary and console</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-omnithreadlibrary-task-started-from-another-task'><span class="section-number">2.7.2 </span>OmniThreadLibrary task started from another task</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-omnithreadlibrary-task-started-from-a-tthread'><span class="section-number">2.7.3 </span>OmniThreadLibrary task started from a TThread</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap05.html#introotl-tomnivalue'><span class="section-number">2.8 </span>TOmniValue</a>
        <ul>
          <li>
            <a href='chap05.html#leanpub-auto-data-access'><span class="section-number">2.8.1 </span>Data access</a>
          </li>
          <li>
            <a href='chap05.html#introotl-tomnivalue-typetesting'><span class="section-number">2.8.2 </span>Type testing</a>
          </li>
          <li>
            <a href='chap05.html#introotl-tomnivalue-clearing'><span class="section-number">2.8.3 </span>Clearing the content</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-operators'><span class="section-number">2.8.4 </span>Operators</a>
          </li>
          <li>
            <a href='chap05.html#introotl-tomnivalue-generictypes'><span class="section-number">2.8.5 </span>Using with generic types</a>
          </li>
          <li>
            <a href='chap05.html#introotl-tomnivalue-array'><span class="section-number">2.8.6 </span>Array access</a>
          </li>
          <li>
            <a href='chap05.html#introotl-tomnivalue-records'><span class="section-number">2.8.7 </span>Handling records</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-object-ownership'><span class="section-number">2.8.8 </span>Object ownership</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-working-with-tvalue'><span class="section-number">2.8.9 </span>Working with TValue</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-low-level-methods'><span class="section-number">2.8.10 </span>Low-level methods</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap05.html#leanpub-auto-tomnivalueobj'><span class="section-number">2.9 </span>TOmniValueObj</a>
      </li>
      <li>
        <a href='chap05.html#introotl-fluentinterfaces'><span class="section-number">2.10 </span>Fluent interfaces</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap06.html#highlevel'><span class="section-number">3. </span>High-level multi-threading</a>
    <ul>
      <li>
        <a href='chap06.html#highlevel-introduction'><span class="section-number">3.1 </span>Introduction</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-a-life-cycle-of-an-abstraction'><span class="section-number">3.1.1 </span>A life cycle of an abstraction</a>
          </li>
          <li>
            <a href='chap06.html#highLevel-intro-AnonymousEtAl'><span class="section-number">3.1.2 </span>Anonymous methods, procedures, and methods</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-introduction-pooling'><span class="section-number">3.1.3 </span>Pooling</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-blocking-collection'><span class="section-number">3.2 </span>Blocking collection</a>
        <ul>
          <li>
            <a href='chap06.html#highlevel-blocking-collection-iomniblockingcollection'><span class="section-number">3.2.1 </span>IOmniBlockingCollection</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-blocking-collection-bulk-impexp'><span class="section-number">3.2.2 </span>Bulk import and export</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-blocking-collection-throttling'><span class="section-number">3.2.3 </span>Throttling</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-taskconfig'><span class="section-number">3.3 </span>Task configuration</a>
      </li>
      <li>
        <a href='chap06.html#highlevel-async'><span class="section-number">3.4 </span>Async</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-handling-exceptions'><span class="section-number">3.4.1 </span>Handling exceptions</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-asyncawait'><span class="section-number">3.5 </span>Async/Await</a>
      </li>
      <li>
        <a href='chap06.html#highlevel-future'><span class="section-number">3.6 </span>Future</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-iomnifuturet-interface'><span class="section-number">3.6.1 </span>IOmniFuture&lt;T&gt; interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-completion-detection'><span class="section-number">3.6.2 </span>Completion detection</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-cancellation'><span class="section-number">3.6.3 </span>Cancellation</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-handling-exceptions-1'><span class="section-number">3.6.4 </span>Handling exceptions</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples'><span class="section-number">3.6.5 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-join'><span class="section-number">3.7 </span>Join</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-iomniparalleljoin-interface'><span class="section-number">3.7.1 </span>IOmniParallelJoin interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomnijoinstate-interface'><span class="section-number">3.7.2 </span>IOmniJoinState interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-cancellation-1'><span class="section-number">3.7.3 </span>Cancellation</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-join-exceptions'><span class="section-number">3.7.4 </span>Handling exceptions</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-paralleltask'><span class="section-number">3.8 </span>Parallel task</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-iomniparalleltask-interface'><span class="section-number">3.8.1 </span>IOmniParallelTask interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-example'><span class="section-number">3.8.2 </span>Example</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-handling-exceptions-2'><span class="section-number">3.8.3 </span>Handling exceptions</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-1'><span class="section-number">3.8.4 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-backgroundworker'><span class="section-number">3.9 </span>Background worker</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-basics'><span class="section-number">3.9.1 </span>Basics</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomnibackgroundworker-interface'><span class="section-number">3.9.2 </span>IOmniBackgroundWorker interface</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-backgroundworker-initialization'><span class="section-number">3.9.3 </span>Task initialization</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-work-item-configuration'><span class="section-number">3.9.4 </span>Work item configuration</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-backgroundworker-iomniworkitem'><span class="section-number">3.9.5 </span>Work item interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-2'><span class="section-number">3.9.6 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-pipeline'><span class="section-number">3.10 </span>Pipeline</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-background'><span class="section-number">3.10.1 </span>Background</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-basics-1'><span class="section-number">3.10.2 </span>Basics</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomnipipeline-interface'><span class="section-number">3.10.3 </span>IOmniPipeline interface</a>
            <ul>
              <li>
                <a href='chap06.html#leanpub-auto-example-1'><span class="section-number">3.10.3.1 </span>Example</a>
              </li>
            </ul>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-generators-mutators-and-aggregators'><span class="section-number">3.10.4 </span>Generators, mutators, and aggregators</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-pipeline-throttling'><span class="section-number">3.10.5 </span>Throttling</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-pipeline-parallel'><span class="section-number">3.10.6 </span>Parallel stages</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-pipeline-exceptions'><span class="section-number">3.10.7 </span>Exceptions</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-3'><span class="section-number">3.10.8 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-for'><span class="section-number">3.11 </span>Parallel for</a>
        <ul>
          <li>
            <a href='chap06.html#highlevel-for-iomniparallelsimpleloop'><span class="section-number">3.11.1 </span>IOmniParallelSimpleLoop interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iterating-over-an-array'><span class="section-number">3.11.2 </span>Iterating over an array</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-4'><span class="section-number">3.11.3 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-foreach'><span class="section-number">3.12 </span>ForEach</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-cooperation'><span class="section-number">3.12.1 </span>Cooperation</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iterating-over-'><span class="section-number">3.12.2 </span>Iterating over …</a>
            <ul>
              <li>
                <a href='chap06.html#leanpub-auto-number-ranges'><span class="section-number">3.12.2.1 </span>… Number ranges</a>
              </li>
              <li>
                <a href='chap06.html#leanpub-auto-enumerable-collections'><span class="section-number">3.12.2.2 </span>… Enumerable collections</a>
              </li>
              <li>
                <a href='chap06.html#leanpub-auto-thread-safe-enumerable-collections'><span class="section-number">3.12.2.3 </span>… Thread-safe enumerable collections</a>
              </li>
              <li>
                <a href='chap06.html#leanpub-auto-blocking-collections'><span class="section-number">3.12.2.4 </span>… Blocking collections</a>
              </li>
              <li>
                <a href='chap06.html#leanpub-auto-anything'><span class="section-number">3.12.2.5 </span>… Anything</a>
              </li>
            </ul>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-providing-external-input'><span class="section-number">3.12.3 </span>Providing external input</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomniparallelloop-interface'><span class="section-number">3.12.4 </span>IOmniParallelLoop interface</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-foreach-preserveorder'><span class="section-number">3.12.5 </span>Preserving output order</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-foreach-aggregation'><span class="section-number">3.12.6 </span>Aggregation</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-foreach-cancellation'><span class="section-number">3.12.7 </span>Cancellation</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-foreach-taskinit'><span class="section-number">3.12.8 </span>Task initialization and finalization</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-foreach-exceptions'><span class="section-number">3.12.9 </span>Handling exceptions</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-5'><span class="section-number">3.12.10 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-forkjoin'><span class="section-number">3.13 </span>Fork/Join</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-iomniforkjoin-interface'><span class="section-number">3.13.1 </span>IOmniForkJoin interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomnicompute-interface'><span class="section-number">3.13.2 </span>IOmniCompute interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomnicomputet-interface'><span class="section-number">3.13.3 </span>IOmniCompute&lt;T&gt; interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-exceptions'><span class="section-number">3.13.4 </span>Exceptions</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-6'><span class="section-number">3.13.5 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-map'><span class="section-number">3.14 </span>Map</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-iomniparallelmappert1t2-interface'><span class="section-number">3.14.1 </span>IOmniParallelMapper&lt;T1,T2&gt; interface</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-timedtask'><span class="section-number">3.15 </span>Timed task</a>
        <ul>
          <li>
            <a href='chap06.html#highlevel-timedtask-iomnitimedtask'><span class="section-number">3.15.1 </span>IOmniTimedTask interface</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap07.html#lowlevel'><span class="section-number">4. </span>Low-level multi-threading</a>
    <ul>
      <li>
        <a href='chap07.html#leanpub-auto-low-level-for-the-impatient'><span class="section-number">4.1 </span>Low-level for the impatient</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-fourways'><span class="section-number">4.2 </span>Four ways to create a task</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-iomnitaskcontrol'><span class="section-number">4.3 </span>IOmniTaskControl and IOmniTask interfaces</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-taskControllerOwner'><span class="section-number">4.4 </span>Task controller needs an owner</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-communication'><span class="section-number">4.5 </span>Communication subsystem</a>
      </li>
      <li>
        <a href='chap07.html#leanpub-auto-processor-groups-and-numa-nodes'><span class="section-number">4.6 </span>Processor groups and NUMA nodes</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-threadpool'><span class="section-number">4.7 </span>Thread pooling</a>
        <ul>
          <li>
            <a href='chap07.html#leanpub-auto-execution-flow'><span class="section-number">4.7.1 </span>Execution flow</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-threadpool-interface'><span class="section-number">4.7.2 </span>IOmniThreadPool interface</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-threadpool-exitcode'><span class="section-number">4.7.3 </span>Task exit code</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-threadpool-monitoring'><span class="section-number">4.7.4 </span>Monitoring thread pool operations</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-processor-groups-and-numa-nodes-1'><span class="section-number">4.7.5 </span>Processor groups and NUMA nodes</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap07.html#lowlevel-lockfree'><span class="section-number">4.8 </span>Lock-free collections</a>
        <ul>
          <li>
            <a href='chap07.html#lowlevel-lockfree-boundedstack'><span class="section-number">4.8.1 </span>Bounded Stack</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-lockfree-boundedqueue'><span class="section-number">4.8.2 </span>Bounded queue</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-lockfree-messagequeue'><span class="section-number">4.8.3 </span>Message queue</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-lockfree-dynamicqueue'><span class="section-number">4.8.4 </span>Dynamic queue</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-lockfree-observing'><span class="section-number">4.8.5 </span>Observing lock-free collections</a>
            <ul>
              <li>
                <a href='chap07.html#leanpub-auto-examples-7'><span class="section-number">4.8.5.1 </span>Examples</a>
              </li>
            </ul>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-benchmarks'><span class="section-number">4.8.6 </span>Benchmarks</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap07.html#lowlevel-eventmonitor'><span class="section-number">4.9 </span>Event monitor</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-simpletasks'><span class="section-number">4.10 </span>Simple tasks</a>
        <ul>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-name'><span class="section-number">4.10.1 </span>Name</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-uniqueid'><span class="section-number">4.10.2 </span>UniqueID</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-parameters'><span class="section-number">4.10.3 </span>Parameters</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-termination'><span class="section-number">4.10.4 </span>Termination</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-exitcode'><span class="section-number">4.10.5 </span>ExitCode</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-taskexceptions'><span class="section-number">4.10.6 </span>Exceptions</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-communication'><span class="section-number">4.10.7 </span>Sending messages to a task</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-receiving'><span class="section-number">4.10.8 </span>Receiving messages from a task</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-chainto'><span class="section-number">4.10.9 </span>ChainTo</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-joinleave'><span class="section-number">4.10.10 </span>Join / Leave</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-monitorwith'><span class="section-number">4.10.11 </span>MonitorWith / RemoveMonitor</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-enforced'><span class="section-number">4.10.12 </span>Enforced</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-unobserved'><span class="section-number">4.10.13 </span>Unobserved</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-cancellationtoken'><span class="section-number">4.10.14 </span>Cancellation token / CancelWith</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-tasklock'><span class="section-number">4.10.15 </span>Lock / WithLock</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-counter'><span class="section-number">4.10.16 </span>WithCounter</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-setpriority'><span class="section-number">4.10.17 </span>SetPriority</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-setqueuesize'><span class="section-number">4.10.18 </span>SetQueueSize</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap07.html#lowlevel-tomniworker'><span class="section-number">4.11 </span>TOmniWorker tasks</a>
        <ul>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-waitforinit'><span class="section-number">4.11.1 </span>WaitForInit</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-task'><span class="section-number">4.11.2 </span>Task</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-communication'><span class="section-number">4.11.3 </span>Receiving messages</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-registercomm'><span class="section-number">4.11.4 </span>RegisterComm</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-tomniworkerinvoke'><span class="section-number">4.11.5 </span>Invoke</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-msgwait'><span class="section-number">4.11.6 </span>Windows message &amp; APC processing</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-timers'><span class="section-number">4.11.7 </span>Timers</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-terminateWhen'><span class="section-number">4.11.8 </span>TerminateWhen</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-userdata'><span class="section-number">4.11.9 </span>UserData</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap07.html#lowlevel-taskgroup'><span class="section-number">4.12 </span>Task groups</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-iomnitask'><span class="section-number">4.13 </span>IOmniTask interface</a>
        <ul>
          <li>
            <a href='chap07.html#leanpub-auto-name-and-id'><span class="section-number">4.13.1 </span>Name and ID</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-parameters'><span class="section-number">4.13.2 </span>Parameters</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-termination'><span class="section-number">4.13.3 </span>Termination</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-exitstatus'><span class="section-number">4.13.4 </span>Exit status</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-exceptions-1'><span class="section-number">4.13.5 </span>Exceptions</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-communication'><span class="section-number">4.13.6 </span>Communication</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-timers'><span class="section-number">4.13.7 </span>Timers</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-registerwaitobject'><span class="section-number">4.13.8 </span>RegisterWaitObject</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-cancellationtoken'><span class="section-number">4.13.9 </span>CancellationToken</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-lock'><span class="section-number">4.13.10 </span>Lock</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-counter'><span class="section-number">4.13.11 </span>Counter</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-processor-groups-and-numa-nodes-2'><span class="section-number">4.13.12 </span>Processor groups and NUMA nodes</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-internal-and-obsolete-functions'><span class="section-number">4.13.13 </span>Internal and obsolete functions</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap08.html#synch'><span class="section-number">5. </span>Synchronization</a>
    <ul>
      <li>
        <a href='chap08.html#synch-criticalsections'><span class="section-number">5.1 </span>Critical sections</a>
        <ul>
          <li>
            <a href='chap08.html#synch-criticalsections-iomnicriticalsection'><span class="section-number">5.1.1 </span>IOmniCriticalSection</a>
          </li>
          <li>
            <a href='chap08.html#synch-criticalsections-tomnics'><span class="section-number">5.1.2 </span>TOmniCS</a>
          </li>
          <li>
            <a href='chap08.html#synch-criticalsections-lockedt'><span class="section-number">5.1.3 </span>Locked&lt;T&gt;</a>
            <ul>
              <li>
                <a href='chap08.html#leanpub-auto-why-not-use-tmonitor'><span class="section-number">5.1.3.1 </span>Why not use TMonitor?</a>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap08.html#synch-tomnimrew'><span class="section-number">5.2 </span>TOmniMREW</a>
      </li>
      <li>
        <a href='chap08.html#synch-cancellationtoken'><span class="section-number">5.3 </span>Cancellation token</a>
      </li>
      <li>
        <a href='chap08.html#synch-waitablevalue'><span class="section-number">5.4 </span>Waitable value</a>
      </li>
      <li>
        <a href='chap08.html#synch-inversesemaphore'><span class="section-number">5.5 </span>Inverse semaphore</a>
      </li>
      <li>
        <a href='chap08.html#synch-initialization'><span class="section-number">5.6 </span>Initialization</a>
        <ul>
          <li>
            <a href='chap08.html#synch-initialization-pessimistic'><span class="section-number">5.6.1 </span>Pessimistic initialization</a>
          </li>
          <li>
            <a href='chap08.html#synch-initialization-optimistic'><span class="section-number">5.6.2 </span>Optimistic initialization</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap08.html#synch-twaitfor'><span class="section-number">5.7 </span>TWaitFor</a>
      </li>
      <li>
        <a href='chap08.html#synch-tomnilockmanager'><span class="section-number">5.8 </span>TOmniLockManager&lt;K&gt;</a>
      </li>
      <li>
        <a href='chap08.html#synch-tomnisinglethreadusechecker'><span class="section-number">5.9 </span>TOmniSingleThreadUseChecker</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap09.html#misc'><span class="section-number">6. </span>Miscellaneous</a>
    <ul>
      <li>
        <a href='chap09.html#misc-tOmniTwoWayChannel'><span class="section-number">6.1 </span>TOmniTwoWayChannel</a>
      </li>
      <li>
        <a href='chap09.html#misc-tomnivaluecontainer'><span class="section-number">6.2 </span>TOmniValueContainer</a>
      </li>
      <li>
        <a href='chap09.html#misc-tomnicounter'><span class="section-number">6.3 </span>TOmniCounter</a>
      </li>
      <li>
        <a href='chap09.html#misc-TOmniAlignedInt32'><span class="section-number">6.4 </span>TOmniAlignedInt32 and TOmniAlignedInt64</a>
      </li>
      <li>
        <a href='chap09.html#misc-tomnirecordwrapper'><span class="section-number">6.5 </span>TOmniRecordWrapper</a>
      </li>
      <li>
        <a href='chap09.html#misc-tomnirecord'><span class="section-number">6.6 </span>TOmniRecord</a>
      </li>
      <li>
        <a href='chap09.html#misc-iomniautodestroyobject'><span class="section-number">6.7 </span>IOmniAutoDestroyObject</a>
      </li>
      <li>
        <a href='chap09.html#misc-iomniintegerset'><span class="section-number">6.8 </span>IOmniIntegerSet</a>
      </li>
      <li>
        <a href='chap09.html#misc-environment'><span class="section-number">6.9 </span>Environment</a>
        <ul>
          <li>
            <a href='chap09.html#leanpub-auto-iomniaffinity'><span class="section-number">6.9.1 </span>IOmniAffinity</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap10.html#howto'><span class="section-number">7. </span>How-to</a>
    <ul>
      <li>
        <a href='chap10.html#howto-backgroundFileScanning'><span class="section-number">7.1 </span>Background file scanning</a>
      </li>
      <li>
        <a href='chap10.html#howto-webDownload'><span class="section-number">7.2 </span>Web download and database storage</a>
      </li>
      <li>
        <a href='chap10.html#howto-parallelForSyncOut'><span class="section-number">7.3 </span>Parallel for with synchronized output</a>
      </li>
      <li>
        <a href='chap10.html#howto-parallelForTaskInit'><span class="section-number">7.4 </span>Using taskIndex and task initializer in parallel for</a>
      </li>
      <li>
        <a href='chap10.html#howto-listPartitioning'><span class="section-number">7.5 </span>Background worker and list partitioning</a>
      </li>
      <li>
        <a href='chap10.html#howto-parallelDataProduction'><span class="section-number">7.6 </span>Parallel data production</a>
      </li>
      <li>
        <a href='chap10.html#howto-connectionPool'><span class="section-number">7.7 </span>Building a connection pool</a>
        <ul>
          <li>
            <a href='chap10.html#leanpub-auto-from-theory-to-practice'><span class="section-number">7.7.1 </span>From theory to practice</a>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-running-the-demo'><span class="section-number">7.7.2 </span>Running the demo</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap10.html#howto-quickSortParallelMax'><span class="section-number">7.8 </span>QuickSort and parallel max</a>
        <ul>
          <li>
            <a href='chap10.html#leanpub-auto-quicksort'><span class="section-number">7.8.1 </span>QuickSort</a>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-parallel-max'><span class="section-number">7.8.2 </span>Parallel max</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap10.html#howto-parallelSearch'><span class="section-number">7.9 </span>Parallel search in a tree</a>
      </li>
      <li>
        <a href='chap10.html#howto-multiFrame'><span class="section-number">7.10 </span>Multiple workers with multiple frames</a>
        <ul>
          <li>
            <a href='chap10.html#leanpub-auto-the-worker'><span class="section-number">7.10.1 </span>The worker</a>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-the-frame'><span class="section-number">7.10.2 </span>The frame</a>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-the-form'><span class="section-number">7.10.3 </span>The form</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap10.html#howto-databases'><span class="section-number">7.11 </span>OmniThreadLibrary and databases</a>
        <ul>
          <li>
            <a href='chap10.html#leanpub-auto-database-model'><span class="section-number">7.11.1 </span>Database model</a>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-frame-and-worker'><span class="section-number">7.11.2 </span>Frame and worker</a>
            <ul>
              <li>
                <a href='chap10.html#leanpub-auto-connecting-to-the-database'><span class="section-number">7.11.2.1 </span>Connecting to the database</a>
              </li>
              <li>
                <a href='chap10.html#leanpub-auto-retrieving-the-data'><span class="section-number">7.11.2.2 </span>Retrieving the data</a>
              </li>
            </ul>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-main-program'><span class="section-number">7.11.3 </span>Main program</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap10.html#howto-com'><span class="section-number">7.12 </span>OmniThreadLibrary and COM/OLE</a>
      </li>
      <li>
        <a href='chap10.html#howto-mqtthread'><span class="section-number">7.13 </span>Using a message queue with a TThread worker</a>
        <ul>
          <li>
            <a href='chap10.html#leanpub-auto-sending-data-from-multiple-producers-to-a-single-worker'><span class="section-number">7.13.1 </span>Sending data from multiple producers to a single worker</a>
            <ul>
              <li>
                <a href='chap10.html#leanpub-auto-initialization-and-cleanup'><span class="section-number">7.13.1.1 </span>Initialization and cleanup</a>
              </li>
              <li>
                <a href='chap10.html#leanpub-auto-sending-data-to-the-worker'><span class="section-number">7.13.1.2 </span>Sending data to the worker</a>
              </li>
              <li>
                <a href='chap10.html#leanpub-auto-receiving-the-data'><span class="section-number">7.13.1.3 </span>Receiving the data</a>
              </li>
            </ul>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-sending-data-from-a-worker-to-a-form'><span class="section-number">7.13.2 </span>Sending data from a worker to a form</a>
            <ul>
              <li>
                <a href='chap10.html#leanpub-auto-initialization-and-cleanup-1'><span class="section-number">7.13.2.1 </span>Initialization and cleanup</a>
              </li>
              <li>
                <a href='chap10.html#leanpub-auto-sending-data-to-the-form'><span class="section-number">7.13.2.2 </span>Sending data to the form</a>
              </li>
              <li>
                <a href='chap10.html#leanpub-auto-receiving-the-data-1'><span class="section-number">7.13.2.3 </span>Receiving the data</a>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap11.html#appendix-units'>A. Units</a>
  </li>
  <li>
    <a href='chap12.html#demos'>B. Demo applications</a>
  </li>
  <li>
    <a href='chap13.html#examples'>C. Examples</a>
  </li>
  <li>
    <a href='chap14.html#appendix-hooking'>D. Hooking into OmniThreadLibrary</a>
    <ul>
      <li>
        <a href='chap14.html#leanpub-auto-exception-notifications'>Exception notifications</a>
      </li>
      <li>
        <a href='chap14.html#leanpub-auto-thread-notifications'>Thread notifications</a>
      </li>
      <li>
        <a href='chap14.html#leanpub-auto-pool-notifications'>Pool notifications</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap15.html#highlevel-foreach-internals'>E. ForEach internals</a>
    <ul>
      <li>
        <a href='chap15.html#leanpub-auto-source-provider'>Source provider</a>
      </li>
      <li>
        <a href='chap15.html#leanpub-auto-data-manager'>Data manager</a>
      </li>
      <li>
        <a href='chap15.html#leanpub-auto-local-queue'>Local queue</a>
      </li>
      <li>
        <a href='chap15.html#leanpub-auto-output-ordering'>Output ordering</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap16.html#leanpub-auto-f-hyperlinks'>F. Hyperlinks</a>
  </li>
  <li>
    <a href='chap17.html#leanpub-endnotes'>Notes</a>
  </li>
</ul>

</ol>
</div>
<div id="leanpub-main" class="kramdown">
<h2 id="highlevel">
<span class="section-number">3. </span>High-level multi-threading</h2>

<p>Face it – multi-threading programming is hard. It is hard to design a multi-threaded program, it is hard to write and test it and it is <em>insanely</em> hard to debug it. To ease this problem, OmniThreadLibrary introduces several pre-packaged multi-threading solutions; so-called <em>abstractions</em>. </p>

<p>The idea behind the high-level abstractions is that the user should just choose appropriate abstraction and write the worker code, while the OmniThreadLibrary provides the framework that implements the tricky multi-threaded parts, takes care of synchronisation and so on.</p>


<h3 id="highlevel-introduction">
<span class="section-number">3.1 </span>Introduction</h3>

<p>High-level abstractions are implemented in the <em>OtlParallel</em> unit. They are all created through the factory class <code>Parallel</code>. High-level code intensively uses anonymous methods and generics which makes Delphi 2009 the minimum supported version. As the implementation of generics in D2009 and D2010 is not very stable, I’d recommend using at least Delphi XE.</p>

<h4 id="leanpub-auto-a-life-cycle-of-an-abstraction">
<span class="section-number">3.1.1 </span>A life cycle of an abstraction</h4>

<p>Typical factory from the <code>Parallel</code> class returns an interface. For example, <code>Parallel</code> implements five <code>Join</code> overloads which create a <a href="chap06.html#highlevel-join"><em>Join</em></a> abstraction.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">Join</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">Join</code><code class="p">(</code><code class="k">const</code> <code class="n">task1</code><code class="o">,</code> <code class="n">task2</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">3 </code>  <code class="n">IOmniParallelJoin</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">Join</code><code class="p">(</code><code class="k">const</code> <code class="n">task1</code><code class="o">,</code> <code class="n">task2</code><code class="o">:</code> <code class="n">TOmniJoinDelegate</code><code class="p">)</code><code class="o">:</code>
<code class="lineno">5 </code>  <code class="n">IOmniParallelJoin</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">6 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">Join</code><code class="p">(</code><code class="k">const</code> <code class="n">tasks</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">7 </code>  <code class="n">IOmniParallelJoin</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">8 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">Join</code><code class="p">(</code><code class="k">const</code> <code class="n">tasks</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">TOmniJoinDelegate</code><code class="p">)</code><code class="o">:</code>
<code class="lineno">9 </code>  <code class="n">IOmniParallelJoin</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<p>Important fact to keep in mind is that the <em>Join</em> abstraction (or any other abstraction returned from any of the <code>Parallel</code> factories) will only be alive as long as this interface is not destroyed. For example, the following code fragment will function fine.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">Test_OK</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="n">Parallel</code><code class="o">.</code><code class="n">Join</code><code class="p">(</code>
<code class="lineno"> 4 </code>    <code class="k">procedure</code>
<code class="lineno"> 5 </code>    <code class="k">begin</code>
<code class="lineno"> 6 </code>      <code class="nf">Sleep</code><code class="p">(</code><code class="mi">10000</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">end</code><code class="o">,</code>
<code class="lineno"> 8 </code>    <code class="k">procedure</code>
<code class="lineno"> 9 </code>    <code class="k">begin</code>
<code class="lineno">10 </code>      <code class="nf">Sleep</code><code class="p">(</code><code class="mi">15000</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="k">end</code>
<code class="lineno">13 </code>  <code class="p">)</code><code class="o">.</code><code class="n">Execute</code><code class="o">;</code>
<code class="lineno">14 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The interface returned from the <code>Parallel.Join</code> call is stored in a hidden variable which will only be destroyed while executing the <code>end</code> statement of the <code>Test_OK</code> procedure. As the <code>Execute</code> waits for all subtasks to complete, <code>Join</code> will complete its execution before the <code>end</code> is executed and before the interface is destroyed. </p>

<p>Modify the code slightly and it will not work anymore.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">Test_Fail</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="n">Parallel</code><code class="o">.</code><code class="n">Join</code><code class="p">(</code>
<code class="lineno"> 4 </code>    <code class="k">procedure</code>
<code class="lineno"> 5 </code>    <code class="k">begin</code>
<code class="lineno"> 6 </code>      <code class="nf">Sleep</code><code class="p">(</code><code class="mi">10000</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">end</code><code class="o">,</code>
<code class="lineno"> 8 </code>    <code class="k">procedure</code>
<code class="lineno"> 9 </code>    <code class="k">begin</code>
<code class="lineno">10 </code>      <code class="nf">Sleep</code><code class="p">(</code><code class="mi">15000</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="k">end</code>
<code class="lineno">13 </code>  <code class="p">)</code><code class="o">.</code><code class="n">NoWait</code><code class="o">.</code><code class="n">Execute</code><code class="o">;</code>
<code class="lineno">14 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>Because of the <code>NoWait</code> modifier, <code>Execute</code> will not wait for subtasks to complete but will return immediately. Next, the code behind the <code>end</code> will be executed and will destroy the abstraction while the subtasks are still running. </p>

<p>In such cases, it is important to keep the interface in a global field (typically it will be stored inside a form or another object) which will stay alive until the abstraction has stopped.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">Test_OK_Again</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="n">FJoin</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">Join</code><code class="p">(</code>
<code class="lineno"> 4 </code>    <code class="k">procedure</code>
<code class="lineno"> 5 </code>    <code class="k">begin</code>
<code class="lineno"> 6 </code>      <code class="nf">Sleep</code><code class="p">(</code><code class="mi">10000</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">end</code><code class="o">,</code>
<code class="lineno"> 8 </code>    <code class="k">procedure</code>
<code class="lineno"> 9 </code>    <code class="k">begin</code>
<code class="lineno">10 </code>      <code class="nf">Sleep</code><code class="p">(</code><code class="mi">15000</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="k">end</code>
<code class="lineno">13 </code>  <code class="p">)</code><code class="o">.</code><code class="n">NoWait</code><code class="o">.</code><code class="n">Execute</code><code class="o">;</code>
<code class="lineno">14 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>This leads to a new problem – when should this interface be destroyed? The answer depends on the abstraction used. Some abstractions provide <code>OnStop</code> method which can be used for this purpose. For other abstractions, you should use <em>termination handler</em> of the <a href="chap06.html#highlevel-taskconfig">task configuration block</a>.</p>

<h4 id="highLevel-intro-AnonymousEtAl">
<span class="section-number">3.1.2 </span>Anonymous methods, procedures, and methods</h4>

<p>High-level abstractions are very much based on anonymous methods. They are used all over the <em>OtlParallel</em> unit and they will also be used in your own code as they provide the simplest way to interact with the high-level threading. All of delegates (pieces of code that you ‘plug in’ into the high-level infrastructure) are declared as anonymous methods.</p>

<p>That, however, does not force you to write anonymous methods to use high-level multi-threading. Thanks to the Delphi compiler, you can always provide a normal function/procedure or a method when an anonymous method is required. </p>

<p>For example, let’s look at the <code>IOmniWorkItemConfig</code> interface. It defines (along with other stuff) method <code>OnExecute</code> which accepts a delegate of type <code>TOmniBackgroundWorkerDelegate</code>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">TOmniBackgroundWorkerDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code> <code class="p">(</code>
<code class="lineno">2 </code>  <code class="k">const</code> <code class="n">workItem</code><code class="o">:</code> <code class="n">IOmniWorkItem</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">3 </code>
<code class="lineno">4 </code><code class="n">IOmniWorkItemConfig</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno">5 </code>  <code class="k">function</code>  <code class="nf">OnExecute</code><code class="p">(</code><code class="k">const</code> <code class="n">aTask</code><code class="o">:</code> <code class="n">TOmniBackgroundWorkerDelegate</code><code class="p">)</code><code class="o">:</code>
<code class="lineno">6 </code>    <code class="n">IOmniWorkItemConfig</code><code class="o">;</code>
<code class="lineno">7 </code>  <code class="o">...</code>
<code class="lineno">8 </code><code class="k">end</code><code class="o">;</code> 
</pre></div>

</figure>

<p>Let’s assume a variable of the appropriate type, <code>config: IOmniWorkItemConfig</code>. You can then call the <code>OnExecute</code> method using an anonymous method.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">config</code><code class="o">.</code><code class="n">OnExecute</code><code class="p">(</code>
<code class="lineno">2 </code>  <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">workItem</code><code class="o">:</code> <code class="n">IOmniWorkItem</code><code class="p">)</code>
<code class="lineno">3 </code>  <code class="k">begin</code>
<code class="lineno">4 </code>    <code class="o">...</code>
<code class="lineno">5 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>Alternatively, you could declare a ‘normal’ procedure with the same <em>signature</em> (with the same parameters) and pass it to the <code>OnExecute</code> call.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">OnConfigExecute</code><code class="p">(</code><code class="k">const</code> <code class="n">workItem</code><code class="o">:</code> <code class="n">IOmniWorkItem</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="o">...</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">5 </code>
<code class="lineno">6 </code><code class="n">config</code><code class="o">.</code><code class="n">OnExecute</code><code class="p">(</code><code class="n">OnConfigExecute</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>The third option is to pass a method of some class to the <code>OnExecute</code>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TMyClass</code><code class="o">.</code><code class="nf">OnConfigExecute</code><code class="p">(</code><code class="k">const</code> <code class="n">workItem</code><code class="o">:</code> <code class="n">IOmniWorkItem</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="o">...</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">5 </code>
<code class="lineno">6 </code><code class="k">procedure</code> <code class="nc">TMyClass</code><code class="o">.</code><code class="nf">DoConfig</code><code class="o">;</code>
<code class="lineno">7 </code><code class="k">begin</code>
<code class="lineno">8 </code>  <code class="n">config</code><code class="o">.</code><code class="n">OnExecute</code><code class="p">(</code><code class="n">OnConfigExecute</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">9 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>These three options are valid whenever an anonymous method delegate can be used.</p>

<h4 id="highlevel-introduction-pooling">
<span class="section-number">3.1.3 </span>Pooling</h4>

<p>Starting a thread is a relatively slow operation, which is why threads, used in the high-level abstractions are not constantly created and destroyed. Rather than that, they are allocated from a <a href="chap07.html#lowlevel-threadpool">thread pool</a>.</p>

<p>All high-level abstractions are using the same thread pool, <code>GlobalParallelPool</code>. It has public visibility – just in case you have to configure its parameters.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">GlobalParallelPool</code><code class="o">:</code> <code class="n">IOmniThreadPool</code><code class="o">;</code>
</pre></div>

</figure>

<p>This behaviour can be overridden by using the <a href="chap06.html#highlevel-taskconfig">task configuration block</a>.</p>

<p>The following rules hold for all tasks created by the high-level abstractions:</p>

<ul>
  <li>If a task configuration block is not specified, task is created in the <code>OtlParallel.GlobalParallelPool</code> pool.</li>
  <li>If a task configuration block is specified:
    <ul>
      <li>If <code>ThreadPool(aPool)</code> is called, task is created in the <code>aPool</code> pool.</li>
      <li>If <code>ThreadPool(nil)</code> is called, task is created in the default <code>OtlThreadPool.GlobalOmniThreadPool</code> pool.</li>
      <li>If <code>NoThreadPool</code> is called, task is not created in a pool but instead
uses a newly created thread (IOW, a <a href="chap07.html#lowlevel"><code>Run</code></a> is used instead of a <a href="chap07.html#lowlevel-threadpool"><code>Schedule</code></a>).</li>
      <li>Otherwise, task is created in the <code>OtlParallel.GlobalParallelPool</code> pool (same as when a task configuration block is not specified).</li>
    </ul>
  </li>
</ul>


<div class="page-break"></div>
<h3 id="highlevel-blocking-collection">
<span class="section-number">3.2 </span>Blocking collection</h3>

<p>The <em>blocking collection</em> is a Delphi clone of <a href="http://msdn.microsoft.com/en-us/library/dd997371.aspx">.NET 4 BlockingCollection</a>.	 It is a thread-safe collection that provides multiple simultaneous readers and writers. This implementation of blocking collection works only with the <a href="chap05.html#introotl-tomnivalue"><code>TOmniValue</code></a> elements, which is not a big limitation provided that TOmniValue can store anything, including a class, an interface and a record.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 291px;">
    <img src="images/highlevel----blockingCollection.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<p>
  <em>See also <a href="chap12.html#demos">demo</a> <code>33_BlockingCollection</code>.</em>
</p>

<div class="page-break"></div>
<h4 id="highlevel-blocking-collection-iomniblockingcollection">
<span class="section-number">3.2.1 </span>IOmniBlockingCollection</h4>

<p>The blocking collecting is exposed as an interface that lives in the <em>OtlCollections</em> unit.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">IOmniBlockingCollection</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 2 </code>  <code class="k">procedure</code> <code class="nf">Add</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="k">procedure</code> <code class="nf">CompleteAdding</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="k">function</code>  <code class="nf">GetEnumerator</code><code class="o">:</code> <code class="n">IOmniValueEnumerator</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="k">function</code>  <code class="nf">IsCompleted</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="k">function</code>  <code class="nf">IsEmpty</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="k">function</code>  <code class="nf">IsFinalized</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="k">function</code>  <code class="nf">Next</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="k">procedure</code> <code class="nf">ReraiseExceptions</code><code class="p">(</code><code class="n">enable</code><code class="o">:</code> <code class="kt">boolean</code> <code class="o">=</code> <code class="k">true</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">10 </code>  <code class="k">procedure</code> <code class="nf">SetThrottling</code><code class="p">(</code><code class="n">highWatermark</code><code class="o">,</code> <code class="n">lowWatermark</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="k">function</code>  <code class="nf">Take</code><code class="p">(</code><code class="k">var</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="k">function</code>  <code class="nf">TryAdd</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="k">function</code>  <code class="nf">TryTake</code><code class="p">(</code><code class="k">var</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code> 
<code class="lineno">14 </code>    <code class="n">timeout_ms</code><code class="o">:</code> <code class="kt">cardinal</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">15 </code>  <code class="k">property</code> <code class="py">ContainerSubject</code><code class="o">:</code> <code class="n">TOmniContainerSubject</code> 
<code class="lineno">16 </code>    <code class="kp">read</code> <code class="nf">GetContainerSubject</code><code class="o">;</code>
<code class="lineno">17 </code>  <code class="k">property</code> <code class="py">Count</code><code class="o">:</code> <code class="kt">integer</code> <code class="kp">read</code> <code class="nf">GetApproxCount</code><code class="o">;</code>
<code class="lineno">18 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>There’s also a class <code>TOmniBlockingCollection</code> which implements this interface. This class is public and can be used in your code.</p>

<p>The blocking collection works in the following way:</p>

<ul>
  <li>
<code>Add</code> will add new value to the collection (which is internally implemented as a queue). </li>
  <li>
<code>CompleteAdding</code> tells the collection that all data has been added. From now on, calling <code>Add</code> will raise an exception. </li>
  <li>
<code>TryAdd</code> is the same as <code>Add</code> except that it doesn’t raise an exception but returns <code>False</code> if the value can’t be added (if <code>CompleteAdding</code> was already called)</li>
  <li>
<code>IsCompleted</code> returns <code>True</code> after the <code>CompleteAdding</code> has been called.</li>
  <li>
<code>IsEmpty</code> returns <code>True</code> if collection is empty. <sup>[3.07]</sup>
</li>
  <li>
<code>Count</code> returns the number of elements in the collection. <sup>[3.07]</sup>  </li>
  <li>
<code>IsFinalized</code> returns <code>True</code> if <code>CompleteAdding</code> has been called <strong>and</strong> the collection is empty.</li>
  <li>
<code>Next</code> retrieves next element from the collection (by calling <code>Take</code>) and returns it as the result. If <code>Take</code> fails, an <code>ECollectionCompleted</code> exception is raised.</li>
  <li>
<code>ReraiseExceptions</code> enables or disables internal exception-checking flag. Initially, this flag is disabled. When the flag is enabled and <code>Take</code> or <code>TryTake</code> retrieve a <code>TOmniValue</code> holding an exception object, this exception is immediately raised.</li>
  <li>
<code>SetThrottling</code> enables the throttling mechanism. See <a href="chap06.html#highlevel-blocking-collection-throttling">Throttling</a> for more information.</li>
  <li>
<code>Take</code> reads a next value from the collection. If there’s no data in the collection, <code>Take</code> will block until the next value is available. If, however, any other thread calls <code>CompleteAdding</code> while the <code>Take</code> is blocked, <code>Take</code> will unblock and return <code>False</code>. </li>
  <li>
<code>TryTake</code> is the same as <code>Take</code> except that it has a timeout parameter specifying maximum time the call is allowed to wait for the next value. If <code>INFINITE</code> is passed in the timeout parameter, <code>TryTake</code> will block until the data is available or <code>CompleteAdding</code> is called.</li>
  <li>
<code>ContainerSubject</code> property enables the blocking collection to partake in lock-free collection <a href="chap07.html#lowlevel-lockfree-observing">observing</a> mechanism.</li>
</ul>

<p>Enumerator calls <code>Take</code> in the <code>MoveNext</code> method and returns the value returned from <code>Take</code>. Enumerator will therefore block when there is no data in the collection. The usual way to stop the enumerator is to call <code>CompleteAdding</code> which will unblock all pending <code>MoveNext</code> calls and stop enumeration.</p>

<h4 id="highlevel-blocking-collection-bulk-impexp">
<span class="section-number">3.2.2 </span>Bulk import and export</h4>

<p>The <code>TOmniBlockingCollection</code> class implements a set of functions for fast import of large quantity of data, and for simple extraction of all data into an array.   </p>

<aside class="information blurb">
    <p>These funtions are only available in Delphi 2010 and newer. </p>

</aside>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">class</code> <code class="k">function</code> <code class="nf">FromArray</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">values</code><code class="o">:</code> <code class="n">TArray</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 2 </code>  <code class="n">IOmniBlockingCollection</code><code class="o">;</code> <code class="k">inline</code><code class="o">;</code> 
<code class="lineno"> 3 </code><code class="k">class</code> <code class="k">function</code> <code class="nf">FromRange</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">values</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">T</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 4 </code>  <code class="n">IOmniBlockingCollection</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">class</code> <code class="k">function</code> <code class="nf">FromRange</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">collection</code><code class="o">:</code> <code class="n">IEnumerable</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 6 </code>  <code class="n">IOmniBlockingCollection</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code> <code class="k">inline</code><code class="o">;</code>
<code class="lineno"> 7 </code><code class="k">class</code> <code class="k">function</code> <code class="nf">FromRange</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">collection</code><code class="o">:</code> <code class="n">TEnumerable</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 8 </code>  <code class="n">IOmniBlockingCollection</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code> <code class="k">inline</code><code class="o">;</code>
<code class="lineno"> 9 </code><code class="k">class</code> <code class="k">function</code> <code class="nf">ToArray</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">coll</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="p">)</code><code class="o">:</code> <code class="n">TArray</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code>
<code class="lineno">10 </code><code class="k">procedure</code> <code class="nf">AddRange</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">values</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">T</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">11 </code><code class="k">procedure</code> <code class="nf">AddRange</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">collection</code><code class="o">:</code> <code class="n">IEnumerable</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">12 </code><code class="k">procedure</code> <code class="nf">AddRange</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">collection</code><code class="o">:</code> <code class="n">TEnumerable</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<p>The three <code>FromRange&lt;T&gt;</code> overloads <sup>[3.07.6]</sup> create a new <code>IOmniBlockingCollection</code> and populate its content from an array or a collection.</p>

<p>The <code>FromArray&lt;T&gt;</code> function <sup>[3.07.6]</sup> is an alias for the <code>FromRange&lt;T&gt;</code> function accepting an array.</p>

<p>The three `AddRange&lt;T&gt;’ functions <sup>[3.07.6]</sup> keep the current content of the blocking collection intact and add new data to the collection.</p>

<p>The <code>ToArray&lt;T&gt;</code> function returns entire content of the blocking collection repacked into a dynamic array. Returned data is removed from the blocking collection.</p>

<p>
  <em><a href="chap12.html#demos">Demo</a> <code>61_CollectionToArray</code> shows how to use <code>ToArray&lt;T&gt;</code>.</em>
</p>

<p>
  <em><a href="chap12.html#demos">Demo</a> <code>67_ArrayToCollection</code> shows how to use <code>FromArray&lt;T&gt;</code> and <code>FromRange&lt;T&gt;</code>.</em>
</p>

<h4 id="highlevel-blocking-collection-throttling">
<span class="section-number">3.2.3 </span>Throttling</h4>

<p>Normally, a blocking collection can grow without limits and can fill up the available memory. If the algorithm doesn’t prevent this intrinsically, it is sometimes useful to set up <em>throttling</em>, a mechanism which blocks additions when the blocking collection size reaches some predetermined value (<em>high watermark</em>) and which allows additions again when the size reaches another predetermined value (<em>low watermark</em>).</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">SetThrottling</code><code class="p">(</code><code class="n">highWatermark</code><code class="o">,</code> <code class="n">lowWatermark</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>The behaviour of <code>Add</code>, <code>TryAdd</code>, <code>Take</code> and <code>TryTake</code> is modified if the throttling is used.</p>

<p>When <code>Add</code> or <code>TryAdd</code> is called and the number of elements in the blocking collection equals <code>highWatermark</code>, the code blocks. It will only continue if the number of elements in the collection falls below the <code>lowWatermark</code> or if the <code>CompleteAdding</code> is called.</p>

<p>When <code>Take</code> or <code>TryTake</code> take an element from the collection and adding is temporarily blocked because of the throttling and the new number of elements in the collection is now below the <code>lowWatermark</code>, all waiting <code>Add</code> and <code>TryAdd</code> calls will be unblocked.</p>


<h3 id="highlevel-taskconfig">
<span class="section-number">3.3 </span>Task configuration</h3>

<p>High-level abstractions will do most of the hard work for you, but sometimes you’ll still have to apply some configuration to the low-level parallel tasks (entities represented with the <a href="chap05.html#introotl-tasksvsthreads"><code>IOmniTask</code></a> interface). The mechanism for doing low-level configuration is called <em>task configuration block</em>.</p>

<p>Task configuration block, or <code>IOmniTaskConfig</code>, is an interface returned from the <code>Parallel.TaskConfig</code> factory function.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">class</code> <code class="k">function</code> <code class="nc">Parallel</code><code class="o">.</code><code class="nf">TaskConfig</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="bp">Result</code> <code class="o">:=</code> <code class="n">TOmniTaskConfig</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>This interface contains various functions that set up messaging handlers, termination handlers and so on.  All function return interface itself so they can be used in a fluent manner.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">IOmniTaskConfig</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 2 </code>  <code class="k">procedure</code> <code class="nf">Apply</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="k">function</code>  <code class="nf">CancelWith</code><code class="p">(</code>
<code class="lineno"> 4 </code>    <code class="k">const</code> <code class="n">token</code><code class="o">:</code> <code class="n">IOmniCancellationToken</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="k">function</code>  <code class="nf">MonitorWith</code><code class="p">(</code>
<code class="lineno"> 6 </code>    <code class="k">const</code> <code class="n">monitor</code><code class="o">:</code> <code class="n">IOmniTaskControlMonitor</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="k">function</code>  <code class="nf">NoThreadPool</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="k">function</code>  <code class="nf">OnMessage</code><code class="p">(</code>
<code class="lineno"> 9 </code>    <code class="n">eventDispatcher</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">10 </code>  <code class="k">function</code>  <code class="nf">OnMessage</code><code class="p">(</code>
<code class="lineno">11 </code>    <code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniTaskMessageEvent</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="k">function</code>  <code class="nf">OnMessage</code><code class="p">(</code>
<code class="lineno">13 </code>    <code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> 
<code class="lineno">14 </code>    <code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniTaskMessageEvent</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">15 </code>  <code class="k">function</code>  <code class="nf">OnMessage</code><code class="p">(</code>
<code class="lineno">16 </code>    <code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> 
<code class="lineno">17 </code>    <code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniOnMessageFunction</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">18 </code>  <code class="k">function</code>  <code class="nf">OnTerminated</code><code class="p">(</code>
<code class="lineno">19 </code>    <code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniTaskTerminatedEvent</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">20 </code>  <code class="k">function</code>  <code class="nf">OnTerminated</code><code class="p">(</code>
<code class="lineno">21 </code>    <code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniOnTerminatedFunction</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">22 </code>  <code class="k">function</code>  <code class="nf">OnTerminated</code><code class="p">(</code>
<code class="lineno">23 </code>    <code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniOnTerminatedFunctionSimple</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code> 
<code class="lineno">24 </code>    <code class="n">overload</code><code class="o">;</code>
<code class="lineno">25 </code>  <code class="k">function</code>  <code class="nf">SetPriority</code><code class="p">(</code><code class="n">threadPriority</code><code class="o">:</code> <code class="n">TOTLThreadPriority</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code>
<code class="lineno">26 </code>  <code class="k">function</code>  <code class="nf">ThreadPool</code><code class="p">(</code><code class="k">const</code> <code class="n">threadPool</code><code class="o">:</code> <code class="n">IOmniThreadPool</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code>
<code class="lineno">27 </code>  <code class="k">function</code>  <code class="nf">WithCounter</code><code class="p">(</code>
<code class="lineno">28 </code>    <code class="k">const</code> <code class="n">counter</code><code class="o">:</code> <code class="n">IOmniCounter</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code>
<code class="lineno">29 </code>  <code class="k">function</code>  <code class="nf">WithLock</code><code class="p">(</code>
<code class="lineno">30 </code>    <code class="k">const</code> <code class="n">lock</code><code class="o">:</code> <code class="n">TSynchroObject</code><code class="o">;</code> 
<code class="lineno">31 </code>    <code class="n">autoDestroyLock</code><code class="o">:</code> <code class="kt">boolean</code> <code class="o">=</code> <code class="k">true</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">32 </code>  <code class="k">function</code>  <code class="nf">WithLock</code><code class="p">(</code>
<code class="lineno">33 </code>    <code class="k">const</code> <code class="n">lock</code><code class="o">:</code> <code class="n">IOmniCriticalSection</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">34 </code><code class="k">end</code><code class="o">;</code> 
</pre></div>

</figure>

<ul>
  <li>
<code>Apply</code> applies task configuration block to a <a href="chap05.html#introotl-tasksvsthreads">task</a>. It is used internally in the <em>OtlParallel</em> unit.</li>
  <li>
<code>CancelWith</code> shares <a href="chap07.html#lowlevel-simpletasks-cancellationtoken">cancellation token</a> with the task. </li>
  <li>
<code>MonitorWith</code> attaches task to the <a href="chap07.html#lowlevel-simpletasks-monitorwith">monitor</a>.</li>
</ul>

<ul id="highlevel-taskconfig-nothreadpool">
  <li>
<code>NoThreadPool</code> instructs the OtlParallel architecture to create a new thread to execute worker task instead of running task in a thread pool. <sup>[3.07.2]</sup>
</li>
  <li>
<code>OnMessage</code> functions set up message dispatch to an object (for example, a form) or to an event handler. In the latter case, event handler can be set for a specific message ID or for all messages.</li>
  <li>
<code>OnTerminated</code> sets up termination handler which is called when the task terminates.</li>
  <li>
<code>SetPriority</code> specifies the priority for worker tasks. Default priority <em>normal</em> will be used if this method is not called.</li>
  <li>
<code>ThreadPool</code> specifies the thread pool used for executing worker tasks. Default thread pool <code>GlobalParallelPool</code> (singleton, defined in the <em>OtlParallel</em> unit) is used for executing worker tasks if this method is not called. If a <code>nil</code> is passsed
as an argument, default OmniThreadLibrary pool <code>OtlThreadPool.GlobalOmniThreadPool</code> will be used.  </li>
  <li>
<code>WithCounter</code> shares a <a href="chap07.html#lowlevel-simpletasks-counter">counter</a> with the task.</li>
  <li>
<code>WithLock</code> shares a <a href="chap07.html#lowlevel-simpletasks-tasklock">lock object</a> with the task.</li>
</ul>

<p>Examples of task configuration block usage are demonstrated in <a href="chap12.html#demos">demo</a> <em>47_TaskConfig</em>. Some examples are also given in sections describing individual abstractions.</p>


<div class="page-break"></div>
<h3 id="highlevel-async">
<span class="section-number">3.4 </span>Async</h3>

<p><em>Async</em> is the simplest of high-level abstractions and is typically used for <em>fire and forget</em> scenarios. To create an Async task, call Parallel.Async.</p>

<aside>

<div class="figure-wrapper center">
  <figure class="image" style="width: 236px;">
    <img src="images/highlevel----async.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


</aside>

<aside>
  <p><em>When you call <code>Parallel.Async</code>, code is started in a new thread (indicated by the bold vertical line) and both main and background threads continue execution. After some time, background task completes execution and disappears.</em></p>

</aside>

<p>
  <em>See also <a href="chap12.html#demos">demo</a> <code>46_Async</code>.</em>
</p>

<p>Example:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">Parallel</code><code class="o">.</code><code class="n">Async</code><code class="p">(</code>
<code class="lineno">2 </code>  <code class="k">procedure</code>
<code class="lineno">3 </code>  <code class="k">begin</code>
<code class="lineno">4 </code>    <code class="nf">MessageBeep</code><code class="p">(</code><code class="mh">$FFFFFFFF</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>This simple program creates a background task with a sole purpose to make some noise. The task is coded as an anonymous method but you can also use a <a href="chap06.html#highLevel-intro-AnonymousEtAl">normal method or a normal procedure</a> for the task code.</p>

<p>The <code>Parallel</code> class defines two <code>Async</code> overloads. The first accepts a parameter-less background task and an optional <a href="chap06.html#highlevel-taskconfig">task configuration block</a> and the second accepts a background task with an <a href="chap05.html#introotl-tasksvsthreads"><code>IOmniTask</code></a> parameter and an optional task configuration block.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniTaskDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code>	
<code class="lineno"> 4 </code>  <code class="n">Parallel</code> <code class="o">=</code> <code class="k">class</code>
<code class="lineno"> 5 </code>    <code class="k">class</code> <code class="k">procedure</code> <code class="nf">Async</code><code class="p">(</code><code class="n">task</code><code class="o">:</code> <code class="n">TProc</code><code class="o">;</code>
<code class="lineno"> 6 </code>      <code class="n">taskConfig</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code> <code class="o">=</code> <code class="k">nil</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">class</code> <code class="k">procedure</code> <code class="nf">Async</code><code class="p">(</code><code class="n">task</code><code class="o">:</code> <code class="n">TOmniTaskDelegate</code><code class="o">;</code>
<code class="lineno"> 8 </code>      <code class="n">taskConfig</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code> <code class="o">=</code> <code class="k">nil</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="o">...</code>
<code class="lineno">10 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The second form is useful if the background code needs access to the <a href="chap05.html#introotl-tasksvsthreads"><code>IOmniTask</code> interface</a>, for example, to send messages to the owner or to execute code in the owner thread (typically that will be the main thread).</p>

<p>The example below uses <em>Async</em> task to fetch the contents of a web page (by calling a mysterious function HttpGet) and then uses <a href="chap07.html#lowlevel-tomniworker-tomniworkerinvoke"><code>Invoke</code></a> to execute a code that logs the length of the result in the main thread.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">Parallel</code><code class="o">.</code><code class="n">Async</code><code class="p">(</code>
<code class="lineno"> 2 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code>
<code class="lineno"> 3 </code>  <code class="k">var</code> 
<code class="lineno"> 4 </code>    <code class="n">page</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="k">begin</code>
<code class="lineno"> 6 </code>    <code class="n">HttpGet</code><code class="p">(</code><code class="s">'otl.17slon.com'</code><code class="o">,</code> <code class="mi">80</code><code class="o">,</code> <code class="s">'tutorials.htm'</code><code class="o">,</code> <code class="n">page</code><code class="o">,</code> <code class="s">''</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="n">task</code><code class="o">.</code><code class="n">Invoke</code><code class="p">(</code>
<code class="lineno"> 8 </code>      <code class="k">procedure</code>
<code class="lineno"> 9 </code>      <code class="k">begin</code>
<code class="lineno">10 </code>        <code class="nc">lbLogAsync</code><code class="o">.</code><code class="nc">Items</code><code class="o">.</code><code class="nf">Add</code><code class="p">(</code><code class="nb">Format</code><code class="p">(</code><code class="s">'Async GET: %d ms; page length = %d'</code><code class="o">,</code> 
<code class="lineno">11 </code>          <code class="p">[</code><code class="nb">time</code><code class="o">,</code> <code class="nb">Length</code><code class="p">(</code><code class="n">page</code><code class="p">)]))</code>
<code class="lineno">12 </code>      <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>The same result could be achieved by sending a message from the background thread to the main thread. In the example below, <a href="chap06.html#highlevel-taskconfig"><code>TaskConfig</code></a> block is used to configure message handler.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">const</code>
<code class="lineno"> 2 </code>  <code class="n">WM_RESULT</code> <code class="o">=</code> <code class="n">WM_USER</code><code class="o">;</code>
<code class="lineno"> 3 </code>	
<code class="lineno"> 4 </code><code class="k">procedure</code> <code class="nf">LogResult</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="k">const</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="n">lbLogAsync</code><code class="o">.</code><code class="n">Items</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="nb">Format</code><code class="p">(</code><code class="s">'Async GET: %d ms; page length = %d'</code><code class="o">,</code> 
<code class="lineno"> 7 </code>    <code class="p">[</code><code class="nb">time</code><code class="o">,</code> <code class="nb">Length</code><code class="p">(</code><code class="n">page</code><code class="p">)]))</code>
<code class="lineno"> 8 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno"> 9 </code>	
<code class="lineno">10 </code><code class="n">Parallel</code><code class="o">.</code><code class="n">Async</code><code class="p">(</code>
<code class="lineno">11 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code>
<code class="lineno">12 </code>  <code class="k">var</code> 
<code class="lineno">13 </code>    <code class="n">page</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code>
<code class="lineno">14 </code>  <code class="k">begin</code>
<code class="lineno">15 </code>    <code class="n">HttpGet</code><code class="p">(</code><code class="s">'otl.17slon.com'</code><code class="o">,</code> <code class="mi">80</code><code class="o">,</code> <code class="s">'tutorials.htm'</code><code class="o">,</code> <code class="n">page</code><code class="o">,</code> <code class="s">''</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">16 </code>    <code class="n">task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="n">WM_RESULT</code><code class="o">,</code> <code class="n">page</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">17 </code>  <code class="k">end</code><code class="o">,</code>
<code class="lineno">18 </code>  <code class="n">TaskConfig</code><code class="o">.</code><code class="n">OnMessage</code><code class="p">(</code><code class="n">WM_RESULT</code><code class="o">,</code> <code class="n">LogResult</code><code class="p">)</code>
<code class="lineno">19 </code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>Let me warn you that in cases where you want to return a result from a background task, <em>Async</em> abstraction is not the most appropriate. You would be better off using a <a href="chap06.html#highlevel-future"><em>Future</em></a>.</p>

<h4 id="leanpub-auto-handling-exceptions">
<span class="section-number">3.4.1 </span>Handling exceptions</h4>

<p>If the background code raises an unhandled exception, OmniThreadLibrary catches this exception and re-raises it in the <code>OnTerminated</code> handler. This way the exception travels from the background thread to the owner thread where it can be processed.</p>

<p>As the <code>OnTerminated</code> handler executes at an unspecified moment when Windows are processing window messages, there is no good way to catch this message with a try..except block. The caller must install its own <code>OnTerminated</code> handler instead and handle exception there.</p>

<p>The following example uses <code>OnTerminated</code> handler to <a href="chap07.html#lowlevel-simpletasks-taskexceptions">detach fatal exception</a> from the task, log the exception details and destroy the exception object. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">Parallel</code><code class="o">.</code><code class="n">Async</code><code class="p">(</code>
<code class="lineno"> 2 </code>  <code class="k">procedure</code>
<code class="lineno"> 3 </code>  <code class="k">begin</code>
<code class="lineno"> 4 </code>    <code class="nf">Sleep</code><code class="p">(</code><code class="mi">1000</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 5 </code>    <code class="k">raise</code> <code class="n">Exception</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="s">'Exception in Async'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="k">end</code><code class="o">,</code>
<code class="lineno"> 7 </code>  <code class="n">Parallel</code><code class="o">.</code><code class="n">TaskConfig</code><code class="o">.</code><code class="n">OnTerminated</code><code class="p">(</code>
<code class="lineno"> 8 </code>    <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="p">)</code>
<code class="lineno"> 9 </code>    <code class="k">var</code>
<code class="lineno">10 </code>      <code class="n">excp</code><code class="o">:</code> <code class="n">Exception</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">begin</code>
<code class="lineno">12 </code>      <code class="k">if</code> <code class="nb">assigned</code><code class="p">(</code><code class="n">task</code><code class="o">.</code><code class="n">FatalException</code><code class="p">)</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno">13 </code>        <code class="n">excp</code> <code class="o">:=</code> <code class="n">task</code><code class="o">.</code><code class="n">DetachException</code><code class="o">;</code>
<code class="lineno">14 </code>        <code class="n">Log</code><code class="p">(</code><code class="s">'Caught async exception %s:%s'</code><code class="o">,</code><code class="p">[</code><code class="n">excp</code><code class="o">.</code><code class="n">ClassName</code><code class="o">,</code> <code class="n">excp</code><code class="o">.</code><code class="n">Message</code><code class="p">])</code><code class="o">;</code>
<code class="lineno">15 </code>        <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">excp</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">16 </code>      <code class="k">end</code><code class="o">;</code>
<code class="lineno">17 </code>    <code class="k">end</code>
<code class="lineno">18 </code>  <code class="p">))</code><code class="o">;</code>
</pre></div>

</figure>

<p>If you don’t install an <code>OnTerminated</code> handler, an exception will be handled by the application-level filter, which will by default cause a message box to appear.</p>

<p>
  <em>See also <a href="chap12.html#demos">demo</a> <code>48_OtlParallelExceptions</code>.</em>
</p>


<div class="page-break"></div>
<h3 id="highlevel-asyncawait">
<span class="section-number">3.5 </span>Async/Await</h3>

<p><em>Async/Await</em> is a simplified version of the <a href="chap06.html#highlevel-async"><em>Async</em></a> abstraction which mimics the <a href="http://blogs.msdn.com/b/pfxteam/archive/2012/04/12/10293335.aspx">.NET Async/Await</a> mechanism.<sup id="fnref-async-await-more"><a href="chap17.html#fn-async-await-more" rel="footnote">4</a></sup></p>

<p><em>Async/Await</em> accepts two parameter less anonymous methods. The first one is executed in a background thread and the second one is executed in the main thread after the background thread has completed its work.</p>

<p>
  <em>See also <a href="chap12.html#demos">demo</a> <code>53_AsyncAwait</code>.</em>
</p>

<p>Using <em>Async/Await</em> you can, for example, create a background operation which is triggered by a click and which re-enables button after the background job has been completed.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TForm1</code><code class="o">.</code><code class="nf">Button1Click</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">button</code><code class="o">:</code> <code class="n">TButton</code><code class="o">;</code>
<code class="lineno"> 4 </code><code class="k">begin</code>
<code class="lineno"> 5 </code>  <code class="n">button</code> <code class="o">:=</code> <code class="n">Sender</code> <code class="k">as</code> <code class="n">TButton</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="n">button</code><code class="o">.</code><code class="n">Caption</code> <code class="o">:=</code> <code class="s">'Working ...'</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="n">button</code><code class="o">.</code><code class="n">Enabled</code> <code class="o">:=</code> <code class="k">false</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="n">Async</code><code class="p">(</code> 
<code class="lineno"> 9 </code>    <code class="c1">// executed in a background thread</code>
<code class="lineno">10 </code>    <code class="k">procedure</code> <code class="k">begin</code>
<code class="lineno">11 </code>      <code class="nf">Sleep</code><code class="p">(</code><code class="mi">5000</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">end</code><code class="p">)</code><code class="o">.</code>
<code class="lineno">13 </code>  <code class="n">Await</code><code class="p">(</code> 
<code class="lineno">14 </code>    <code class="c1">// executed in the main thread after </code>
<code class="lineno">15 </code>    <code class="c1">// the anonymous method passed to </code>
<code class="lineno">16 </code>    <code class="c1">// Async has completed its work</code>
<code class="lineno">17 </code>    <code class="k">procedure</code> <code class="k">begin</code>
<code class="lineno">18 </code>      <code class="nc">button</code><code class="o">.</code><code class="nf">Enabled</code> <code class="o">:=</code> <code class="k">true</code><code class="o">;</code>
<code class="lineno">19 </code>      <code class="n">button</code><code class="o">.</code><code class="n">Caption</code> <code class="o">:=</code> <code class="s">'Done!'</code><code class="o">;</code>
<code class="lineno">20 </code>    <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">21 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<aside class="tip blurb">
    <p>Keep in mind that <a href="chap06.html#highlevel-async"><em>Async</em></a> is invoked by calling <code>Parallel.Async</code> and <a href="chap06.html#highlevel-asyncawait"><em>Async/Await</em></a> by calling <code>Async</code>.</p>

</aside>

<p>Exceptions in the <code>Async</code> part are currently not handled by the OmniThreadLibrary.</p>


<div class="page-break"></div>
<h3 id="highlevel-future">
<span class="section-number">3.6 </span>Future</h3>

<p>A <em>Future</em> is a background calculation that returns a result. To create the abstraction, call <code>Parallel.Future&lt;T&gt;</code> (where <code>T</code> is the type returned from the calculation). This will return a result of type <code>IOmniFuture&lt;T&gt;</code>, which is the interface you will use to work with the background task.</p>

<p>To get the result of the calculation, call the <code>.Value</code> method on the interface returned from the <code>Parallel.Future</code> call.</p>

<aside>

<div class="figure-wrapper center">
  <figure class="image" style="width: 238px;">
    <img src="images/highlevel----future.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


</aside>

<aside>
  <p><em>When you call <code>Parallel.Future</code>, a background task is started immediately. The task continues with its (possibly long) execution and the main thread can do some other work. When you need the result of the background calculation, call the <code>.Value</code> method, which will return the result immediately if it is ready or which will wait for the background code to complete its work if necessary.</em></p>

</aside>

<p>
  <em>See also <a href="chap12.html#demos">demo</a> <code>39_Future</code>.</em>
</p>

<div class="page-break"></div>
<p>Example:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">var</code>
<code class="lineno"> 2 </code>  <code class="n">FCalculation</code><code class="o">:</code> <code class="n">IOmniFuture</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;;</code>
<code class="lineno"> 3 </code>
<code class="lineno"> 4 </code><code class="k">procedure</code> <code class="nf">StartCalculation</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="n">FCalculation</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">Future</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;</code><code class="p">(</code>
<code class="lineno"> 7 </code>    <code class="k">function</code><code class="o">:</code> <code class="nf">integer</code>
<code class="lineno"> 8 </code>    <code class="k">var</code>
<code class="lineno"> 9 </code>      <code class="n">i</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">begin</code>
<code class="lineno">11 </code>      <code class="bp">Result</code> <code class="o">:=</code> <code class="mi">0</code><code class="o">;</code>
<code class="lineno">12 </code>      <code class="k">for</code> <code class="n">i</code> <code class="o">:=</code> <code class="mi">1</code> <code class="k">to</code> <code class="mi">100000</code> <code class="k">do</code>
<code class="lineno">13 </code>        <code class="bp">Result</code> <code class="o">:=</code> <code class="bp">Result</code> <code class="o">+</code> <code class="n">i</code><code class="o">;</code>
<code class="lineno">14 </code>    <code class="k">end</code>
<code class="lineno">15 </code>  <code class="p">)</code><code class="o">;</code>
<code class="lineno">16 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">17 </code>
<code class="lineno">18 </code><code class="k">function</code> <code class="nf">GetResult</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">19 </code><code class="k">begin</code>
<code class="lineno">20 </code>  <code class="bp">Result</code> <code class="o">:=</code> <code class="n">FCalculation</code><code class="o">.</code><code class="n">Value</code><code class="o">;</code>
<code class="lineno">21 </code>  <code class="n">FCalculation</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
<code class="lineno">22 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The <code>Parallel</code> class implements two <code>Future&lt;T&gt;</code> overloads. The first accepts a parameter-less background task and an optional <a href="chap06.html#highlevel-taskconfig">task configuration block</a> and the second accepts a background task with an <a href="chap05.html#introotl-tasksvsthreads"><code>IOmniTask</code></a> parameter and an optional task configuration block.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniFutureDelegate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">function</code><code class="o">:</code> <code class="nf">T</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">TOmniFutureDelegateEx</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="o">=</code> 
<code class="lineno"> 4 </code>    <code class="n">reference</code> <code class="k">to</code> <code class="k">function</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">:</code> <code class="n">T</code><code class="o">;</code>
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code>  <code class="n">Parallel</code> <code class="o">=</code> <code class="k">class</code>
<code class="lineno"> 7 </code>    <code class="k">class</code> <code class="k">function</code> <code class="nf">Future</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">action</code><code class="o">:</code> <code class="n">TOmniFutureDelegate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code>
<code class="lineno"> 8 </code>      <code class="n">taskConfig</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code> <code class="o">=</code> <code class="k">nil</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniFuture</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">class</code> <code class="k">function</code> <code class="nf">Future</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">action</code><code class="o">:</code> <code class="n">TOmniFutureDelegateEx</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code>
<code class="lineno">10 </code>      <code class="n">taskConfig</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code> <code class="o">=</code> <code class="k">nil</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniFuture</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="o">...</code>
<code class="lineno">12 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The second form is useful if the background code needs access to the <a href="chap05.html#introotl-tasksvsthreads"><code>IOmniTask</code></a> interface, for example, to send messages to the owner or to execute code in the owner thread (typically that will be the main thread). See the <a href="chap06.html#highlevel-async"><em>Async</em></a> section for an example. </p>

<p>A Future task always wraps a function of some type. In the example above the function added numbers from <em>1</em> to <em>100000</em> together and returned an integer result. That’s why the Future task was created by calling <code>Parallel.Future&lt;integer&gt;</code> and why the result – the interface that provides a way to manage the task – is declared as <code>IOmniFuture&lt;integer&gt;</code>. But a Future could equally well return a result of any type – a string or a date/time or even a record, class or interface.</p>

<p>The following example is a rewrite of the <a href="chap06.html#highlevel-async"><em>Async</em></a> example. It uses the same mysterious <code>HttpGet</code> function, but it is wrapped in a more flexible way. Function <code>StartHttpGet</code> accepts an url parameter specifying which page to retrieve from the web server. It then creates a future returning a string and passes it a simple code to execute – a one-liner anonymous function that only calls the already known <code>HttpGet</code>.</p>

<p>This example illustrates two important points:</p>

<ul>
  <li>Anonymous methods are great for <em>capturing</em> variables. If you look at the <code>StartHttpGet</code> again, you’ll see that the <em>url</em> parameter is used from two different threads. <code>StartHttpGet</code> is called in the main thread and the anonymous code is executed in the background thread. Still, the parameter somehow makes it across this thread boundary – and that is done by the anonymous method magic.</li>
  <li>Don’t write long and complicated anonymous methods – it is better to call an external method from the anonymous code and make the long and complicated calculation in that external method (or in a code called from that method etc).</li>
</ul>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">var</code>
<code class="lineno"> 2 </code>  <code class="n">FGetFuture</code><code class="o">:</code> <code class="n">IOmniFuture</code><code class="o">&lt;</code><code class="k">string</code><code class="o">&gt;;</code>
<code class="lineno"> 3 </code>
<code class="lineno"> 4 </code><code class="k">function</code> <code class="nf">HttpGet</code><code class="p">(</code><code class="k">const</code> <code class="n">url</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="c1">// this function fetches a page from the web server </code>
<code class="lineno"> 7 </code>  <code class="c1">// and returns its contents</code>
<code class="lineno"> 8 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno"> 9 </code>
<code class="lineno">10 </code><code class="k">procedure</code> <code class="nf">StartHttpGet</code><code class="p">(</code><code class="k">const</code> <code class="n">url</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">11 </code><code class="k">begin</code>
<code class="lineno">12 </code>  <code class="n">FGetFuture</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">Future</code><code class="o">&lt;</code><code class="k">string</code><code class="o">&gt;</code><code class="p">(</code>
<code class="lineno">13 </code>    <code class="k">function</code><code class="o">:</code> <code class="k">string</code>
<code class="lineno">14 </code>    <code class="k">begin</code>
<code class="lineno">15 </code>      <code class="bp">Result</code> <code class="o">:=</code> <code class="nf">HttpGet</code><code class="p">(</code><code class="n">url</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">16 </code>    <code class="k">end</code>
<code class="lineno">17 </code>  <code class="p">)</code><code class="o">;</code>
<code class="lineno">18 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">19 </code>
<code class="lineno">20 </code><code class="k">function</code> <code class="nf">GetResult</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code>
<code class="lineno">21 </code><code class="k">begin</code>
<code class="lineno">22 </code>  <code class="bp">Result</code> <code class="o">:=</code> <code class="n">FGetFuture</code><code class="o">.</code><code class="n">Value</code><code class="o">;</code>
<code class="lineno">23 </code>  <code class="n">FGetFuture</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
<code class="lineno">24 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-iomnifuturet-interface">
<span class="section-number">3.6.1 </span>IOmniFuture&lt;T&gt; interface</h4>

<p>The <code>IOmniFuture&lt;T&gt;</code> interface implements other methods besides the <code>Value</code>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">IOmniFuture</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 3 </code>    <code class="k">procedure</code> <code class="nf">Cancel</code><code class="o">;</code>
<code class="lineno"> 4 </code>    <code class="k">function</code>  <code class="nf">DetachException</code><code class="o">:</code> <code class="n">Exception</code><code class="o">;</code>
<code class="lineno"> 5 </code>    <code class="k">function</code>  <code class="nf">FatalException</code><code class="o">:</code> <code class="n">Exception</code><code class="o">;</code>
<code class="lineno"> 6 </code>    <code class="k">function</code>  <code class="nf">IsCancelled</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">function</code>  <code class="nf">IsDone</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 8 </code>    <code class="k">function</code>  <code class="nf">TryValue</code><code class="p">(</code><code class="n">timeout_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> <code class="k">var</code> <code class="n">value</code><code class="o">:</code> <code class="n">T</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">function</code>  <code class="nf">Value</code><code class="o">:</code> <code class="n">T</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">function</code>  <code class="nf">WaitFor</code><code class="p">(</code><code class="n">timeout_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">11 </code>   <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The interface implements exception-handling functions, cancellation support and functions that check if the background calculation has completed.</p>

<h4 id="leanpub-auto-completion-detection">
<span class="section-number">3.6.2 </span>Completion detection</h4>

<p>When you call the <code>Value</code> function, you don’t know ahead what will happen. If the background code has already calculated the result, the <code>Value</code> call will return immediately. Otherwise, the caller thread will be blocked until the result is available and if you are executing a long calculation (or if the web or database connection did not succeed and is now waiting for a timeout to occur) this may last awhile. If you created the future in the main thread, then your whole application will be blocked until <code>Value</code> returns.</p>

<p>There are few ways around this problem. One is to periodically call the <code>IsDone</code> function. It will return <code>False</code> while the background calculation is still working and <code>True</code> once the result is available. Another option is to call <code>WaitFor</code> with some (small) timeout. <code>WaitFor</code> will wait specified number of milliseconds and will return <code>True</code> if result is available. The third way to achieve the same is to call <code>TryValue</code> periodically. <code>TryValue</code> also waits some specified number of milliseconds and returns <code>True</code> if result is available but in addition it will also return the result in the <em>value</em> parameter.</p>

<p>The fourth and completely different way is to specify a <a href="chap06.html#highlevel-taskconfig">termination handler</a> which will notify you when the background calculation is completed. The following example sets the termination handler to get the value of the background calculation into the memo field and then destroy the <em>Future</em> interface.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">StartHttpGet</code><code class="p">(</code><code class="k">const</code> <code class="n">url</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="n">FGetFuture</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">Future</code><code class="o">&lt;</code><code class="k">string</code><code class="o">&gt;</code><code class="p">(</code>
<code class="lineno"> 4 </code>    <code class="k">function</code><code class="o">:</code> <code class="k">string</code>
<code class="lineno"> 5 </code>    <code class="k">begin</code>
<code class="lineno"> 6 </code>      <code class="bp">Result</code> <code class="o">:=</code> <code class="nf">HttpGet</code><code class="p">(</code><code class="n">url</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">end</code><code class="o">,</code>
<code class="lineno"> 8 </code>    <code class="n">Parallel</code><code class="o">.</code><code class="n">TaskConfig</code><code class="o">.</code><code class="n">OnTerminated</code><code class="p">(</code>
<code class="lineno"> 9 </code>      <code class="k">procedure</code>
<code class="lineno">10 </code>      <code class="k">begin</code>
<code class="lineno">11 </code>        <code class="nc">Memo1</code><code class="o">.</code><code class="nf">Text</code> <code class="o">:=</code> <code class="n">FGetFuture</code><code class="o">.</code><code class="n">Value</code><code class="o">;</code>
<code class="lineno">12 </code>        <code class="n">FGetFuture</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
<code class="lineno">13 </code>      <code class="k">end</code>
<code class="lineno">14 </code>     <code class="p">)</code>
<code class="lineno">15 </code>  <code class="p">)</code><code class="o">;</code>
<code class="lineno">16 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-cancellation">
<span class="section-number">3.6.3 </span>Cancellation</h4>

<p>It is possible to cancel the background execution of the <em>Future</em> before it is completed. The <em>Future</em> uses <a href="chap07.html#lowlevel-simpletasks-cancellationtoken">Cancellation token mechanism</a> to achieve this. Cancellation is cooperative – if the background task does not willingly cancel itself, cancellation will fail.</p>

<p>To cancel a background task, the <em>Future</em> owner (the code that called <code>Parallel.Future</code>) has to call the <code>Cancel</code> method on the <code>IOmniFuture&lt;T&gt;</code> interface. This will signal the cancellation token which the background task must check periodically. To get access to the cancellation token, background code must be declared as a function accepting an <a href="chap05.html#introotl-tasksvsthreads"><code>IOmniTask</code></a> parameter.</p>

<p>The following (pretty much pointless) program illustrates this concept.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">var</code>
<code class="lineno"> 2 </code>  <code class="n">FCountFuture</code><code class="o">:</code> <code class="n">IOmniFuture</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;;</code>
<code class="lineno"> 3 </code>
<code class="lineno"> 4 </code><code class="k">function</code> <code class="nf">CountTo100</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">var</code>
<code class="lineno"> 6 </code>  <code class="n">i</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 7 </code><code class="k">begin</code>
<code class="lineno"> 8 </code>  <code class="k">for</code> <code class="n">i</code> <code class="o">:=</code> <code class="mi">1</code> <code class="k">to</code> <code class="mi">100</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno"> 9 </code>    <code class="nb">Sleep</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="bp">Result</code> <code class="o">:=</code> <code class="n">i</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">if</code> <code class="n">task</code><code class="o">.</code><code class="n">CancellationToken</code><code class="o">.</code><code class="n">IsSignalled</code> <code class="k">then</code>
<code class="lineno">12 </code>      <code class="k">break</code><code class="o">;</code> <code class="c1">//for</code>
<code class="lineno">13 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">14 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">15 </code>
<code class="lineno">16 </code><code class="k">procedure</code> <code class="nf">StartCounting</code><code class="o">;</code>
<code class="lineno">17 </code><code class="k">begin</code>
<code class="lineno">18 </code>  <code class="n">FCountFuture</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">Future</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;</code><code class="p">(</code><code class="n">CountTo100</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">19 </code>  <code class="nb">Sleep</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">20 </code>  <code class="n">FCountFuture</code><code class="o">.</code><code class="n">Cancel</code><code class="o">;</code>
<code class="lineno">21 </code>  <code class="n">FCountFuture</code><code class="o">.</code><code class="n">WaitFor</code><code class="p">(</code><code class="n">INFINITE</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">22 </code>  <code class="n">FCountFuture</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
<code class="lineno">23 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>StartCounting</code> creates a <em>Future</em> which executes <code>CountTo100</code> function in the background. It then sleeps <em>100</em> milliseconds, calls the <code>Cancel</code> function, waits for the <em>Future</em> to terminate and clears the <em>Future</em> interface.</p>

<p><code>CountTo100</code> function counts from <em>1</em> to <em>100</em>. It sleeps for <em>100</em> milliseconds after each number, stores the current counter in the function result and then checks the cancellation token. If it is signaled (meaning that the owner called the <code>Cancel</code> function), it will break out of the for loop.</p>

<p>If you put a breakpoint on the last line of the <code>StartCounting</code> function and run the program, you’ll see that it will be reached almost immediately, proving that the <code>CountTo100</code> did not take <em>10</em> seconds to return a result (<em>100</em> repeats * <em>100</em> milliseconds = <em>10</em> seconds).</p>

<p>You cannot call the <code>Value</code> function if the calculation was cancelled as it would raise an <code>EFutureCancelled</code> exception. If you don’t know whether the <code>Cancel</code> was called or not, you can call the <code>IOmniFuture&lt;T&gt;.IsCancelled</code> and check the result (<code>True</code> = calculation was cancelled).</p>

<h4 id="leanpub-auto-handling-exceptions-1">
<span class="section-number">3.6.4 </span>Handling exceptions</h4>

<p>If the background code raises an unhandled exception (i.e. the exception was not captured in a <code>try</code>..<code>except</code> block), OmniThreadLibrary catches this exception and gracefully completes the background task. When you call the <code>Value</code> function, this exception is re-raised.</p>

<p>This immensely helps with debugging as the background exceptions (exceptions in background threads) are ignored when you run the program without a debugger. By default Delphi does nothing with them – it behaves as if nothing is wrong and that can be quite dangerous. As the <em>Future</em> exceptions are re-raised in the  main thread when the <code>Value</code> is called this makes them equivalent to other exceptions in the main thread.</p>

<p>There are few different ways to handle exceptions in <em>Future</em> and they are easiest explained through the code. First example catches the exception by wrapping the <code>Value</code> call in <code>try</code>..<code>except</code>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">FutureException1</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">future</code><code class="o">:</code> <code class="n">IOmniFuture</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;;</code>
<code class="lineno"> 4 </code><code class="k">begin</code>
<code class="lineno"> 5 </code>  <code class="n">future</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">Future</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;</code><code class="p">(</code>
<code class="lineno"> 6 </code>    <code class="k">function</code><code class="o">:</code> <code class="nf">integer</code>
<code class="lineno"> 7 </code>    <code class="k">begin</code>
<code class="lineno"> 8 </code>      <code class="k">raise</code> <code class="n">ETestException</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="s">'Exception in Parallel.Future'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">end</code>
<code class="lineno">10 </code>  <code class="p">)</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="n">Log</code><code class="p">(</code><code class="s">'Future is executing ...'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="nb">Sleep</code><code class="p">(</code><code class="mi">1000</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="k">try</code>
<code class="lineno">14 </code>    <code class="n">Log</code><code class="p">(</code><code class="s">'Future retured: %d'</code><code class="o">,</code> <code class="p">[</code><code class="n">future</code><code class="o">.</code><code class="n">Value</code><code class="p">])</code><code class="o">;</code>
<code class="lineno">15 </code>  <code class="k">except</code>
<code class="lineno">16 </code>    <code class="k">on</code> <code class="n">E</code><code class="o">:</code> <code class="n">Exception</code> <code class="k">do</code>
<code class="lineno">17 </code>      <code class="n">Log</code><code class="p">(</code><code class="s">'Future raised exception %s:%s'</code><code class="o">,</code> <code class="p">[</code><code class="n">E</code><code class="o">.</code><code class="n">ClassName</code><code class="o">,</code> <code class="n">E</code><code class="o">.</code><code class="n">Message</code><code class="p">])</code><code class="o">;</code>
<code class="lineno">18 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">19 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>Second example uses <code>WaitFor</code> to wait on task completion and then checks the result of the <code>FatalException</code> function. It will return <code>Nil</code> if there was no exception or the exception object if there was an exception. Exception object itself will still be owned by the <em>Future</em> task and will be destroyed when the <em>Future</em> is destroyed.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">FutureException2</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">future</code><code class="o">:</code> <code class="n">IOmniFuture</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;;</code>
<code class="lineno"> 4 </code><code class="k">begin</code>
<code class="lineno"> 5 </code>  <code class="n">future</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">Future</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;</code><code class="p">(</code>
<code class="lineno"> 6 </code>    <code class="k">function</code><code class="o">:</code> <code class="nf">integer</code>
<code class="lineno"> 7 </code>    <code class="k">begin</code>
<code class="lineno"> 8 </code>      <code class="k">raise</code> <code class="n">ETestException</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="s">'Exception in Parallel.Future'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">end</code>
<code class="lineno">10 </code>  <code class="p">)</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="n">Log</code><code class="p">(</code><code class="s">'Future is executing ...'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="n">future</code><code class="o">.</code><code class="n">WaitFor</code><code class="p">(</code><code class="n">INFINITE</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="k">if</code> <code class="nb">assigned</code><code class="p">(</code><code class="n">future</code><code class="o">.</code><code class="n">FatalException</code><code class="p">)</code> <code class="k">then</code>
<code class="lineno">14 </code>    <code class="n">Log</code><code class="p">(</code><code class="s">'Future raised exception %s:%s'</code><code class="o">,</code> 
<code class="lineno">15 </code>      <code class="p">[</code><code class="n">future</code><code class="o">.</code><code class="n">FatalException</code><code class="o">.</code><code class="n">ClassName</code><code class="o">,</code> <code class="n">future</code><code class="o">.</code><code class="n">FatalException</code><code class="o">.</code><code class="n">Message</code><code class="p">])</code>
<code class="lineno">16 </code>  <code class="k">else</code>
<code class="lineno">17 </code>    <code class="n">Log</code><code class="p">(</code><code class="s">'Future retured: %d'</code><code class="o">,</code> <code class="p">[</code><code class="n">future</code><code class="o">.</code><code class="n">Value</code><code class="p">])</code><code class="o">;</code>
<code class="lineno">18 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>Third example shows how you can detach exception from the future. By calling <code>DetachException</code> you will get the ownership of the exception object and you should destroy it at some appropriate point in time.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">FutureException3</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">excFuture</code><code class="o">:</code> <code class="n">Exception</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">future</code>   <code class="o">:</code> <code class="n">IOmniFuture</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="n">future</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">Future</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;</code><code class="p">(</code>
<code class="lineno"> 7 </code>    <code class="k">function</code><code class="o">:</code> <code class="nf">integer</code>
<code class="lineno"> 8 </code>    <code class="k">begin</code>
<code class="lineno"> 9 </code>      <code class="k">raise</code> <code class="n">ETestException</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="s">'Exception in Parallel.Future'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">end</code>
<code class="lineno">11 </code>  <code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="n">Log</code><code class="p">(</code><code class="s">'Future is executing ...'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="n">future</code><code class="o">.</code><code class="n">WaitFor</code><code class="p">(</code><code class="n">INFINITE</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">14 </code>  <code class="n">excFuture</code> <code class="o">:=</code> <code class="n">future</code><code class="o">.</code><code class="n">DetachException</code><code class="o">;</code>
<code class="lineno">15 </code>  <code class="k">try</code>
<code class="lineno">16 </code>    <code class="k">if</code> <code class="nb">assigned</code><code class="p">(</code><code class="n">excFuture</code><code class="p">)</code> <code class="k">then</code>
<code class="lineno">17 </code>      <code class="n">Log</code><code class="p">(</code><code class="s">'Future raised exception %s:%s'</code><code class="o">,</code> 
<code class="lineno">18 </code>        <code class="p">[</code><code class="n">excFuture</code><code class="o">.</code><code class="n">ClassName</code><code class="o">,</code> <code class="n">excFuture</code><code class="o">.</code><code class="n">Message</code><code class="p">])</code>
<code class="lineno">19 </code>    <code class="k">else</code>
<code class="lineno">20 </code>      <code class="n">Log</code><code class="p">(</code><code class="s">'Future retured: %d'</code><code class="o">,</code> <code class="p">[</code><code class="n">future</code><code class="o">.</code><code class="n">Value</code><code class="p">])</code><code class="o">;</code>
<code class="lineno">21 </code>  <code class="k">finally</code> <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">excFuture</code><code class="p">)</code><code class="o">;</code> <code class="k">end</code><code class="o">;</code>
<code class="lineno">22 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<blockquote>
  <p>See also <a href="chap12.html#demos">demo</a> <code>48_OtlParallelExceptions</code>.</p>
</blockquote>

<h4 id="leanpub-auto-examples">
<span class="section-number">3.6.5 </span>Examples</h4>

<p>Practical examples of <em>Future</em> usage can be found in chapter <a href="chap10.html#howto-com">OmniThreadLibrary and COM/OLE</a>.</p>


<div class="page-break"></div>
<h3 id="highlevel-join">
<span class="section-number">3.7 </span>Join</h3>

<p><em>Join</em> abstraction enables you to start multiple background tasks in multiple threads. To create the task, call <code>Parallel.Join</code>.</p>

<aside>

<div class="figure-wrapper center">
  <figure class="image" style="width: 340px;">
    <img src="images/highlevel----join.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


</aside>

<aside>
  <p><em>When you use Parallel.Join, background tasks are started in background threads. By default, Join waits for all background threads to complete before the control is returned to the caller.</em></p>

</aside>

<p>
  <em>See also <a href="chap12.html#demos">demo</a> <code>37_ParallelJoin</code>.</em>
</p>

<div class="page-break"></div>
<p>Example:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">Parallel</code><code class="o">.</code><code class="n">Join</code><code class="p">(</code>
<code class="lineno"> 2 </code>  <code class="k">procedure</code>
<code class="lineno"> 3 </code>  <code class="k">var</code>
<code class="lineno"> 4 </code>    <code class="nf">i</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="k">begin</code>
<code class="lineno"> 6 </code>    <code class="k">for</code> <code class="n">i</code> <code class="o">:=</code> <code class="mi">1</code> <code class="k">to</code> <code class="mi">8</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno"> 7 </code>      <code class="nb">Sleep</code><code class="p">(</code><code class="mi">200</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 8 </code>      <code class="n">MessageBeep</code><code class="p">(</code><code class="mh">$FFFFFFFF</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">end</code><code class="o">,</code>
<code class="lineno">10 </code>  <code class="k">procedure</code>
<code class="lineno">11 </code>  <code class="k">var</code>
<code class="lineno">12 </code>    <code class="nf">i</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="k">begin</code>
<code class="lineno">14 </code>    <code class="k">for</code> <code class="n">i</code> <code class="o">:=</code> <code class="mi">1</code> <code class="k">to</code> <code class="mi">10</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">15 </code>      <code class="nb">Sleep</code><code class="p">(</code><code class="mi">160</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">16 </code>      <code class="n">MessageBeep</code><code class="p">(</code><code class="mh">$FFFFFFFF</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">17 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">18 </code>  <code class="k">end</code>
<code class="lineno">19 </code><code class="p">)</code><code class="o">.</code><code class="n">Execute</code><code class="o">;</code>
</pre></div>

</figure>

<p>This simple program executes two background tasks, each beeping at a different frequency. Each task is coded as an anonymous method but you can also use a <a href="chap06.html#highLevel-intro-AnonymousEtAl">normal method or a normal procedure</a> for the task code. </p>

<p>The <code>Parallel</code> class defines five <code>Join</code> overloads. The first creates empty  <code>IOmniParallelJoin</code> interface. Next two create the same interface but configured with two tasks and the last two create this interface configured for any number of tasks. Tasks can be of two different types – parameterless methods and methods containing one parameter of the <code>IOmniJoinState</code> type.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniJoinDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">joinState</code><code class="o">:</code>
<code class="lineno"> 3 </code>                        <code class="n">IOmniJoinState</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 4 </code>
<code class="lineno"> 5 </code>  <code class="n">Parallel</code> <code class="o">=</code> <code class="k">class</code>
<code class="lineno"> 6 </code>    <code class="k">class</code> <code class="k">function</code> <code class="nf">Join</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">class</code> <code class="k">function</code> <code class="nf">Join</code><code class="p">(</code><code class="k">const</code> <code class="n">task1</code><code class="o">,</code> <code class="n">task2</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code>
<code class="lineno"> 8 </code>                     <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">class</code> <code class="k">function</code> <code class="nf">Join</code><code class="p">(</code><code class="k">const</code> <code class="n">task1</code><code class="o">,</code> <code class="n">task2</code><code class="o">:</code> <code class="n">TOmniJoinDelegate</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">10 </code>                     <code class="n">IOmniParallelJoin</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">class</code> <code class="k">function</code> <code class="nf">Join</code><code class="p">(</code><code class="k">const</code> <code class="n">tasks</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code>
<code class="lineno">12 </code>                     <code class="n">overload</code><code class="o">;</code>
<code class="lineno">13 </code>    <code class="k">class</code> <code class="k">function</code> <code class="nf">Join</code><code class="p">(</code><code class="k">const</code> <code class="n">tasks</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">TOmniJoinDelegate</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">14 </code>                     <code class="n">IOmniParallelJoin</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">15 </code>    <code class="o">...</code>
<code class="lineno">16 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-iomniparalleljoin-interface">
<span class="section-number">3.7.1 </span>IOmniParallelJoin interface</h4>

<p><code>Parallel.Join</code> returns an <code>IOmniParallelJoin</code> interface which you can use to specify tasks, start and control execution and handle exceptions.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">IOmniParallelJoin</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 3 </code>    <code class="k">function</code> <code class="nf">Cancel</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code>
<code class="lineno"> 4 </code>    <code class="k">function</code> <code class="nf">DetachException</code><code class="o">:</code> <code class="n">Exception</code><code class="o">;</code>
<code class="lineno"> 5 </code>    <code class="k">function</code> <code class="nf">Execute</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code>
<code class="lineno"> 6 </code>    <code class="k">function</code> <code class="nf">FatalException</code><code class="o">:</code> <code class="n">Exception</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">function</code> <code class="nf">IsCancelled</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 8 </code>    <code class="k">function</code> <code class="nf">IsExceptional</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">function</code> <code class="nf">NumTasks</code><code class="p">(</code><code class="n">numTasks</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">function</code> <code class="nf">OnStop</code><code class="p">(</code><code class="k">const</code> <code class="n">stopCode</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">function</code> <code class="nf">OnStop</code><code class="p">(</code><code class="k">const</code> <code class="n">stopCode</code><code class="o">:</code> <code class="n">TOmniTaskStopDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">function</code> <code class="nf">OnStopInvoke</code><code class="p">(</code><code class="k">const</code> <code class="n">stopCode</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code>
<code class="lineno">13 </code>    <code class="k">function</code> <code class="nf">Task</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">14 </code>    <code class="k">function</code> <code class="nf">Task</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">TOmniJoinDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code>              <code class="n">overload</code><code class="o">;</code>
<code class="lineno">15 </code>    <code class="k">function</code> <code class="nf">TaskConfig</code><code class="p">(</code><code class="k">const</code> <code class="n">config</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code>
<code class="lineno">16 </code>    <code class="k">function</code> <code class="nf">NoWait</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code>
<code class="lineno">17 </code>    <code class="k">function</code> <code class="nf">WaitFor</code><code class="p">(</code><code class="n">timeout_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">18 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The most important of these functions is <code>Execute</code>. It will start an appropriate number of background threads and start executing tasks in those threads. By default, Join uses as many threads as there are tasks but you can override this behaviour by calling the <code>NumTasks</code> function. </p>

<p>If <code>NumTasks</code> receives a positive parameter (<code>&gt; 0</code>), the number of worker tasks is set to that number. For example, <code>NumTasks(16)</code> starts <em>16</em> worker tasks, even if that is more than the number of available cores. </p>

<p>If <code>NumTasks</code> receives a negative parameter (<code>&lt; 0</code>), it specifies the number of cores that should be reserved for other use. The number of worker tasks is then set to <code>&lt;number of available cores&gt; - &lt;number of reserved cores&gt;</code>. If, for example, current process can use <em>16</em> cores and <code>NumTasks(-4)</code> is used, only <em>12</em> (916-4*) worker tasks will be started.</p>

<p>Value <em>0</em> is not allowed and results in an exception.</p>

<p>You can add tasks to a <em>Join</em> abstractions by calling the <code>Task</code> function. In fact, that’s just how the <code>Parallel.Join</code> overloads are implemented. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">class</code> <code class="k">function</code> <code class="nc">Parallel</code><code class="o">.</code><code class="nf">Join</code><code class="p">(</code><code class="k">const</code> <code class="n">task1</code><code class="o">,</code> <code class="n">task2</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="bp">Result</code> <code class="o">:=</code> <code class="n">TOmniParallelJoin</code><code class="o">.</code><code class="n">Create</code><code class="o">.</code><code class="n">Task</code><code class="p">(</code><code class="n">task1</code><code class="p">)</code><code class="o">.</code><code class="n">Task</code><code class="p">(</code><code class="n">task2</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 4 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code><code class="k">class</code> <code class="k">function</code> <code class="nc">Parallel</code><code class="o">.</code><code class="nf">Join</code><code class="p">(</code><code class="k">const</code> <code class="n">tasks</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code>
<code class="lineno"> 7 </code><code class="k">var</code>
<code class="lineno"> 8 </code>  <code class="n">aTask</code><code class="o">:</code> <code class="n">TProc</code><code class="o">;</code>
<code class="lineno"> 9 </code><code class="k">begin</code>
<code class="lineno">10 </code>  <code class="bp">Result</code> <code class="o">:=</code> <code class="n">TOmniParallelJoin</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="k">for</code> <code class="n">aTask</code> <code class="k">in</code> <code class="n">tasks</code> <code class="k">do</code>
<code class="lineno">12 </code>    <code class="bp">Result</code><code class="o">.</code><code class="n">Task</code><code class="p">(</code><code class="n">aTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>To set up <a href="chap06.html#highlevel-taskconfig">task configuration block</a>, call the <code>TaskConfig</code> function. Following example uses <code>TaskConfig</code> to set up critical section which is then used in two parallel tasks to protect the shared resource. Workers use the <code>IOmniJoinState</code> instance to access the <a href="chap05.html#introotl-tasksvsthreads"><code>IOmniTask</code></a> interface and through it the <a href="chap07.html#lowlevel-simpletasks-tasklock"><code>Lock</code></a> property.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">FSharedValue</code> <code class="o">:=</code> <code class="mi">42</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="n">Parallel</code><code class="o">.</code><code class="n">Join</code><code class="p">(</code>
<code class="lineno"> 3 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">joinState</code><code class="o">:</code> <code class="n">IOmniJoinState</code><code class="p">)</code>
<code class="lineno"> 4 </code>  <code class="k">var</code>
<code class="lineno"> 5 </code>    <code class="n">i</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="k">begin</code>
<code class="lineno"> 7 </code>    <code class="k">for</code> <code class="n">i</code> <code class="o">:=</code> <code class="mi">1</code> <code class="k">to</code> <code class="mi">1000000</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno"> 8 </code>      <code class="n">joinState</code><code class="o">.</code><code class="n">Task</code><code class="o">.</code><code class="n">Lock</code><code class="o">.</code><code class="n">Acquire</code><code class="o">;</code>
<code class="lineno"> 9 </code>      <code class="n">FSharedValue</code> <code class="o">:=</code> <code class="n">FSharedValue</code> <code class="o">+</code> <code class="mi">17</code><code class="o">;</code>
<code class="lineno">10 </code>      <code class="n">joinState</code><code class="o">.</code><code class="n">Task</code><code class="o">.</code><code class="n">Lock</code><code class="o">.</code><code class="n">Release</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="k">end</code><code class="o">,</code>
<code class="lineno">13 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">joinState</code><code class="o">:</code> <code class="n">IOmniJoinState</code><code class="p">)</code>
<code class="lineno">14 </code>  <code class="k">var</code>
<code class="lineno">15 </code>    <code class="n">i</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">16 </code>  <code class="k">begin</code>
<code class="lineno">17 </code>    <code class="k">for</code> <code class="n">i</code> <code class="o">:=</code> <code class="mi">1</code> <code class="k">to</code> <code class="mi">1000000</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">18 </code>      <code class="n">joinState</code><code class="o">.</code><code class="n">Task</code><code class="o">.</code><code class="n">Lock</code><code class="o">.</code><code class="n">Acquire</code><code class="o">;</code>
<code class="lineno">19 </code>      <code class="n">FSharedValue</code> <code class="o">:=</code> <code class="n">FSharedValue</code> <code class="o">-</code> <code class="mi">17</code><code class="o">;</code>
<code class="lineno">20 </code>      <code class="n">joinState</code><code class="o">.</code><code class="n">Task</code><code class="o">.</code><code class="n">Lock</code><code class="o">.</code><code class="n">Release</code><code class="o">;</code>
<code class="lineno">21 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">22 </code>  <code class="k">end</code>
<code class="lineno">23 </code><code class="p">)</code><code class="o">.</code><code class="n">TaskConfig</code><code class="p">(</code><code class="n">Parallel</code><code class="o">.</code><code class="n">TaskConfig</code><code class="o">.</code><code class="n">WithLock</code><code class="p">(</code><code class="n">CreateOmniCriticalSection</code><code class="p">))</code>
<code class="lineno">24 </code> <code class="o">.</code><code class="n">Execute</code><code class="o">;</code>
</pre></div>

</figure>

<p>By default, <code>Join</code> will wait for all background tasks to complete execution. Alternatively, you can call the <code>NoWait</code> function, after which <code>Join</code> will just start the tasks and return immediately. If you want to be notified when all tasks are finished, you can assign the termination handler by calling the <code>OnStop</code> function. This termination handler is called from one of the worker threads, not from the main thread! If you need to run a code in the main thread, use the <a href="chap06.html#highlevel-taskconfig">task configuration block</a>.</p>

<p id="highlevel-join-onstopinvoke">Release <sup>[3.07.2]</sup> introduced method <code>OnStopInvoke</code> which works like <code>OnStop</code> except that the termination handler is automatically executed in the context of the owner thread via implicit <code>Invoke</code>. For example, see <a href="chap06.html#highlevel-foreach-onstopinvoke"><code>Parallel.ForEach.OnStopInvoke</code></a>.</p>

<p>You can also call <code>WaitFor</code> to wait for the <code>Join</code> to finish. <code>WaitFor</code> accepts an optional timeout parameter; by default it will wait as long as needed.</p>

<h4 id="leanpub-auto-iomnijoinstate-interface">
<span class="section-number">3.7.2 </span>IOmniJoinState interface</h4>

<p>Task method can accept a parameter of type <code>IOmniJoinState</code>. This allows it to access the <a href="chap05.html#introotl-tasksvsthreads"><code>IOmniTask</code></a> interface, participate in the cooperative cancellation and check for exceptions.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">type</code>
<code class="lineno">2 </code>  <code class="n">IOmniJoinState</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno">3 </code>    <code class="k">function</code>  <code class="nf">GetTask</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="o">;</code>
<code class="lineno">4 </code>  <code class="c1">//</code>
<code class="lineno">5 </code>    <code class="k">procedure</code> <code class="nf">Cancel</code><code class="o">;</code>
<code class="lineno">6 </code>    <code class="k">function</code>  <code class="nf">IsCancelled</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">7 </code>    <code class="k">function</code>  <code class="nf">IsExceptional</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">8 </code>    <code class="k">property</code> <code class="py">Task</code><code class="o">:</code> <code class="n">IOmniTask</code> <code class="kp">read</code> <code class="nf">GetTask</code><code class="o">;</code>
<code class="lineno">9 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-cancellation-1">
<span class="section-number">3.7.3 </span>Cancellation</h4>

<p><em>Join</em> background tasks support cooperative cancellation. If you are using <code>TOmniJoinDelegate</code> tasks (that is, tasks accepting the IOmniJoinState parameter), any task can call the <code>Cancel</code> method of this interface. This, in turn, sets internal cancellation flag which may be queried by calling the <code>IsCancelled</code> method. That way, one task can interrupt other tasks provided that they are testing <code>IsCancelled</code> repeatedly.</p>

<p>Main thread can also cancel its subtasks (when using <code>NoWait</code>) by calling <code>IOmniParallelJoin.Cancel</code> and can test the cancellation flag by calling <code>IsCancelled</code>. </p>

<p>The following demo code shows most of the concepts mentioned above.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">var</code>
<code class="lineno"> 2 </code>  <code class="n">join</code><code class="o">:</code> <code class="n">IOmniParallelJoin</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="nb">time</code><code class="o">:</code> <code class="kt">int64</code><code class="o">;</code>
<code class="lineno"> 4 </code><code class="k">begin</code>
<code class="lineno"> 5 </code>  <code class="n">FJoinCount</code><code class="o">.</code><code class="n">Value</code> <code class="o">:=</code> <code class="mi">0</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="n">FJoinCount2</code><code class="o">.</code><code class="n">Value</code> <code class="o">:=</code> <code class="mi">0</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="n">join</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">Join</code><code class="p">(</code>
<code class="lineno"> 8 </code>    <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">joinState</code><code class="o">:</code> <code class="n">IOmniJoinState</code><code class="p">)</code>
<code class="lineno"> 9 </code>    <code class="k">var</code>
<code class="lineno">10 </code>      <code class="n">i</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">begin</code>
<code class="lineno">12 </code>      <code class="k">for</code> <code class="n">i</code> <code class="o">:=</code> <code class="mi">1</code> <code class="k">to</code> <code class="mi">10</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">13 </code>        <code class="nb">Sleep</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">14 </code>        <code class="n">FJoinCount</code><code class="o">.</code><code class="n">Increment</code><code class="o">;</code>
<code class="lineno">15 </code>        <code class="k">if</code> <code class="n">joinState</code><code class="o">.</code><code class="n">IsCancelled</code> <code class="k">then</code>
<code class="lineno">16 </code>          <code class="k">break</code><code class="o">;</code> <code class="c1">//for</code>
<code class="lineno">17 </code>      <code class="k">end</code><code class="o">;</code>
<code class="lineno">18 </code>    <code class="k">end</code><code class="o">,</code>
<code class="lineno">19 </code>    <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">joinState</code><code class="o">:</code> <code class="n">IOmniJoinState</code><code class="p">)</code>
<code class="lineno">20 </code>    <code class="k">var</code>
<code class="lineno">21 </code>      <code class="n">i</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">22 </code>    <code class="k">begin</code>
<code class="lineno">23 </code>      <code class="k">for</code> <code class="n">i</code> <code class="o">:=</code> <code class="mi">1</code> <code class="k">to</code> <code class="mi">10</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">24 </code>        <code class="nb">Sleep</code><code class="p">(</code><code class="mi">200</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">25 </code>        <code class="n">FJoinCount2</code><code class="o">.</code><code class="n">Increment</code><code class="o">;</code>
<code class="lineno">26 </code>        <code class="k">if</code> <code class="n">joinState</code><code class="o">.</code><code class="n">IsCancelled</code> <code class="k">then</code>
<code class="lineno">27 </code>          <code class="k">break</code><code class="o">;</code> <code class="c1">//for</code>
<code class="lineno">28 </code>      <code class="k">end</code><code class="o">;</code>
<code class="lineno">29 </code>    <code class="k">end</code>
<code class="lineno">30 </code>  <code class="p">)</code><code class="o">.</code><code class="n">NoWait</code><code class="o">.</code><code class="n">Execute</code><code class="o">;</code>
<code class="lineno">31 </code>  <code class="nb">Sleep</code><code class="p">(</code><code class="mi">500</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">32 </code>  <code class="nb">time</code> <code class="o">:=</code> <code class="n">DSiTimeGetTime64</code><code class="o">;</code>
<code class="lineno">33 </code>  <code class="n">join</code><code class="o">.</code><code class="n">Cancel</code><code class="o">.</code><code class="n">WaitFor</code><code class="p">(</code><code class="n">INFINITE</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">34 </code>  <code class="n">Log</code><code class="p">(</code><code class="nb">Format</code><code class="p">(</code><code class="s">'Waited %d ms for joins to terminate'</code><code class="o">,</code>
<code class="lineno">35 </code>    <code class="p">[</code><code class="n">DSiElapsedTime64</code><code class="p">(</code><code class="nb">time</code><code class="p">)]))</code><code class="o">;</code>
<code class="lineno">36 </code>  <code class="n">Log</code><code class="p">(</code><code class="nb">Format</code><code class="p">(</code><code class="s">'Tasks counted up to %d and %d'</code><code class="o">,</code>
<code class="lineno">37 </code>    <code class="p">[</code><code class="n">FJoinCount</code><code class="o">.</code><code class="n">Value</code><code class="o">,</code> <code class="n">FJoinCount2</code><code class="o">.</code><code class="n">Value</code><code class="p">]))</code><code class="o">;</code>
<code class="lineno">38 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The call to <code>Parallel.Join</code> starts two tasks. Because the <code>NoWait</code> is used, the call returns immediately and stores resulting <code>IOmniParallelJoin</code> interface in the local variable <code>join</code>. Main code then sleeps for half a second, cancels the execution and waits for background tasks to terminate.</p>

<p>Both tasks execute a simple loop which waits a little, increments a counter and checks the cancellation flag. Because the cancellation flag is set after 500 ms, we would expect five or six repetitions of the first loop (five repetitions take exactly 500 ms and we can’t tell exactly what will execute first – <code>Cancel</code> or fifth <code>IsCancelled</code>) and three repetitions of the second loop. That is exactly what the program prints out.</p>

<h4 id="highlevel-join-exceptions">
<span class="section-number">3.7.4 </span>Handling exceptions</h4>

<p>Exceptions in background tasks are caught and re-raised in the <code>WaitFor</code> method. If you are using a synchronous version of <em>Join</em> (without the <code>NoWait</code> modifier), then <code>WaitFor</code> is called at the end of the <code>Execute</code> method (in other words, <code>Parallel.Join(…).Execute</code> will re-raise task exceptions). If, however, you are using the asynchronous version (by calling <code>Parallel.Join(…).NoWait.Execute</code>), exception will only be raised when you wait for the background tasks to complete by calling <code>WaitFor</code>. </p>

<p>You can test for the exception by calling the <code>FatalException</code> function. It will first wait for all background tasks to complete (without raising the exception) and then return the exception object. You can also detach the exception object from the Join and handle it yourself by using the <code>DetachException</code> function.</p>

<p>There’s also an <code>IsExceptional</code> function (available in <code>IOmniParallelJoin</code> and <code>IOmniJoinState</code> interfaces) which tells you whether any background task has thrown an exception.</p>

<p>As <em>Join</em> executes multiple tasks, there can be multiple background exceptions. To get you full access to those exceptions, <em>Join</em> wraps them into <code>EJoinException</code> object.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">type</code>
<code class="lineno">2 </code>  <code class="n">EJoinException</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">Exception</code><code class="p">)</code>
<code class="lineno">3 </code>    <code class="k">constructor</code> <code class="nf">Create</code><code class="o">;</code> <code class="k">reintroduce</code><code class="o">;</code>
<code class="lineno">4 </code>    <code class="k">destructor</code>  <code class="nf">Destroy</code><code class="o">;</code> <code class="kp">override</code><code class="o">;</code>
<code class="lineno">5 </code>    <code class="k">procedure</code> <code class="nf">Add</code><code class="p">(</code><code class="n">iTask</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">taskException</code><code class="o">:</code> <code class="n">Exception</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">6 </code>    <code class="k">function</code>  <code class="nf">Count</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">7 </code>    <code class="k">property</code> <code class="py">Inner</code><code class="p">[</code><code class="n">idxException</code><code class="o">:</code> <code class="kt">integer</code><code class="p">]</code><code class="o">:</code> <code class="n">TJoinInnerException</code> 
<code class="lineno">8 </code>      <code class="kp">read</code> <code class="nf">GetInner</code><code class="o">;</code> <code class="kp">default</code><code class="o">;</code>
<code class="lineno">9 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>This exception class contains combined error messages from all background tasks in its <code>Message</code> property and allows you to access exception information for all caught exceptions directly with the <code>Inner[]</code> property. The following code demonstrates this.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">var</code>
<code class="lineno"> 2 </code>  <code class="n">iInnerExc</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="k">begin</code>
<code class="lineno"> 4 </code>  <code class="k">try</code>
<code class="lineno"> 5 </code>    <code class="n">Parallel</code><code class="o">.</code><code class="n">Join</code><code class="p">([</code>
<code class="lineno"> 6 </code>      <code class="k">procedure</code> <code class="k">begin</code>
<code class="lineno"> 7 </code>        <code class="k">raise</code> <code class="nc">ETestException</code><code class="o">.</code><code class="nf">Create</code><code class="p">(</code><code class="s">'Exception 1 in Parallel.Join'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 8 </code>      <code class="k">end</code><code class="o">,</code>
<code class="lineno"> 9 </code>      <code class="k">procedure</code> <code class="k">begin</code>
<code class="lineno">10 </code>      <code class="k">end</code><code class="o">,</code>
<code class="lineno">11 </code>      <code class="k">procedure</code> <code class="k">begin</code>
<code class="lineno">12 </code>        <code class="k">raise</code> <code class="nc">ETestException</code><code class="o">.</code><code class="nf">Create</code><code class="p">(</code><code class="s">'Exception 2 in Parallel.Join'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code>      <code class="k">end</code><code class="p">])</code><code class="o">.</code><code class="n">Execute</code><code class="o">;</code>
<code class="lineno">14 </code>  <code class="k">except</code>
<code class="lineno">15 </code>    <code class="k">on</code> <code class="n">E</code><code class="o">:</code> <code class="n">EJoinException</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">16 </code>      <code class="n">Log</code><code class="p">(</code><code class="s">'Join raised exception %s:%s'</code><code class="o">,</code> <code class="p">[</code><code class="n">E</code><code class="o">.</code><code class="n">ClassName</code><code class="o">,</code> <code class="n">E</code><code class="o">.</code><code class="n">Message</code><code class="p">])</code><code class="o">;</code>
<code class="lineno">17 </code>      <code class="k">for</code> <code class="n">iInnerExc</code> <code class="o">:=</code> <code class="mi">0</code> <code class="k">to</code> <code class="n">E</code><code class="o">.</code><code class="n">Count</code> <code class="o">-</code> <code class="mi">1</code> <code class="k">do</code>
<code class="lineno">18 </code>        <code class="n">Log</code><code class="p">(</code><code class="s">'  Task #%d raised exception: %s:%s'</code><code class="o">,</code> <code class="p">[</code><code class="n">E</code><code class="p">[</code><code class="n">iInnerExc</code><code class="p">]</code><code class="o">.</code><code class="n">TaskNumber</code><code class="o">,</code>
<code class="lineno">19 </code>          <code class="n">E</code><code class="p">[</code><code class="n">iInnerExc</code><code class="p">]</code><code class="o">.</code><code class="n">FatalException</code><code class="o">.</code><code class="n">ClassName</code><code class="o">,</code>
<code class="lineno">20 </code>          <code class="n">E</code><code class="p">[</code><code class="n">iInnerExc</code><code class="p">]</code><code class="o">.</code><code class="n">FatalException</code><code class="o">.</code><code class="n">Message</code><code class="p">])</code><code class="o">;</code>
<code class="lineno">21 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">22 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">23 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The <code>iInnerExc</code> variable loops over all caught exceptions and for each such exception displays the task number (starting with 0), exception class and exception message. This approach allows you to log the exception or, if you are interested in details, examine specific inner exceptions and handle them appropriately.</p>

<p>
  <em>See also <a href="chap12.html#demos">demo</a> <code>48_OtlParallelExceptions</code>.</em>
</p>


<div class="page-break"></div>
<h3 id="highlevel-paralleltask">
<span class="section-number">3.8 </span>Parallel task</h3>

<p><em>Parallel task</em> abstraction enables you to start the same <a href="chap06.html#highLevel-intro-AnonymousEtAl">method</a> in multiple threads. To create the task, call <code>Parallel.ParallelTask</code>.</p>

<aside>

<div class="figure-wrapper center">
  <figure class="image" style="width: 468px;">
    <img src="images/highlevel----parallelTask.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


</aside>

<aside>
  <p><em>When you use Parallel.ParallelTask, same background task is started in multiple background threads. By default, ParallelTask waits for all background threads to complete before the control is returned to the caller.</em></p>

</aside>

<p>Example:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">Parallel</code><code class="o">.</code><code class="n">ParallelTask</code><code class="o">.</code><code class="n">NumTasks</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">2 </code>  <code class="k">procedure</code>
<code class="lineno">3 </code>  <code class="k">begin</code>
<code class="lineno">4 </code>    <code class="k">while</code> <code class="k">true</code> <code class="k">do</code>
<code class="lineno">5 </code>      <code class="o">;</code>
<code class="lineno">6 </code>  <code class="k">end</code>
<code class="lineno">7 </code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>This simple code fragment starts infinite loop in three threads. The task is coded as an anonymous method but you can also use a <a href="chap06.html#highLevel-intro-AnonymousEtAl">normal method or a normal procedure</a> for the task code.</p>

<p>The <code>Parallel</code> class implements function <code>ParallelTask</code> which returns an <code>IOmniParallelTask</code> interface. All configuration of the parallel task is done via this interface.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">type</code>
<code class="lineno">2 </code>  <code class="n">Parallel</code> <code class="o">=</code> <code class="k">class</code>
<code class="lineno">3 </code>    <code class="k">class</code> <code class="k">function</code> <code class="nf">ParallelTask</code><code class="o">:</code> <code class="n">IOmniParallelTask</code><code class="o">;</code>
<code class="lineno">4 </code>    <code class="o">...</code>
<code class="lineno">5 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-iomniparalleltask-interface">
<span class="section-number">3.8.1 </span>IOmniParallelTask interface</h4>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">IOmniParallelTask</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 3 </code>    <code class="k">function</code>  <code class="nf">Execute</code><code class="p">(</code><code class="k">const</code> <code class="n">aTask</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelTask</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 4 </code>    <code class="k">function</code>  <code class="nf">Execute</code><code class="p">(</code>
<code class="lineno"> 5 </code>      <code class="k">const</code> <code class="n">aTask</code><code class="o">:</code> <code class="n">TOmniParallelTaskDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelTask</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 6 </code>    <code class="k">function</code>  <code class="nf">NoWait</code><code class="o">:</code> <code class="n">IOmniParallelTask</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">function</code>  <code class="nf">NumTasks</code><code class="p">(</code><code class="n">numTasks</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelTask</code><code class="o">;</code>
<code class="lineno"> 8 </code>    <code class="k">function</code>  <code class="nf">OnStop</code><code class="p">(</code><code class="k">const</code> <code class="n">stopCode</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelTask</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">function</code>  <code class="nf">OnStop</code><code class="p">(</code><code class="k">const</code> <code class="n">stopCode</code><code class="o">:</code> <code class="n">TOmniTaskStopDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelTask</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">function</code>  <code class="nf">OnStopInvoke</code><code class="p">(</code><code class="k">const</code> <code class="n">stopCode</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelTask</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">function</code>  <code class="nf">TaskConfig</code><code class="p">(</code><code class="k">const</code> <code class="n">config</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelTask</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">function</code>  <code class="nf">WaitFor</code><code class="p">(</code><code class="n">timeout_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The most important of these functions is <code>Execute</code>. It will start an appropriate number of background threads and start executing task in those threads. </p>

<p>There are two overloaded versions of <code>Execute</code>. The first accepts a parameter-less background task, and the second accepts a background task with an <a href="chap05.html#introotl-tasksvsthreads"><code>IOmniTask</code></a> parameter.</p>

<p>By default, <em>Parallel task</em> uses as many threads as there are tasks but you can override this behaviour by calling the <code>NumTasks</code> function.</p>

<p>If <code>NumTasks</code> receives a positive parameter (<code>&gt; 0</code>), the number of worker tasks is set to that number. For example, <code>NumTasks(16)</code> starts <em>16</em> worker tasks, even if that is more than the number of available cores.</p>

<p>If <code>NumTasks</code> receives a negative parameter (<code>&lt; 0</code>), it specifies the number of cores that should be reserved for other use. The number of worker tasks is then set to <code>&lt;number of available cores&gt; - &lt;number of reserved cores&gt;</code>. If, for example, current process can use <em>16</em> cores and <code>NumTasks(-4)</code> is used, only <em>12</em> (<em>16-4</em>) worker tasks will be started. </p>

<p>Parameter <em>0</em> is not allowed and results in an exception.</p>

<p>The <code>OnStop</code> function can be used to set up a termination handler - a code that will get executed when all background tasks will have completed execution. This termination handler is called from one of the worker threads, not from the main thread! If you need to run a code in the main thread, use the <a href="chap06.html#highlevel-taskconfig">task configuration block</a>. To set up task configuration block, call the <code>TaskConfig</code> function.</p>

<p id="highlevel-paralleltask-onstopinvoke">Release <sup>[3.07.2]</sup> introduced method <code>OnStopInvoke</code> which works like <code>OnStop</code> except that the termination handler is automatically executed in the context of the owner thread via implicit <code>Invoke</code>. For example, see <a href="chap06.html#highlevel-foreach-onstopinvoke"><code>Parallel.ForEach.OnStopInvoke</code></a>.</p>

<p>A call to the <code>WaitFor</code> function will wait for up to <code>timeout_ms</code> milliseconds (this value can be set to <code>INFINITE</code>) for all background tasks to terminate. If the tasks terminate in the specified time, <code>WaitFor</code> will return <code>True</code>. Otherwise, it will return <code>False</code>.</p>

<h4 id="leanpub-auto-example">
<span class="section-number">3.8.2 </span>Example</h4>

<p>The following code uses <code>ParallelTask</code> to generate large quantities of pseudo-random data. The data is written to an output stream. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">CreateRandomFile</code><code class="p">(</code><code class="nb">fileSize</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">output</code><code class="o">:</code> <code class="n">TStream</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">const</code>
<code class="lineno"> 3 </code>  <code class="n">CBlockSize</code> <code class="o">=</code> <code class="mi">1</code> <code class="o">*</code> <code class="mi">1024</code> <code class="o">*</code> <code class="mi">1024</code> <code class="cm">{1 MB}</code><code class="o">;</code>
<code class="lineno"> 4 </code><code class="k">var</code>
<code class="lineno"> 5 </code>  <code class="n">buffer</code>   <code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="n">memStr</code>   <code class="o">:</code> <code class="n">TMemoryStream</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="n">outQueue</code> <code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="n">unwritten</code><code class="o">:</code> <code class="n">IOmniCounter</code><code class="o">;</code>
<code class="lineno"> 9 </code><code class="k">begin</code>
<code class="lineno">10 </code>  <code class="n">outQueue</code> <code class="o">:=</code> <code class="n">TOmniBlockingCollection</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="n">unwritten</code> <code class="o">:=</code> <code class="n">CreateCounter</code><code class="p">(</code><code class="nb">fileSize</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="n">Parallel</code><code class="o">.</code><code class="n">ParallelTask</code><code class="o">.</code><code class="n">NoWait</code>
<code class="lineno">13 </code>    <code class="o">.</code><code class="n">NumTasks</code><code class="p">(</code><code class="n">Environment</code><code class="o">.</code><code class="n">Process</code><code class="o">.</code><code class="n">Affinity</code><code class="o">.</code><code class="n">Count</code><code class="p">)</code>
<code class="lineno">14 </code>    <code class="o">.</code><code class="n">OnStop</code><code class="p">(</code><code class="n">Parallel</code><code class="o">.</code><code class="n">CompleteQueue</code><code class="p">(</code><code class="n">outQueue</code><code class="p">))</code>
<code class="lineno">15 </code>    <code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">16 </code>      <code class="k">procedure</code>
<code class="lineno">17 </code>      <code class="k">var</code>
<code class="lineno">18 </code>        <code class="nf">buffer</code>      <code class="o">:</code> <code class="n">TMemoryStream</code><code class="o">;</code>
<code class="lineno">19 </code>        <code class="n">bytesToWrite</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">20 </code>        <code class="n">randomGen</code>   <code class="o">:</code> <code class="n">TGpRandom</code><code class="o">;</code>
<code class="lineno">21 </code>      <code class="k">begin</code>
<code class="lineno">22 </code>        <code class="n">randomGen</code> <code class="o">:=</code> <code class="n">TGpRandom</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">23 </code>        <code class="k">try</code>
<code class="lineno">24 </code>          <code class="k">while</code> <code class="n">unwritten</code><code class="o">.</code><code class="n">Take</code><code class="p">(</code><code class="n">CBlockSize</code><code class="o">,</code> <code class="n">bytesToWrite</code><code class="p">)</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">25 </code>            <code class="n">buffer</code> <code class="o">:=</code> <code class="n">TMemoryStream</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">26 </code>            <code class="n">buffer</code><code class="o">.</code><code class="n">Size</code> <code class="o">:=</code> <code class="n">bytesToWrite</code><code class="o">;</code>
<code class="lineno">27 </code>            <code class="n">FillBuffer</code><code class="p">(</code><code class="n">buffer</code><code class="o">.</code><code class="n">Memory</code><code class="o">,</code> <code class="n">bytesToWrite</code><code class="o">,</code> <code class="n">randomGen</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">28 </code>            <code class="n">outQueue</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">buffer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">29 </code>          <code class="k">end</code><code class="o">;</code>
<code class="lineno">30 </code>        <code class="k">finally</code> <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">randomGen</code><code class="p">)</code><code class="o">;</code> <code class="k">end</code><code class="o">;</code>
<code class="lineno">31 </code>      <code class="k">end</code>
<code class="lineno">32 </code>    <code class="p">)</code><code class="o">;</code>
<code class="lineno">33 </code>  <code class="k">for</code> <code class="n">buffer</code> <code class="k">in</code> <code class="n">outQueue</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">34 </code>    <code class="n">memStr</code> <code class="o">:=</code> <code class="n">buffer</code><code class="o">.</code><code class="n">AsObject</code> <code class="k">as</code> <code class="n">TMemoryStream</code><code class="o">;</code>
<code class="lineno">35 </code>    <code class="n">output</code><code class="o">.</code><code class="n">CopyFrom</code><code class="p">(</code><code class="n">memStr</code><code class="o">,</code> <code class="mi">0</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">36 </code>    <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">memStr</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">37 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">38 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The code creates a <a href="chap06.html#highlevel-blocking-collection">blocking collection</a> to hold buffers with pseudo-random data. Then it creates a <a href="chap09.html#misc-tomnicounter">counter</a> which will hold the count of bytes that have yet to be written. </p>

<p><code>ParallelTask</code> is used to start parallel workers. Each worker initializes its own pseudo-random data generator and then keeps generating buffers with pseudo-random data until the counter drops to zero. Each buffer is written to the blocking collection. </p>

<p>Because of the <code>NoWait</code> modifier, main thread continues with the execution immediately after all threads have been scheduled. Main thread keeps reading buffers from the blocking collection and writes the content of those buffers into the output stream. (As the <code>TStream</code> is not thread-safe, we cannot write to the output stream directly from multiple background threads.)</p>

<p><code>For..in</code> loop will block if there is no data in the blocking collection, but it will only stop looping after the blocking collection’s <code>CompleteAdding</code> method is called. This is done with the help of the <code>Parallel.CompleteQueue</code> helper which is called from the termination handler (<code>OnStop</code>).</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">class</code> <code class="k">function</code> <code class="nc">Parallel</code><code class="o">.</code><code class="nf">CompleteQueue</code><code class="p">(</code>
<code class="lineno">2 </code>  <code class="k">const</code> <code class="n">queue</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="p">)</code><code class="o">:</code> <code class="n">TProc</code><code class="o">;</code>
<code class="lineno">3 </code><code class="k">begin</code>
<code class="lineno">4 </code>  <code class="bp">Result</code> <code class="o">:=</code>
<code class="lineno">5 </code>    <code class="k">procedure</code>
<code class="lineno">6 </code>    <code class="k">begin</code>
<code class="lineno">7 </code>      <code class="nc">queue</code><code class="o">.</code><code class="nf">CompleteAdding</code><code class="o">;</code>
<code class="lineno">8 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">9 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-handling-exceptions-2">
<span class="section-number">3.8.3 </span>Handling exceptions</h4>

<p>Exceptions in background tasks are caught and re-raised in the <code>WaitFor</code> method. If you are using a synchronous version of <em>Parallel task</em> (without the <code>NoWait</code> modifier), then <code>WaitFor</code> is called at the end of the <code>Execute</code> method (in other words, <code>Parallel.ParallelTask.Execute(...)</code> will re-raise task exceptions). If, however, you are using the asynchronous version (by calling <code>Parallel.Paralleltask.NoWait.Execute(...)</code>), an exception will only be raised when you wait for the background tasks to complete by calling <code>WaitFor</code>. </p>

<p>For more details on handling ParallelTask exceptions, see the <a href="chap06.html#highlevel-join-exceptions">Handling exceptions</a> section in the <a href="chap06.html#highlevel-join"><em>Join</em></a> chapter.</p>

<h4 id="leanpub-auto-examples-1">
<span class="section-number">3.8.4 </span>Examples</h4>

<p>Practical examples of <em>Parallel Task</em> usage can be found in chapters <a href="chap10.html#howto-listPartitioning">Background worker and list partitioning</a> and <a href="chap10.html#howto-parallelDataProduction">Parallel data production</a>.</p>


<div class="page-break"></div>
<h3 id="highlevel-backgroundworker">
<span class="section-number">3.9 </span>Background worker</h3>

<p><em>Background worker</em> abstraction implements a client/server relationship. To create a <em>Background worker</em> abstraction, call <code>Parallel.BackgroundWorker</code>.</p>

<aside>

<div class="figure-wrapper center">
  <figure class="image" style="width: 340px;">
    <img src="images/highlevel----backgroundWorker.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


</aside>

<aside>
  <p><em>When you call <code>Parallel.BackgroundWorker.Execute</code>, OmniThreadLibrary starts your task in one or more threads. Task code is wrapped in a wrapper which receives requests from the owner, calls the task to process a request and returns a result to the owner.</em></p>

</aside>

<p>
  <em>See also <a href="chap12.html#demos">demo</a> <code>52_BackgroundWorker</code>.</em>
</p>

<div class="page-break"></div>
<p>Example:</p>

<blockquote>
  <p>Start the worker</p>
</blockquote>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">FBackgroundWorker</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">BackgroundWorker</code><code class="o">.</code><code class="n">NumTasks</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>
<code class="lineno"> 2 </code>  <code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno"> 3 </code>    <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">workItem</code><code class="o">:</code> <code class="n">IOmniWorkItem</code><code class="p">)</code>
<code class="lineno"> 4 </code>    <code class="k">begin</code>
<code class="lineno"> 5 </code>      <code class="n">workItem</code><code class="o">.</code><code class="bp">Result</code> <code class="o">:=</code> <code class="n">workItem</code><code class="o">.</code><code class="n">Data</code><code class="o">.</code><code class="n">AsInteger</code> <code class="o">*</code> <code class="mi">3</code><code class="o">;</code>
<code class="lineno"> 6 </code>    <code class="k">end</code>
<code class="lineno"> 7 </code>  <code class="p">)</code>
<code class="lineno"> 8 </code>  <code class="o">.</code><code class="n">OnRequestDone</code><code class="p">(</code>
<code class="lineno"> 9 </code>    <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">Sender</code><code class="o">:</code> <code class="n">IOmniBackgroundWorker</code><code class="o">;</code>
<code class="lineno">10 </code>      <code class="k">const</code> <code class="n">workItem</code><code class="o">:</code> <code class="n">IOmniWorkItem</code><code class="p">)</code>
<code class="lineno">11 </code>    <code class="k">begin</code>
<code class="lineno">12 </code>      <code class="n">lbLogBW</code><code class="o">.</code><code class="n">ItemIndex</code> <code class="o">:=</code> <code class="n">lbLogBW</code><code class="o">.</code><code class="n">Items</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="nb">Format</code><code class="p">(</code><code class="s">'%d * 3 = %d'</code><code class="o">,</code>
<code class="lineno">13 </code>        <code class="p">[</code><code class="n">workItem</code><code class="o">.</code><code class="n">Data</code><code class="o">.</code><code class="n">AsInteger</code><code class="o">,</code> <code class="n">workItem</code><code class="o">.</code><code class="bp">Result</code><code class="o">.</code><code class="n">AsInteger</code><code class="p">]))</code><code class="o">;</code>
<code class="lineno">14 </code>    <code class="k">end</code>
<code class="lineno">15 </code>  <code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<blockquote>
  <p>Schedule a work item</p>
</blockquote>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FBackgroundWorker</code><code class="o">.</code><code class="n">Schedule</code><code class="p">(</code>
<code class="lineno">2 </code>  <code class="n">FBackgroundWorker</code><code class="o">.</code><code class="n">CreateWorkItem</code><code class="p">(</code><code class="nb">Random</code><code class="p">(</code><code class="mi">100</code><code class="p">)))</code><code class="o">;</code>
</pre></div>

</figure>

<blockquote>
  <p>Stop the worker</p>
</blockquote>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FBackgroundWorker</code><code class="o">.</code><code class="n">Terminate</code><code class="p">(</code><code class="n">INFINITE</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">FBackgroundWorker</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-basics">
<span class="section-number">3.9.1 </span>Basics</h4>

<p><em>Background worker</em> is designed around the concept of a work item. You create a worker which spawns one or more background threads and then schedule work items to it. When they are processed, the abstraction notifies you so you can process the result. Work items are queued so you can schedule many work items at once and background threads will then process them one by one.</p>

<p><em>Background worker</em> is created by calling <code>Parallel.BackgroundWorker</code> factory. Usually you’ll also set the main work item processing method and completion method by calling <code>Execute</code> and <code>OnRequestDone</code>, respectively. As usual, you can provide OTL with a <a href="chap06.html#highLevel-intro-AnonymousEtAl">method, a procedure, or an anonymous method</a>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FWorker</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">BackgroundWorker</code>
<code class="lineno">2 </code>  <code class="o">.</code><code class="n">OnRequestDone</code><code class="p">(</code><code class="n">StringRequestDone</code><code class="p">)</code>
<code class="lineno">3 </code>  <code class="o">.</code><code class="n">Execute</code><code class="p">(</code><code class="n">StringProcessorHL</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>To close the background worker, call the <code>Terminate</code> method and set the reference (<code>FWorker</code>) to <code>nil</code>.</p>

<p>To create a work item, call the <code>CreateWorkItem</code> factory and pass the result to the <code>Schedule</code> method. You can pass any data to the work item by passing a parameter to the <code>CreateWorkItem</code> method. If you need to pass multiple parameters, you can collect them in a record and wrap it with a <code>TOmniValue.FromRecord&lt;T&gt;</code>, pass them as an array of <code>TOmniValue</code>s or pass them as an object or an interface.</p>

<h4 id="leanpub-auto-iomnibackgroundworker-interface">
<span class="section-number">3.9.2 </span>IOmniBackgroundWorker interface</h4>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniTaskInitializerDelegate</code> <code class="o">=</code> 
<code class="lineno"> 3 </code>    <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">var</code> <code class="n">taskState</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">TOmniTaskFinalizerDelegate</code> <code class="o">=</code> 
<code class="lineno"> 5 </code>    <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">taskState</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 6 </code>
<code class="lineno"> 7 </code>  <code class="n">IOmniBackgroundWorker</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 8 </code>    <code class="k">function</code>  <code class="nf">CreateWorkItem</code><code class="p">(</code><code class="k">const</code> <code class="n">data</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniWorkItem</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">procedure</code> <code class="nf">CancelAll</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">procedure</code> <code class="nf">CancelAll</code><code class="p">(</code><code class="n">upToUniqueID</code><code class="o">:</code> <code class="kt">int64</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">function</code>  <code class="nf">Config</code><code class="o">:</code> <code class="n">IOmniWorkItemConfig</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">function</code>  <code class="nf">Execute</code><code class="p">(</code><code class="k">const</code> <code class="n">aTask</code><code class="o">:</code> <code class="n">TOmniBackgroundWorkerDelegate</code> <code class="o">=</code> <code class="k">nil</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">13 </code>      <code class="n">IOmniBackgroundWorker</code><code class="o">;</code>
<code class="lineno">14 </code>    <code class="k">function</code>  <code class="nf">Finalize</code><code class="p">(</code><code class="n">taskFinalizer</code><code class="o">:</code> 
<code class="lineno">15 </code>      <code class="n">TOmniTaskFinalizerDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniBackgroundWorker</code><code class="o">;</code>
<code class="lineno">16 </code>    <code class="k">function</code>  <code class="nf">Initialize</code><code class="p">(</code><code class="n">taskInitializer</code><code class="o">:</code> 
<code class="lineno">17 </code>      <code class="n">TOmniTaskInitializerDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniBackgroundWorker</code><code class="o">;</code>      
<code class="lineno">18 </code>    <code class="k">function</code>  <code class="nf">NumTasks</code><code class="p">(</code><code class="n">numTasks</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniBackgroundWorker</code><code class="o">;</code>
<code class="lineno">19 </code>    <code class="k">function</code>  <code class="nf">OnRequestDone</code><code class="p">(</code><code class="k">const</code> <code class="n">aTask</code><code class="o">:</code> <code class="n">TOmniWorkItemDoneDelegate</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">20 </code>      <code class="n">IOmniBackgroundWorker</code><code class="o">;</code>
<code class="lineno">21 </code>    <code class="k">function</code>  <code class="nf">OnRequestDone_Asy</code><code class="p">(</code><code class="k">const</code> <code class="n">aTask</code><code class="o">:</code> <code class="n">TOmniWorkItemDoneDelegate</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">22 </code>      <code class="n">IOmniBackgroundWorker</code><code class="o">;</code>
<code class="lineno">23 </code>    <code class="k">function</code>  <code class="nf">OnStop</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniBackgroundWorker</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">24 </code>    <code class="k">function</code>  <code class="nf">OnStop</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TOmniTaskStopDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniBackgroundWorker</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">25 </code>    <code class="k">function</code>  <code class="nf">OnStopInvoke</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniBackgroundWorker</code><code class="o">;</code>
<code class="lineno">26 </code>    <code class="k">procedure</code> <code class="nf">Schedule</code><code class="p">(</code><code class="k">const</code> <code class="n">workItem</code><code class="o">:</code> <code class="n">IOmniWorkItem</code><code class="o">;</code> 
<code class="lineno">27 </code>      <code class="k">const</code> <code class="n">workItemConfig</code><code class="o">:</code> <code class="n">IOmniWorkItemConfig</code> <code class="o">=</code> <code class="k">nil</code><code class="p">)</code><code class="o">;</code> 
<code class="lineno">28 </code>    <code class="k">function</code>  <code class="nf">TaskConfig</code><code class="p">(</code><code class="k">const</code> <code class="n">config</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">29 </code>      <code class="n">IOmniBackgroundWorker</code><code class="o">;</code>
<code class="lineno">30 </code>    <code class="k">function</code>  <code class="nf">Terminate</code><code class="p">(</code><code class="n">maxWait_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">31 </code>    <code class="k">function</code>  <code class="nf">WaitFor</code><code class="p">(</code><code class="n">maxWait_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">32 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p><em>Background worker</em> supports two notification mechanisms. By calling <code>OnRequestDone</code>, you are setting a synchronous handler which will be executed in the context of the thread that created the background worker (usually a main thread). In other words – if you call <code>OnRequestDone</code>, you don’t have to worry about thread synchronisation issues. On the other hand, <code>OnRequestDone_Asy</code> handler is executed asynchronously, in the context of the thread that processed the work item.</p>

<p>For performance reasons (for example when terminating the application), the code can prevent execution of event handlers for a work item by setting <a href="chap06.html#highlevel-backgroundworker-iomniworkitem-skipcompletionhandler"><code>IOmniWorkItem.SkipCompletionHandler</code></a> to <code>True</code>.</p>

<p>By calling <code>NumTasks</code>, you can set the degree of parallelism. By default, background worker uses only one background task but you can override this behaviour. </p>

<p>If <code>NumTasks</code> receives a positive parameter (<code>&gt; 0</code>), the number of worker tasks is set to that number. For example, <code>NumTasks(16)</code> starts <em>16</em> worker tasks, even if that is more than the number of available cores.</p>

<p>If <code>NumTasks</code> receives a negative parameter (<code>&lt; 0</code>), it specifies a number of cores that should be reserved for other use. The number of worker tasks is then set to <code>&lt;number of available cores&gt; - &lt;number of reserved cores&gt;</code>. If, for example, current process can use <em>16</em> cores and <code>NumTasks(-4)</code> is used, only <em>12</em> (<em>16-4</em>) worker tasks will be started.</p>

<p>Value <em>0</em> is not allowed and results in an exception.</p>

<p>The <code>OnStop</code> function can be used to set up a termination handler - a code that will get executed when all background tasks will have completed execution. This termination handler is called from one of the worker threads, not from the main thread! If you need to run a code in the main thread, use the <a href="chap06.html#highlevel-taskconfig">task configuration block</a>. To set up task configuration block, call the <code>TaskConfig</code> function.</p>

<p id="highlevel-backgroundworker-onstopinvoke">Release <sup>[3.07.2]</sup> introduced method <code>OnStopInvoke</code> which works like <code>OnStop</code> except that the termination handler is automatically executed in the context of the owner thread via implicit <code>Invoke</code>. For example, see <a href="chap06.html#highlevel-foreach-onstopinvoke"><code>Parallel.ForEach.OnStopInvoke</code></a>.</p>

<p>Calling <code>Terminate</code> will stop background workers. If they stop in <code>maxWait_ms</code>, <code>True</code> will be returned, <code>False</code> otherwise. <code>WaitFor</code> waits for workers to stop (without commanding them to stop beforehand so you would have to call <code>Terminate</code> before <code>WaitFor</code>) and returns <code>True</code>/<code>False</code> just as <code>Terminate</code> does.</p>

<h4 id="highlevel-backgroundworker-initialization">
<span class="section-number">3.9.3 </span>Task initialization</h4>

<p><em>Background worker</em> implements a mechanism that can be used by worker tasks to initialize and destroy task-specific structures. </p>

<p>By calling <code>Initialize</code>, you can provide a task <em>initializer</em> which is executed once for each worker task before it begins processing work items. Similarly, by calling <code>Finalize</code> you provide the background worker with a task <em>finalizer</em> which is called just before the background task is destroyed. </p>

<p>Both initializer and finalizer will receive a <code>taskState</code> variable where you can store any task-specific data (for example, a class containing multiple task-specific structures). This <em>task state</em> is also available in the executor method through the property <code>IOmniWorkItem.TaskState</code>.</p>

<h4 id="leanpub-auto-work-item-configuration">
<span class="section-number">3.9.4 </span>Work item configuration</h4>

<p>You can pass additional configuration parameters to the <code>Schedule</code> method by providing a configuration block, which can be created by calling the <code>Config</code> method. By using this approach, you can set a custom executor method or a custom completion method for each separate work item.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">type</code>
<code class="lineno">2 </code>  <code class="n">IOmniWorkItemConfig</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno">3 </code>    <code class="k">function</code>  <code class="nf">OnExecute</code><code class="p">(</code><code class="k">const</code> <code class="n">aTask</code><code class="o">:</code> <code class="n">TOmniBackgroundWorkerDelegate</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">4 </code>      <code class="n">IOmniWorkItemConfig</code><code class="o">;</code>
<code class="lineno">5 </code>    <code class="k">function</code>  <code class="nf">OnRequestDone</code><code class="p">(</code><code class="k">const</code> <code class="n">aTask</code><code class="o">:</code> <code class="n">TOmniWorkItemDoneDelegate</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">6 </code>      <code class="n">IOmniWorkItemConfig</code><code class="o">;</code>
<code class="lineno">7 </code>    <code class="k">function</code>  <code class="nf">OnRequestDone_Asy</code><code class="p">(</code><code class="k">const</code> <code class="n">aTask</code><code class="o">:</code> <code class="n">TOmniWorkItemDoneDelegate</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">8 </code>      <code class="n">IOmniWorkItemConfig</code><code class="o">;</code>
<code class="lineno">9 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="highlevel-backgroundworker-iomniworkitem">
<span class="section-number">3.9.5 </span>Work item interface</h4>

<p><code>CreateWorkItem</code> method returns an <code>IOmniWorkItem</code> interface.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">IOmniWorkItem</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 3 </code>    <code class="k">function</code>  <code class="nf">DetachException</code><code class="o">:</code> <code class="n">Exception</code><code class="o">;</code>
<code class="lineno"> 4 </code>    <code class="k">function</code>  <code class="nf">FatalException</code><code class="o">:</code> <code class="n">Exception</code><code class="o">;</code>
<code class="lineno"> 5 </code>    <code class="k">function</code>  <code class="nf">IsExceptional</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 6 </code>    <code class="k">property</code> <code class="py">CancellationToken</code><code class="o">:</code> <code class="n">IOmniCancellationToken</code>
<code class="lineno"> 7 </code>      <code class="kp">read</code> <code class="nf">GetCancellationToken</code><code class="o">;</code>
<code class="lineno"> 8 </code>    <code class="k">property</code> <code class="py">Data</code><code class="o">:</code> <code class="n">TOmniValue</code> <code class="kp">read</code> <code class="nf">GetData</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">property</code> <code class="bp">Result</code><code class="o">:</code> <code class="py">TOmniValue</code> <code class="kp">read</code> <code class="nf">GetResult</code> <code class="kp">write</code> <code class="nf">SetResult</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">property</code> <code class="py">SkipCompletionHandler</code><code class="o">:</code> <code class="kt">boolean</code> <code class="kp">read</code> <code class="nf">GetSkipCompletionHandler</code> <code class="kp">write</code>
<code class="lineno">11 </code>      <code class="nf">SetSkipCompletionHandler</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">property</code> <code class="py">Task</code><code class="o">:</code> <code class="n">IOmniTask</code> <code class="kp">read</code> <code class="nf">GetTask</code><code class="o">;</code>
<code class="lineno">13 </code>    <code class="k">property</code> <code class="py">TaskState</code><code class="o">:</code> <code class="n">TOmniValue</code> <code class="kp">read</code> <code class="nf">GetTaskState</code><code class="o">;</code>    
<code class="lineno">14 </code>    <code class="k">property</code> <code class="py">UniqueID</code><code class="o">:</code> <code class="kt">int64</code> <code class="kp">read</code> <code class="nf">GetUniqueID</code><code class="o">;</code>
<code class="lineno">15 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>It contains input data (<code>Data</code> property), result (<code>Result</code> property) and a unique ID, which is assigned in the <code>CreateWorkItem</code> call. First work item gets ID 1, second ID 2 and so on. This allows for some flexibility when you want to cancel work items. You can cancel one specific item by calling <code>workItem.CancellationToken.Signal</code> or multiple items by calling <code>backgroundWorker.CancelAll(highestIDToBeCancelled)</code> or all items by calling <code>backgroundWorker.CancelAll</code>.</p>

<p>Cancellation is partly automatic and partly cooperative. If the work item that is to be cancelled has not yet reached the execution, the system will prevent it from ever being executed. If, however, work item is already being processed, your code must occasionally check <code>workItem.CancellationToken.IsSignalled</code> and exit if that happens (provided that you want to support cancellation at all). Regardless of how the work item was cancelled, completion handler will still be called and it can check <code>workItem.CancellationToken.IsSignalled</code> to check whether the work item was cancelled prematurely or not.</p>

<p>Any uncaught exception will be stored in the <code>FatalException</code> property. You can detach (and take ownership of) the exception by calling the <code>DetachException</code> and you can test if there was an exception by calling <code>IsExceptional</code>. If <code>IsExceptional</code> returns <code>True</code>, any access to the <code>Result</code> property will raise exception stored in the <code>FatalException</code> property. [In other words – if an unhandled exception occurs in the executor code (in the background thread), it will propagate to the place where you access <code>workItem.Result</code>.]</p>

<p>Property <code>Task</code> provides access to the task executing the work item. Property <code>TaskState</code> returns the value initialized in the <a href="chap06.html#highlevel-backgroundworker-initialization">task initializer</a>.</p>

<p id="highlevel-backgroundworker-iomniworkitem-skipcompletionhandler">If <code>SkipCompletionHandler</code> is set to <code>True</code> when work item is created or during its execution, request handlers for that work item won’t be called.</p>

<p>If <code>SkipCompletionHandler</code> is set to <code>True</code> in the <code>OnRequestDone_Asy</code> handler, then <code>OnRequestDone</code> handler won’t be called.</p>

<h4 id="leanpub-auto-examples-2">
<span class="section-number">3.9.6 </span>Examples</h4>

<p>Practical examples of <em>Background Worker</em> usage can be found in chapters <a href="chap10.html#howto-listPartitioning">Background worker and list partitioning</a> and <a href="chap10.html#howto-databases">OmniThreadLibrary and databases</a>.</p>


<div class="page-break"></div>
<h3 id="highlevel-pipeline">
<span class="section-number">3.10 </span>Pipeline</h3>

<p><em>Pipeline</em> abstraction encapsulates multistage processes in which the data processing can be split into multiple independent stages connected with data queues.</p>

<aside>

<div class="figure-wrapper center">
  <figure class="image" style="width: 468px;">
    <img src="images/highlevel----pipeline.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


</aside>

<aside>
  <p><em>When you call <code>Parallel.Pipeline</code>, background tasks for all stages are started each in its own thread. The system also creates input queue, output queue and interconnecting queues.</em></p>

</aside>

<p>
  <em>See also <a href="chap12.html#demos">demo</a> <code>41_Pipeline</code>.</em>
</p>

<div class="page-break"></div>
<p>Example:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">uses</code>
<code class="lineno"> 2 </code>  <code class="n">OtlCommon</code><code class="o">,</code>
<code class="lineno"> 3 </code>  <code class="n">OtlCollections</code><code class="o">,</code>
<code class="lineno"> 4 </code>  <code class="n">OtlParallel</code><code class="o">;</code>
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code><code class="k">var</code>
<code class="lineno"> 7 </code>  <code class="nb">sum</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 8 </code>
<code class="lineno"> 9 </code><code class="nb">sum</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">Pipeline</code>
<code class="lineno">10 </code>  <code class="o">.</code><code class="n">Stage</code><code class="p">(</code>
<code class="lineno">11 </code>    <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">input</code><code class="o">,</code> <code class="n">output</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="p">)</code>
<code class="lineno">12 </code>    <code class="k">var</code>
<code class="lineno">13 </code>      <code class="n">i</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">14 </code>    <code class="k">begin</code>
<code class="lineno">15 </code>      <code class="k">for</code> <code class="n">i</code> <code class="o">:=</code> <code class="mi">1</code> <code class="k">to</code> <code class="mi">1000000</code> <code class="k">do</code>
<code class="lineno">16 </code>        <code class="n">output</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">17 </code>    <code class="k">end</code><code class="p">)</code>
<code class="lineno">18 </code>  <code class="o">.</code><code class="n">Stage</code><code class="p">(</code>
<code class="lineno">19 </code>    <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">input</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code> <code class="k">var</code> <code class="n">output</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno">20 </code>    <code class="k">begin</code>
<code class="lineno">21 </code>      <code class="n">output</code> <code class="o">:=</code> <code class="n">input</code><code class="o">.</code><code class="n">AsInteger</code> <code class="o">*</code> <code class="mi">3</code><code class="o">;</code>
<code class="lineno">22 </code>    <code class="k">end</code><code class="p">)</code>
<code class="lineno">23 </code>  <code class="o">.</code><code class="n">Stage</code><code class="p">(</code>
<code class="lineno">24 </code>    <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">input</code><code class="o">,</code> <code class="n">output</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="p">)</code>
<code class="lineno">25 </code>    <code class="k">var</code>
<code class="lineno">26 </code>      <code class="nb">sum</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">27 </code>      <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno">28 </code>    <code class="k">begin</code>
<code class="lineno">29 </code>      <code class="nb">sum</code> <code class="o">:=</code> <code class="mi">0</code><code class="o">;</code>
<code class="lineno">30 </code>      <code class="k">for</code> <code class="n">value</code> <code class="k">in</code> <code class="n">input</code> <code class="k">do</code>
<code class="lineno">31 </code>        <code class="nb">Inc</code><code class="p">(</code><code class="nb">sum</code><code class="o">,</code> <code class="n">value</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">32 </code>      <code class="n">output</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="nb">sum</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">33 </code>    <code class="k">end</code><code class="p">)</code>
<code class="lineno">34 </code>  <code class="o">.</code><code class="n">Run</code><code class="o">.</code><code class="n">Output</code><code class="o">.</code><code class="n">Next</code><code class="o">;</code>
</pre></div>

</figure>

<p>This example creates a three-stage pipeline. First stage generates numbers from 1 to 1.000,000. Second stage multiplies each number by 3. Third stage adds all numbers together and writes the result to the output queue. This result is then stored in the variable <code>sum</code>. </p>

<h4 id="leanpub-auto-background">
<span class="section-number">3.10.1 </span>Background</h4>

<p>The <em>Pipeline</em> abstraction is appropriate for parallelizing processes that can be split into stages (subprocesses), connected with data queues. Data flows from the input queue into the first stage where it is partially processed and then emitted into an intermediary queue. The first stage then continues execution, processes more input data and outputs more output data. This continues until complete input is processed. The intermediary queue leads into the next stage which does the processing in a similar manner and so on and on. At the end, the data is output into a queue which can be then read and processed by the program that created this multistage process. As a whole, a multistage process acts as a pipeline – data comes in, data comes out (and a miracle occurs in-between ;)). </p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 70%;">
    <img src="images/highlevel----pipeline1.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<p>What is important here is that no stage shares state with any other stage.  The only interaction between stages is done with the data passed through the intermediary queues. The quantity of data, however, doesn’t have to be constant. It is entirely possible for a stage to generate more or less data than it received on the input queue.</p>

<p>In a classical single-threaded program the execution plan for a multistage process is very simple.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 70%;">
    <img src="images/highlevel----pipeline2.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<p>In a multi-threaded environment, however, we can do better than that. Because the stages are mostly independent, they can be executed in parallel. </p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 50%;">
    <img src="images/highlevel----pipeline3.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<h4 id="leanpub-auto-basics-1">
<span class="section-number">3.10.2 </span>Basics</h4>

<p>A <em>Pipeline</em> is created by calling <code>Parallel.Pipeline</code> function which returns an <code>IOmniPipeline</code> interface. There are three overloaded versions of this function. The first creates an unconfigured pipeline. The second prepares one or more stages and optionally sets the input queue. The third prepares one or more stages with a different method signature.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">TPipelineStageDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">input</code><code class="o">,</code> <code class="n">output</code><code class="o">:</code>
<code class="lineno"> 2 </code>  <code class="n">IOmniBlockingCollection</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="n">TPipelineStageDelegateEx</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">input</code><code class="o">,</code> <code class="n">output</code><code class="o">:</code>
<code class="lineno"> 4 </code>  <code class="n">IOmniBlockingCollection</code><code class="o">;</code> <code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code><code class="k">class</code> <code class="k">function</code> <code class="nf">Pipeline</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 7 </code><code class="k">class</code> <code class="k">function</code> <code class="nf">Pipeline</code><code class="p">(</code><code class="k">const</code> <code class="n">stages</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">TPipelineStageDelegate</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="k">const</code> <code class="n">input</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code> <code class="o">=</code> <code class="k">nil</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 9 </code><code class="k">class</code> <code class="k">function</code> <code class="nf">Pipeline</code><code class="p">(</code><code class="k">const</code> <code class="n">stages</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">TPipelineStageDelegateEx</code><code class="o">;</code>
<code class="lineno">10 </code>  <code class="k">const</code> <code class="n">input</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code> <code class="o">=</code> <code class="k">nil</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<p>Stages are implemented as <a href="chap06.html#highLevel-intro-AnonymousEtAl">anonymous procedures, procedures or methods</a> taking two queue parameters – one for input and one for output. Both queues are automatically created by the <em>Pipeline</em> implementation and passed to the stage delegate.</p>

<p><em>Pipeline</em> also supports the concept of <em>simple stages</em> where stage method accepts a <code>TOmniValue</code> input and provides a <code>TOmniValue</code> output. In this case, OmniThreadLibrary provides the loop which reads data from the input queue, calls your stage code and writes data to the output queue. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">TPipelineSimpleStageDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code>
<code class="lineno">2 </code>  <code class="k">const</code> <code class="n">input</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code> <code class="k">var</code> <code class="n">output</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>Simple stage can produce zero or one data element for each input. Only if the code assigns a value to the <code>output</code> parameter, the value will be written to the output queue.</p>

<h4 id="leanpub-auto-iomnipipeline-interface">
<span class="section-number">3.10.3 </span>IOmniPipeline interface</h4>

<p>All <code>Parallel.Pipeline</code> overloads return the <code>IOmniPipeline</code> interface.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">IOmniPipeline</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 2 </code>  <code class="k">procedure</code> <code class="nf">Cancel</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="k">function</code>  <code class="nf">From</code><code class="p">(</code><code class="k">const</code> <code class="n">queue</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="k">function</code>  <code class="nf">HandleExceptions</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="k">function</code>  <code class="nf">NoThrottling</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="k">function</code>  <code class="nf">NumTasks</code><code class="p">(</code><code class="n">numTasks</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="k">function</code>  <code class="nf">OnStop</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="k">function</code>  <code class="nf">OnStop</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TOmniTaskStopDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="k">function</code>  <code class="nf">OnStopInvoke</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code>
<code class="lineno">10 </code>  <code class="k">function</code>  <code class="nf">Run</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="k">function</code>  <code class="nf">Stage</code><code class="p">(</code>
<code class="lineno">12 </code>    <code class="n">pipelineStage</code><code class="o">:</code> <code class="n">TPipelineSimpleStageDelegate</code><code class="o">;</code> 
<code class="lineno">13 </code>    <code class="n">taskConfig</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code> <code class="o">=</code> <code class="k">nil</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">14 </code>  <code class="k">function</code>  <code class="nf">Stage</code><code class="p">(</code>
<code class="lineno">15 </code>    <code class="n">pipelineStage</code><code class="o">:</code> <code class="n">TPipelineStageDelegate</code><code class="o">;</code> 
<code class="lineno">16 </code>    <code class="n">taskConfig</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code> <code class="o">=</code> <code class="k">nil</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">17 </code>  <code class="k">function</code>  <code class="nf">Stage</code><code class="p">(</code>
<code class="lineno">18 </code>    <code class="n">pipelineStage</code><code class="o">:</code> <code class="n">TPipelineStageDelegateEx</code><code class="o">;</code> 
<code class="lineno">19 </code>    <code class="n">taskConfig</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code> <code class="o">=</code> <code class="k">nil</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">20 </code>  <code class="k">function</code>  <code class="nf">Stages</code><code class="p">(</code>
<code class="lineno">21 </code>    <code class="k">const</code> <code class="n">pipelineStages</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">TPipelineSimpleStageDelegate</code><code class="o">;</code>
<code class="lineno">22 </code>    <code class="n">taskConfig</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code> <code class="o">=</code> <code class="k">nil</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">23 </code>  <code class="k">function</code>  <code class="nf">Stages</code><code class="p">(</code>
<code class="lineno">24 </code>    <code class="k">const</code> <code class="n">pipelineStages</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">TPipelineStageDelegate</code><code class="o">;</code> 
<code class="lineno">25 </code>    <code class="n">taskConfig</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code> <code class="o">=</code> <code class="k">nil</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">26 </code>  <code class="k">function</code>  <code class="nf">Stages</code><code class="p">(</code>
<code class="lineno">27 </code>    <code class="k">const</code> <code class="n">pipelineStages</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">TPipelineStageDelegateEx</code><code class="o">;</code> 
<code class="lineno">28 </code>    <code class="n">taskConfig</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code> <code class="o">=</code> <code class="k">nil</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">29 </code>  <code class="k">function</code>  <code class="nf">Throttle</code><code class="p">(</code><code class="n">numEntries</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">unblockAtCount</code><code class="o">:</code> <code class="kt">integer</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">30 </code>    <code class="n">IOmniPipeline</code><code class="o">;</code>
<code class="lineno">31 </code>  <code class="k">function</code>  <code class="nf">WaitFor</code><code class="p">(</code><code class="n">timeout_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">32 </code>  <code class="k">property</code> <code class="py">Input</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code> <code class="kp">read</code> <code class="nf">GetInput</code><code class="o">;</code>
<code class="lineno">33 </code>  <code class="k">property</code> <code class="py">Output</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code> <code class="kp">read</code> <code class="nf">GetOutput</code><code class="o">;</code>
<code class="lineno">34 </code>  <code class="k">property</code> <code class="py">PipelineStage</code><code class="p">[</code><code class="n">idxStage</code><code class="o">:</code> <code class="kt">integer</code><code class="p">]</code><code class="o">:</code> <code class="n">IOmniPipelineStage</code> <code class="kp">read</code> <code class="nf">GetPipelineStage</code><code class="o">;</code>
<code class="lineno">35 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>Various <code>Stage</code> and <code>Stages</code> overloads can be used to define one or more stages and optionally configure them with a <a href="chap06.html#highlevel-taskconfig">task configuration block</a>.</p>

<p>The <code>Run</code> function does all the hard work. It creates queues and sets up OmniThreadLibrary tasks. </p>

<p>The <code>OnStop</code> function assigns a termination handler - a code that will be called when all pipeline stages stop working. This termination handler is called from one of the worker threads, not from the main thread! If you need to run a code in the main thread, use the <a href="chap06.html#highlevel-taskconfig">task configuration block</a> on the last stage.</p>

<p>Another possibility is to use another variation of <code>OnStop</code> that accepts a delegate with an <code>IOmniTask</code> parameter. You can then use <a href="chap07.html#lowlevel-tomniworker-tomniworkerinvoke"><code>task.Invoke</code></a> to execute a code in the context of the main thread.</p>

<p id="highlevel-pipeline-onstopinvoke">Release <sup>[3.07.2]</sup> introduced method <code>OnStopInvoke</code> which works like <code>OnStop</code> except that the termination handler is automatically executed in the context of the owner thread via implicit <code>Invoke</code>. For example, see <a href="chap06.html#highlevel-foreach-onstopinvoke"><code>Parallel.ForEach.OnStopInvoke</code></a>.</p>

<p>The <code>From</code> function sets the input queue. It will be passed to the first stage in the <code>input</code> parameter. If your code does not call this function, OmniThreadLibrary will automatically create the input queue for you. Input queue can be accessed through the <code>Input</code> property.</p>

<p>The output queue is always created automatically. It can be accessed through the <code>Output</code> property. Even if the last stage doesn’t produce any result, this queue can be used to signal the end of computation. [When each stage ends, CompleteAdding is automatically called on the output queue. This allows the next stage to detect the end of input (blocking collection enumerator will exit or <code>TryTake</code> will return false). Same goes on for the output queue.]</p>

<p>The <code>WaitFor</code> function waits for up to <code>timeout_ms</code> milliseconds for the pipeline to finish the work. It returns <code>True</code> if all stages have processed the data before the time interval expires.</p>

<p>The <code>NumTasks</code> function sets the number of parallel execution tasks for the stage(s) just added with the <code>Stage(s)</code> function (IOW, call <code>Stage</code> followed by <code>NumTasks</code> to do that). If it is called before any stage is added, it will specify the default for all stages. Number of parallel execution tasks for a specific stage can then still be overridden by calling <code>NumTasks</code> after the <code>Stage</code> is called. [See the <a href="chap06.html#highlevel-pipeline-parallel">Parallel stages</a> section below for more information.] </p>

<p>If <code>NumTasks</code> receives a positive parameter (<code>&gt; 0</code>), the number of worker tasks is set to that number. For example, <code>NumTasks(16)</code> starts <em>16</em> worker tasks, even if that is more than the number of available cores. </p>

<p>If <code>NumTasks</code> receives a negative parameter (<code>&lt; 0</code>), it specifies the number of cores that should be reserved for other use. The number of worker tasks is then set to <code>&lt;number of available cores&gt; - &lt;number of reserved cores&gt;</code>. If, for example, current process can use <em>16</em> cores and <code>NumTasks(-4)</code> is used, only <em>12</em> (<em>16-4</em>) worker tasks will be started.</p>

<p>Value <em>0</em> is not allowed and results in an exception.</p>

<p>The <code>Throttle</code> functions sets the throttling parameters for stage(s) just added with the <code>Stage(s)</code> function. Just as the <code>NumTask</code> it affects either the global defaults or just currently added stage(s). By default, throttling is set to <em>10,240</em> elements. [See the <a href="chap06.html#highlevel-pipeline-throttling">Throttling</a> section below for more info.]</p>

<p id="highlevel-pipeline-nothrottle">Up to version <sup>[3.07]</sup> it was not possible to fully disable the <a href="chap06.html#highlevel-pipeline-throttling">throttling mechanism</a>. To fix this problem, version <sup>[3.07]</sup> introduced method <code>NoThrottle</code> which disables throttling on stage(s) just added with the <code>Stage(s)</code> function. </p>

<p>The <code>HandleExceptions</code> function changes the stage wrapper code so that it will pass exceptions from the input queue to the stage code. Just as the <code>NumTask</code> it affects either the global defaults or just currently added stage(s). [See the <a href="chap06.html#highlevel-pipeline-exceptions">Exceptions</a> section below for more info.]</p>

<p>The <code>PipelineStage[]</code> index property allows the program to access input and output pipeline of each stage. This allows the code to insert messages at any point in the pipeline.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">IOmniPipelineStage</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno">2 </code>  <code class="k">property</code> <code class="py">Input</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code> <code class="kp">read</code> <code class="nf">GetInput</code><code class="o">;</code>
<code class="lineno">3 </code>  <code class="k">property</code> <code class="py">Output</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code> <code class="kp">read</code> <code class="nf">GetOutput</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h5 id="leanpub-auto-example-1">
<span class="section-number">3.10.3.1 </span>Example</h5>

<p>An example will help explain all this.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">Parallel</code><code class="o">.</code><code class="n">Pipeline</code>
<code class="lineno">2 </code>  <code class="o">.</code><code class="n">Throttle</code><code class="p">(</code><code class="mi">1000</code><code class="p">)</code>
<code class="lineno">3 </code>  <code class="o">.</code><code class="n">Stage</code><code class="p">(</code><code class="n">StageGenerate</code><code class="p">)</code>
<code class="lineno">4 </code>  <code class="o">.</code><code class="n">Stage</code><code class="p">(</code><code class="n">StageMult2</code><code class="p">)</code>
<code class="lineno">5 </code>  <code class="o">.</code><code class="n">Stages</code><code class="p">([</code><code class="n">StageMinus3</code><code class="o">,</code> <code class="n">StageMod5</code><code class="p">])</code>
<code class="lineno">6 </code>    <code class="o">.</code><code class="n">NumTasks</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>
<code class="lineno">7 </code>  <code class="o">.</code><code class="n">Stage</code><code class="p">(</code><code class="n">StageSum</code><code class="p">)</code>
<code class="lineno">8 </code>  <code class="o">.</code><code class="n">Run</code><code class="o">;</code>
</pre></div>

</figure>

<p>First, a global throttling parameter is set. It will be applied to all stages. Two stages are then added, each with a separate call to the <code>Stage</code> function.</p>

<p>Another two stages are then added with one call. They are both set to execute in two parallel tasks. At the end another stage is added and the whole setup is executed.</p>

<p>The complete process will use seven tasks (one for StageGenerate, one for StageMult2, two for StageMinus3, two for StageMod5 and one for StageSum).</p>

<h4 id="leanpub-auto-generators-mutators-and-aggregators">
<span class="section-number">3.10.4 </span>Generators, mutators, and aggregators</h4>

<p>Let’s look at three different examples of multiprocessing stages.</p>

<p>A stage may accept no input and just generate an output. This will only happen in the first stage. (A middle stage accepting no input would render the whole pipeline rather useless.) </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">StageGenerate</code><code class="p">(</code><code class="k">const</code> <code class="n">input</code><code class="o">,</code> <code class="n">output</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">var</code>
<code class="lineno">3 </code>  <code class="n">i</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">begin</code>
<code class="lineno">5 </code>  <code class="k">for</code> <code class="n">i</code> <code class="o">:=</code> <code class="mi">1</code> <code class="k">to</code> <code class="mi">1000000</code> <code class="k">do</code>
<code class="lineno">6 </code>    <code class="n">output</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">7 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>A stage may also read data from the input and generate the output. Zero, one or more elements could be generated for each input.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">StageMult2</code><code class="p">(</code><code class="k">const</code> <code class="n">input</code><code class="o">,</code> <code class="n">output</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">var</code>
<code class="lineno">3 </code>  <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">begin</code>
<code class="lineno">5 </code>  <code class="k">for</code> <code class="n">value</code> <code class="k">in</code> <code class="n">input</code> <code class="k">do</code>
<code class="lineno">6 </code>    <code class="n">output</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="mi">2</code> <code class="o">*</code> <code class="n">value</code><code class="o">.</code><code class="n">AsInteger</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">7 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The last example is a stage that reads data from the input, performs some operation on it and returns the aggregation of this data.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">StageSum</code><code class="p">(</code><code class="k">const</code> <code class="n">input</code><code class="o">,</code> <code class="n">output</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="nb">sum</code>  <code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="nb">sum</code> <code class="o">:=</code> <code class="mi">0</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="k">for</code> <code class="n">value</code> <code class="k">in</code> <code class="n">input</code> <code class="k">do</code>
<code class="lineno"> 8 </code>    <code class="nb">Inc</code><code class="p">(</code><code class="nb">sum</code><code class="o">,</code> <code class="n">value</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="n">output</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="nb">sum</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>All examples are just special cases of the general principle. <em>Pipeline</em> doesn’t enforce any correlation between the amount of input data and the amount of output data. There’s also absolutely no requirement that data must be all numbers. Feel free to pass around anything that can be contained in a <code>TOmniValue</code>.</p>

<h4 id="highlevel-pipeline-throttling">
<span class="section-number">3.10.5 </span>Throttling</h4>

<p>In some cases, large amount of data may be passed through the multistage process. If one stage is suspended for some time – or if it performs a calculation that is slower than the calculation in the previous stage – this stage’s input queue may fill up with data which can cause lots of memory to be allocated and later released. To even out the data flow, <em>Pipeline</em> uses throttling.</p>

<p>Throttling sets the maximum size of the blocking collection (in <code>TOmniValue</code> units). When the specified quantity of data items is stored in the collection, no more data can be added. The <code>Add</code> function will simply block until the collection is empty enough or <code>CompleteAdding</code> has been called. Collection is deemed to be empty enough when the data count drops below some value which can be either passed as a second parameter to the <code>Throttle</code> function or is calculated as a <em>3/4</em> of the maximum size limit if the second parameter is not provided.</p>

<h4 id="highlevel-pipeline-parallel">
<span class="section-number">3.10.6 </span>Parallel stages</h4>

<p>Usually, one thread is started for each stage in the pipeline. In some specialized cases, however, it may be desirable to run more than one task for a stage. </p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 80%;">
    <img src="images/highlevel----pipeline4.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<p>There’s always only one queue sitting between stages even if there are multiple tasks executing a stage. This is easily accomplished by using <a href="chap06.html#highlevel-blocking-collection"><code>IOmniBlockingCollection</code></a> which supports multiple readers and multiple writers in a thread-safe manner.</p>

<p>There’s an important caveat, though. If you split a stage into multiple tasks, data will be processed in an indeterminate order. You cannot know how many items will be processed by each task and in which order they will be processed. Even worse – data will exit multi-task stage in an indeterminate order (data output from one task will be interleaved with the data from the other task). As of this moment there’s no way to enforce original ordering.</p>

<h4 id="highlevel-pipeline-exceptions">
<span class="section-number">3.10.7 </span>Exceptions</h4>

<p>In the <em>Pipeline</em> abstraction, exceptions are passed through the interconnecting queues from one stage to another.</p>

<p>If an unhandled exception occurs in a stage, it gets caught by the wrapper code and is re-queued to the output queue. When a data element containing exception is read by the next stage, it automatically generates an exception which gets passed to the next output queue. In this way, an exception will progress through the pipeline and will be inserted into the output queue. </p>

<p>If you want to handle exceptions in one stage, call the <code>HandleExceptions</code> function after declaring the stage. (You can also call this function before declaring any stage - that way it will change behaviour for all stages.) You can then call the <code>IsException</code> and <code>AsException</code> functions on the input value to check whether a value contains an exception and to access this exception.</p>

<p>Handling the last (output) stage is slightly different. If you don’t want to re-raise exceptions when data is read from the pipeline output, you have to turn the <em>re-raise exception</em> flag off on the output queue by calling <code>pipeline.Output.ReraiseExceptions(false)</code>. </p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 80%;">
    <img src="images/highlevel----pipelineExceptions.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<p>The following example demonstrates the use of exception-handling functions.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">StageException1</code><code class="p">(</code><code class="k">const</code> <code class="n">input</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code> <code class="k">var</code> <code class="n">output</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="n">output</code> <code class="o">:=</code> <code class="n">input</code><code class="o">.</code><code class="n">AsInteger</code> <code class="o">*</code> <code class="mi">42</code><code class="o">;</code>
<code class="lineno"> 4 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code><code class="k">procedure</code> <code class="nf">StageException2</code><code class="p">(</code><code class="k">const</code> <code class="n">input</code><code class="o">,</code> <code class="n">output</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code><code class="k">var</code>
<code class="lineno"> 8 </code>  <code class="n">outVal</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="n">value</code> <code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">begin</code>
<code class="lineno">11 </code>  <code class="k">for</code> <code class="n">value</code> <code class="k">in</code> <code class="n">input</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">12 </code>    <code class="k">if</code> <code class="n">value</code><code class="o">.</code><code class="n">IsException</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno">13 </code>      <code class="n">value</code><code class="o">.</code><code class="n">AsException</code><code class="o">.</code><code class="n">Free</code><code class="o">;</code>
<code class="lineno">14 </code>      <code class="n">outVal</code><code class="o">.</code><code class="n">Clear</code><code class="o">;</code>
<code class="lineno">15 </code>    <code class="k">end</code>
<code class="lineno">16 </code>    <code class="k">else</code>
<code class="lineno">17 </code>      <code class="n">outVal</code> <code class="o">:=</code> <code class="mi">1</code> <code class="o">/</code> <code class="n">value</code><code class="o">.</code><code class="n">AsInteger</code><code class="o">;</code>
<code class="lineno">18 </code>    <code class="k">if</code> <code class="k">not</code> <code class="n">output</code><code class="o">.</code><code class="n">TryAdd</code><code class="p">(</code><code class="n">outVal</code><code class="p">)</code> <code class="k">then</code>
<code class="lineno">19 </code>      <code class="k">break</code><code class="o">;</code> <code class="c1">//for</code>
<code class="lineno">20 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">21 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">22 </code>
<code class="lineno">23 </code><code class="k">procedure</code> <code class="nc">TfrmOtlParallelExceptions</code><code class="o">.</code><code class="nf">btnPipeline1Click</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">24 </code><code class="k">var</code>
<code class="lineno">25 </code>  <code class="n">pipeline</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code>
<code class="lineno">26 </code>  <code class="n">value</code>   <code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno">27 </code><code class="k">begin</code>
<code class="lineno">28 </code>  <code class="c1">//Stage 2 should accept and correct stage 1 exception </code>
<code class="lineno">29 </code>  <code class="c1">//(third output will be empty)</code>
<code class="lineno">30 </code>  <code class="n">pipeline</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">Pipeline</code>
<code class="lineno">31 </code>    <code class="o">.</code><code class="n">Stage</code><code class="p">(</code><code class="n">StageException1</code><code class="p">)</code>
<code class="lineno">32 </code>    <code class="o">.</code><code class="n">Stage</code><code class="p">(</code><code class="n">StageException2</code><code class="p">)</code>
<code class="lineno">33 </code>      <code class="o">.</code><code class="n">HandleExceptions</code>
<code class="lineno">34 </code>    <code class="o">.</code><code class="n">Run</code><code class="o">;</code>
<code class="lineno">35 </code>
<code class="lineno">36 </code>  <code class="c1">// Provide input</code>
<code class="lineno">37 </code>  <code class="k">with</code> <code class="n">pipeline</code><code class="o">.</code><code class="n">Input</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">38 </code>    <code class="c1">// few normal elements</code>
<code class="lineno">39 </code>    <code class="n">Add</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">40 </code>    <code class="n">Add</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">41 </code>    <code class="c1">// then trigger the exception in the first stage;</code>
<code class="lineno">42 </code>    <code class="c1">// this exception should be 'corrected' in the second stage</code>
<code class="lineno">43 </code>    <code class="n">Add</code><code class="p">(</code><code class="s">'three'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">44 </code>    <code class="n">Add</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">45 </code>    <code class="n">CompleteAdding</code><code class="o">;</code>
<code class="lineno">46 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">47 </code>
<code class="lineno">48 </code>  <code class="c1">// Process output; there should be no exception in the output collection</code>
<code class="lineno">49 </code>  <code class="k">for</code> <code class="n">value</code> <code class="k">in</code> <code class="n">pipeline</code><code class="o">.</code><code class="n">Output</code> <code class="k">do</code>
<code class="lineno">50 </code>    <code class="n">Log</code><code class="p">(</code><code class="n">value</code><code class="o">.</code><code class="n">AsString</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">51 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>
  <em>See also <a href="chap12.html#demos">demo</a> <code>48_OtlParallelExceptions</code>.</em>
</p>

<h4 id="leanpub-auto-examples-3">
<span class="section-number">3.10.8 </span>Examples</h4>

<p>Practical example of <em>Pipeline</em> usage can be found in chapter <a href="chap10.html#howto-webDownload">Web download and database storage</a>.</p>


<div class="page-break"></div>
<h3 id="highlevel-for">
<span class="section-number">3.11 </span>Parallel for</h3>

<p><em>Parallel for</em> abstraction creates a parallel <code>for</code> loop that iterates over an integer range in multiple threads. To create a parallel for loop, call <code>Parallel.For</code>. Since version <sup>[3.06]</sup>, <em>Parallel for</em> abstraction can iterate over elements of an array. This kind of parallel for loop is created by calling <code>Parallel.For&lt;T&gt;</code>.</p>

<aside>

<div class="figure-wrapper center">
  <figure class="image" style="width: 468px;">
    <img src="images/highlevel----for.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


</aside>

<aside>
  <p><em><code>Parallel.For</code> provides a simple way to parallelize a <code>for</code> loop. When you use <code>Parallel.For</code>, OmniThreadLibrary starts multiple background tasks, each working on a subset of <code>for</code> loop ranges. By default, <code>For</code> waits for all background threads to complete before the control is returned to the caller.</em></p>

</aside>

<p>
  <em>See also <a href="chap12.html#demos">demos</a> <code>57_For</code> and <code>58_ForVsForEach</code>.</em>
</p>

<aside class="tip blurb">
    <p>OmniThreadLibrary also implements <a href="chap06.html#highlevel-foreach"><em>ForEach</em></a> abstraction, which is much more powerful than <em>Parallel for</em> but also quite slower.</p>

</aside>

<div class="page-break"></div>
<p>Example:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">PrimeCount</code><code class="o">.</code><code class="n">Value</code> <code class="o">:=</code> <code class="mi">0</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">Parallel</code><code class="o">.</code><code class="k">For</code><code class="p">(</code><code class="mi">1</code><code class="o">,</code> <code class="mi">1000000</code><code class="p">)</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">3 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code>
<code class="lineno">4 </code>  <code class="k">begin</code>
<code class="lineno">5 </code>    <code class="k">if</code> <code class="n">IsPrime</code><code class="p">(</code><code class="n">value</code><code class="p">)</code> <code class="k">then</code> 
<code class="lineno">6 </code>      <code class="n">PrimeCount</code><code class="o">.</code><code class="n">Increment</code><code class="o">;</code>
<code class="lineno">7 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">8 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>This simple program calculates the number of prime numbers in the range from one to one million. The <code>PrimeCount</code> object must be capable of atomic increment (a thread-safe increment), which is simple to achieve with the use of the <a href="chap09.html#misc-TOmniAlignedInt32"><code>TOmniAlignedInt32</code></a> record. The ForEach task is coded as an anonymous method but you can also use a <a href="chap06.html#highLevel-intro-AnonymousEtAl">normal method or a normal procedure</a> for the task code.</p>

<h4 id="highlevel-for-iomniparallelsimpleloop">
<span class="section-number">3.11.1 </span>IOmniParallelSimpleLoop interface</h4>

<p>The <code>Parallel.For</code> function returns an <code>IOmniParallelSimpleLoop</code> interface which is used to configure and run the parallel for loop.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniIteratorSimpleSimpleDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">TOmniIteratorSimpleDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="n">taskIndex</code><code class="o">,</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">TOmniIteratorSimpleFullDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="o">;</code> 
<code class="lineno"> 5 </code>    <code class="n">taskIndex</code><code class="o">,</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="n">TOmniSimpleTaskInitializerDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="n">taskIndex</code><code class="o">,</code> <code class="n">fromIndex</code><code class="o">,</code> 
<code class="lineno"> 7 </code>    <code class="n">toIndex</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="n">TOmniSimpleTaskInitializerTaskDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="o">;</code> 
<code class="lineno"> 9 </code>    <code class="n">taskIndex</code><code class="o">,</code> <code class="n">fromIndex</code><code class="o">,</code> <code class="n">toIndex</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">10 </code>  <code class="n">TOmniSimpleTaskFinalizerDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="n">taskIndex</code><code class="o">,</code> <code class="n">fromIndex</code><code class="o">,</code> 
<code class="lineno">11 </code>    <code class="n">toIndex</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="n">TOmniSimpleTaskFinalizerTaskDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="o">;</code> 
<code class="lineno">13 </code>    <code class="n">taskIndex</code><code class="o">,</code> <code class="n">fromIndex</code><code class="o">,</code> <code class="n">toIndex</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">14 </code>
<code class="lineno">15 </code>  <code class="n">IOmniParallelSimpleLoop</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno">16 </code>    <code class="k">function</code>  <code class="nf">CancelWith</code><code class="p">(</code><code class="k">const</code> <code class="n">token</code><code class="o">:</code> <code class="n">IOmniCancellationToken</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelSimpleLoop</code><code class="o">;</code>
<code class="lineno">17 </code>    <code class="k">function</code>  <code class="nf">NoWait</code><code class="o">:</code> <code class="n">IOmniParallelSimpleLoop</code><code class="o">;</code>
<code class="lineno">18 </code>    <code class="k">function</code>  <code class="nf">NumTasks</code><code class="p">(</code><code class="n">taskCount</code> <code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelSimpleLoop</code><code class="o">;</code>
<code class="lineno">19 </code>    <code class="k">function</code>  <code class="nf">OnStop</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelSimpleLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">20 </code>    <code class="k">function</code>  <code class="nf">OnStop</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TOmniTaskStopDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelSimpleLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">21 </code>    <code class="k">function</code>  <code class="nf">OnStopInvoke</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelSimpleLoop</code><code class="o">;</code>
<code class="lineno">22 </code>    <code class="k">function</code>  <code class="nf">TaskConfig</code><code class="p">(</code><code class="k">const</code> <code class="n">config</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelSimpleLoop</code><code class="o">;</code>
<code class="lineno">23 </code>    <code class="k">procedure</code> <code class="nf">Execute</code><code class="p">(</code><code class="n">loopBody</code><code class="o">:</code> <code class="n">TOmniIteratorSimpleSimpleDelegate</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">24 </code>    <code class="k">procedure</code> <code class="nf">Execute</code><code class="p">(</code><code class="n">loopBody</code><code class="o">:</code> <code class="n">TOmniIteratorSimpleDelegate</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">25 </code>    <code class="k">procedure</code> <code class="nf">Execute</code><code class="p">(</code><code class="n">loopBody</code><code class="o">:</code> <code class="n">TOmniIteratorSimpleFullDelegate</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">26 </code>    <code class="k">function</code>  <code class="nf">Initialize</code><code class="p">(</code><code class="n">taskInitializer</code><code class="o">:</code> <code class="n">TOmniSimpleTaskInitializerDelegate</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">27 </code>      <code class="n">IOmniParallelSimpleLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">28 </code>    <code class="k">function</code>  <code class="nf">Initialize</code><code class="p">(</code><code class="n">taskInitializer</code><code class="o">:</code> <code class="n">TOmniSimpleTaskInitializerTaskDelegate</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">29 </code>      <code class="n">IOmniParallelSimpleLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">30 </code>    <code class="k">function</code>  <code class="nf">Finalize</code><code class="p">(</code><code class="n">taskFinalizer</code><code class="o">:</code> <code class="n">TOmniSimpleTaskFinalizerDelegate</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">31 </code>      <code class="n">IOmniParallelSimpleLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">32 </code>    <code class="k">function</code>  <code class="nf">Finalize</code><code class="p">(</code><code class="n">taskFinalizer</code><code class="o">:</code> <code class="n">TOmniSimpleTaskFinalizerTaskDelegate</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">33 </code>      <code class="n">IOmniParallelSimpleLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">34 </code>    <code class="k">function</code>  <code class="nf">WaitFor</code><code class="p">(</code><code class="n">maxWait_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">35 </code>  <code class="k">end</code><code class="o">;</code> 
</pre></div>

</figure>

<p><code>Execute</code> accepts the block of code to be executed for each value in the input container. Three method signatures are supported.</p>

<p>During execution, input data is split into <code>N</code> sequential ranges (where <code>N</code> is the number of concurrently running tasks). Each task is assigned a <em>task index</em> (from <em>0</em> to <code>N-1</code>). This task index can be used for task-specific initialization and is accessible from <code>Initialize</code>, <code>Finalize</code> and <code>Execute</code> delegates.</p>

<p><code>CancelWith</code> enables the <a href="chap06.html#highlevel-foreach-cancellation">cancellation</a> mechanism.</p>

<p>With <code>Initialize</code> you can initialize per-task data before the task begins execution. Such data can be finalized (cleaned up) with <code>Finalize</code>.</p>

<p>If you call the <code>NoWait</code> function, <em>Parallel for</em> will start in the background and control will be returned to the main thread immediately. If <code>NoWait</code> is not called, <code>Execute</code>  will only return after all tasks have stopped working.</p>

<p>By calling <code>NumTasks</code> you can set up the number of worker tasks. By default, the number of tasks is set to <em>[number of cores available to the process] - 1</em> if <code>NoWait</code> or <code>PreserveOrder</code> modifiers are used and to <em>[number of cores available to the process]</em> in all other cases. </p>

<p>If <code>NumTasks</code> receives a positive parameter (<code>&gt; 0</code>), the number of worker tasks is set to that number. For example, <code>NumTasks(16)</code> starts <em>16</em> worker tasks, even if that is more than the number of available cores. </p>

<p>If <code>NumTasks</code> receives a negative parameter (<code>&lt; 0</code>), it specifies the number of cores that should be reserved for other use. The number of worker tasks is then set to <code>&lt;number of available cores&gt; - &lt;number of reserved cores&gt;</code>. If, for example, current process can use <em>16</em> cores and <code>NumTasks(-4)</code> is used, only <em>12</em> (<em>16-4</em>) worker tasks will be started.</p>

<p>Value <em>0</em> is not allowed and results in an exception.</p>

<p><code>OnStop</code> sets up a termination handler which will be called after all tasks will have completed their work. If <code>NoWait</code> function was called, <code>OnStop</code> will be called from one of the worker threads. If, however, <code>NoWait</code> function was not called, <code>OnStop</code> will be called from the thread that created the <em>Parallel for</em> abstraction.</p>

<p id="highlevel-for-onstopinvoke">Release <sup>[3.07.2]</sup> introduced method <code>OnStopInvoke</code> which works like <code>OnStop</code> except that the termination handler is automatically executed in the context of the owner thread via implicit <code>Invoke</code>. For example, see <a href="chap06.html#highlevel-foreach-onstopinvoke"><code>Parallel.ForEach.OnStopInvoke</code></a>.</p>

<p><code>TaskConfig</code> sets up a <a href="chap06.html#highlevel-taskconfig">task configuration block</a>. Same task configuration block will be applied to all worker tasks. </p>

<p>The following example uses <code>TaskConfig</code> to set up a message handler which will receive messages sent from worker tasks.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">FParallel</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="k">For</code><code class="p">(</code><code class="mi">1</code><code class="o">,</code> <code class="mi">17</code><code class="p">)</code>
<code class="lineno"> 2 </code>  <code class="o">.</code><code class="n">TaskConfig</code><code class="p">(</code><code class="n">Parallel</code><code class="o">.</code><code class="n">TaskConfig</code><code class="o">.</code><code class="n">OnMessage</code><code class="p">(</code><code class="k">Self</code><code class="p">))</code>
<code class="lineno"> 3 </code>  <code class="o">.</code><code class="n">NoWait</code>
<code class="lineno"> 4 </code>  <code class="o">.</code><code class="n">OnStop</code><code class="p">(</code><code class="k">procedure</code> <code class="k">begin</code> <code class="nf">FParallel</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code> <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 5 </code>  
<code class="lineno"> 6 </code><code class="n">FParallel</code>
<code class="lineno"> 7 </code>  <code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno"> 8 </code>    <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="o">;</code> <code class="n">taskIndex</code><code class="o">,</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code>
<code class="lineno"> 9 </code>    <code class="k">begin</code>
<code class="lineno">10 </code>      <code class="n">task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="n">WM_LOG</code><code class="o">,</code> <code class="n">value</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>A call to the <code>WaitFor</code> function will wait for up to <code>timeout_ms</code> milliseconds (this value can be set to <code>INFINITE</code>) for all background tasks to terminate. If the tasks terminate in the specified time, <code>WaitFor</code> will return <code>True</code>. Otherwise, it will return <code>False</code>.</p>

<h4 id="leanpub-auto-iterating-over-an-array">
<span class="section-number">3.11.2 </span>Iterating over an array</h4>

<p>Since version <sup>[3.06]</sup> you can use <code>Parallel.For&lt;T&gt;(const arr: TArray&lt;T&gt;)</code> to iterate over elements of an array. <code>Parallel.For&lt;T&gt;</code> returns a <code>IOmniParallelSimpleLoop&lt;T&gt;</code> interface which is almost the same as the <a href="chap06.html#highlevel-for-iomniparallelsimpleloop"><code>IOmniParallelSimpleLoop</code></a> interface returned from <code>Parallel.For</code> except that it operates on elements of the array (<code>value: T</code>) and not on indexes (<code>value: integer</code>).</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniIteratorSimpleSimpleDelegate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">var</code> <code class="n">value</code><code class="o">:</code> <code class="n">T</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">TOmniIteratorSimpleDelegate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="n">taskIndex</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 4 </code>    <code class="k">var</code> <code class="n">value</code><code class="o">:</code> <code class="n">T</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="n">TOmniIteratorSimpleFullDelegate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="o">;</code> 
<code class="lineno"> 6 </code>    <code class="n">taskIndex</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="k">var</code> <code class="n">value</code><code class="o">:</code> <code class="n">T</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>
<code class="lineno"> 8 </code>  <code class="n">IOmniParallelSimpleLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 9 </code>    <code class="k">function</code>  <code class="nf">CancelWith</code><code class="p">(</code><code class="k">const</code> <code class="n">token</code><code class="o">:</code> <code class="n">IOmniCancellationToken</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelSimpleLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code>
<code class="lineno">10 </code>    <code class="k">function</code>  <code class="nf">NoWait</code><code class="o">:</code> <code class="n">IOmniParallelSimpleLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code>
<code class="lineno">11 </code>    <code class="k">function</code>  <code class="nf">NumTasks</code><code class="p">(</code><code class="n">taskCount</code> <code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelSimpleLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code>
<code class="lineno">12 </code>    <code class="k">function</code>  <code class="nf">OnStop</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelSimpleLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">13 </code>    <code class="k">function</code>  <code class="nf">OnStop</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TOmniTaskStopDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelSimpleLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> 
<code class="lineno">14 </code>      <code class="n">overload</code><code class="o">;</code>
<code class="lineno">15 </code>    <code class="k">function</code>  <code class="nf">TaskConfig</code><code class="p">(</code><code class="k">const</code> <code class="n">config</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelSimpleLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code>
<code class="lineno">16 </code>    <code class="k">procedure</code> <code class="nf">Execute</code><code class="p">(</code><code class="n">loopBody</code><code class="o">:</code> <code class="n">TOmniIteratorSimpleSimpleDelegate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">17 </code>    <code class="k">procedure</code> <code class="nf">Execute</code><code class="p">(</code><code class="n">loopBody</code><code class="o">:</code> <code class="n">TOmniIteratorSimpleDelegate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">18 </code>    <code class="k">procedure</code> <code class="nf">Execute</code><code class="p">(</code><code class="n">loopBody</code><code class="o">:</code> <code class="n">TOmniIteratorSimpleFullDelegate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">19 </code>    <code class="k">function</code>  <code class="nf">Initialize</code><code class="p">(</code><code class="n">taskInitializer</code><code class="o">:</code> <code class="n">TOmniSimpleTaskInitializerDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelSi</code><code class="err">\</code>
<code class="lineno">20 </code><code class="n">mpleLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">21 </code>    <code class="k">function</code>  <code class="nf">Initialize</code><code class="p">(</code><code class="n">taskInitializer</code><code class="o">:</code> <code class="n">TOmniSimpleTaskInitializerTaskDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParall</code><code class="err">\</code>
<code class="lineno">22 </code><code class="n">elSimpleLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">23 </code>    <code class="k">function</code>  <code class="nf">Finalize</code><code class="p">(</code><code class="n">taskFinalizer</code><code class="o">:</code> <code class="n">TOmniSimpleTaskFinalizerDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelSimpleLo</code><code class="err">\</code>
<code class="lineno">24 </code><code class="n">op</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">25 </code>    <code class="k">function</code>  <code class="nf">Finalize</code><code class="p">(</code><code class="n">taskFinalizer</code><code class="o">:</code> <code class="n">TOmniSimpleTaskFinalizerTaskDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelSimp</code><code class="err">\</code>
<code class="lineno">26 </code><code class="n">leLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">27 </code>    <code class="k">function</code>  <code class="nf">WaitFor</code><code class="p">(</code><code class="n">maxWait_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">28 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-examples-4">
<span class="section-number">3.11.3 </span>Examples</h4>

<p>Practical example of <em>Parallel.For</em> usage can be found in chapter <a href="chap10.html#howto-parallelForTaskInit">Using task initializers in parallel for</a>.</p>


<div class="page-break"></div>
<h3 id="highlevel-foreach">
<span class="section-number">3.12 </span>ForEach</h3>

<p><em>ForEach</em> abstraction creates a parallel <code>for</code> loop that iterates over a range of data (number range, list, queue, dataset …) in multiple threads. To create a <em>ForEach</em> abstraction, call <code>Parallel.ForEach</code>.</p>

<aside>

<div class="figure-wrapper center">
  <figure class="image" style="width: 340px;">
    <img src="images/highlevel----forEach.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


</aside>

<aside>
  <p><em>When you use <code>Parallel.ForEach</code>, OmniThreadLibrary starts multiple background tasks and connects them to the source through a serialization mechanism. Output is optionally sorted in the order of the input. By default, <code>ForEach</code> waits for all background threads to complete before the control is returned to the caller.</em></p>

</aside>

<p>
  <em>See also <a href="chap12.html#demos">demos</a> <code>35_ParallelFor</code> and <code>36_OrderedFor</code>.</em>
</p>

<aside class="tip blurb">
    <p>OmmiThreadLibrary also implements <a href="chap06.html#highlevel-for"><em>Parallel for</em></a> abstraction, which is more limited than <em>ForEach</em> but runs faster.</p>

</aside>

<div class="page-break"></div>
<p>Example:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">PrimeCount</code><code class="o">.</code><code class="n">Value</code> <code class="o">:=</code> <code class="mi">0</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="p">(</code><code class="mi">1</code><code class="o">,</code> <code class="mi">1000000</code><code class="p">)</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">3 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code>
<code class="lineno">4 </code>  <code class="k">begin</code>
<code class="lineno">5 </code>    <code class="k">if</code> <code class="n">IsPrime</code><code class="p">(</code><code class="n">value</code><code class="p">)</code> <code class="k">then</code> 
<code class="lineno">6 </code>      <code class="n">PrimeCount</code><code class="o">.</code><code class="n">Increment</code><code class="o">;</code>
<code class="lineno">7 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">8 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>This simple program calculates the number of prime numbers in the range from one to one million. The <code>PrimeCount</code> object must be capable of atomic increment (a thread-safe increment), which is simple to achieve with the use of the <a href="chap09.html#misc-TOmniAlignedInt32"><code>TOmniAlignedInt32</code></a> record. The <em>ForEach</em> task is coded as an anonymous method but you can also use a <a href="chap06.html#highLevel-intro-AnonymousEtAl">normal method or a normal procedure</a> for the task code.</p>

<h4 id="leanpub-auto-cooperation">
<span class="section-number">3.12.1 </span>Cooperation</h4>

<p>The main point of the <em>ForEach</em> abstraction is cooperation between the parallel tasks. <em>ForEach</em> goes to great lengths to minimize potential clashes between threads when they access the source data. Except in special occasions (number range, <a href="chap06.html#highlevel-blocking-collection"><code>IOmniBlockingCollection</code></a>), source data is not thread-safe and locking must be used to synchronize access. </p>

<p>To minimize this locking, source data is allocated to worker tasks in blocks. <em>ForEach</em> creates a <em>source provider</em> object which accesses the source data in a thread-safe manner. This source provider makes sure to always return an appropriately sized block of source data (size will depend on the number of tasks, type of the source data and other factors) when a task runs out of data to process. </p>

<p>Because the source data is allocated in blocks, it is possible that one task runs out of work while other tasks are still busy. In this case, a task will <em>steal</em> data from one of the other tasks. This approach makes all tasks as busy as possible while minimizing the contention.</p>

<p>The details of this process are further discussed in section <a href="chap15.html#highlevel-foreach-internals">Internals</a> below.</p>

<h4 id="leanpub-auto-iterating-over-">
<span class="section-number">3.12.2 </span>Iterating over …</h4>

<p>The <code>Parallel</code> class defines many <code>ForEach</code> overloads, each supporting different container type. We will look at them in more detail in the following sections.</p>

<h5 id="leanpub-auto-number-ranges">
<span class="section-number">3.12.2.1 </span>… Number ranges</h5>

<p>To iterate over a range, pass <code>first</code> and <code>last</code> index to the <code>ForEach</code> call. Optionally, you can pass a <code>step</code> parameter, which defaults to <code>1</code>. <code>ForEach</code> will then iterate from <code>first</code> to <code>last</code> with a <code>step</code> increment.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">class</code> <code class="k">function</code> <code class="nf">ForEach</code><code class="p">(</code><code class="nb">low</code><code class="o">,</code> <code class="nb">high</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">step</code><code class="o">:</code> <code class="kt">integer</code> <code class="o">=</code> <code class="mi">1</code><code class="p">)</code><code class="o">:</code>
<code class="lineno">2 </code>  <code class="n">IOmniParallelLoop</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<p>The pseudo-code for <em>numeric</em> <code>ForEach</code> could be written as</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">i</code> <code class="o">:=</code> <code class="nb">low</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">while</code> <code class="p">((</code><code class="n">step</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="k">and</code> <code class="p">(</code><code class="n">i</code> <code class="o">&lt;=</code> <code class="nb">high</code><code class="p">))</code> <code class="k">or</code>
<code class="lineno">3 </code>      <code class="p">((</code><code class="n">step</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code> <code class="k">and</code> <code class="p">(</code><code class="n">i</code> <code class="o">&gt;=</code> <code class="nb">high</code><code class="p">))</code> <code class="k">do</code>
<code class="lineno">4 </code><code class="k">begin</code>
<code class="lineno">5 </code>  <code class="c1">// process 'i' in parallel</code>
<code class="lineno">6 </code>  <code class="k">if</code> <code class="nb">low</code> <code class="o">&lt;</code> <code class="nb">high</code> <code class="k">then</code> <code class="nb">Inc</code><code class="p">(</code><code class="n">i</code><code class="o">,</code> <code class="n">step</code><code class="p">)</code>
<code class="lineno">7 </code>                <code class="k">else</code> <code class="nb">Dec</code><code class="p">(</code><code class="n">i</code><code class="o">,</code> <code class="n">step</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">8 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h5 id="leanpub-auto-enumerable-collections">
<span class="section-number">3.12.2.2 </span>… Enumerable collections</h5>

<p>If you want to iterate over a collection (say, a <code>TStringList</code>), you have two possibilities. </p>

<p>One is to use an equivalent of <code>for i := 0 to sl.Count-1 do Something(sl[i])</code>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="p">(</code><code class="mi">0</code><code class="o">,</code> <code class="n">sl</code><code class="o">.</code><code class="n">Count</code><code class="o">-</code><code class="mi">1</code><code class="p">)</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">2 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code>
<code class="lineno">3 </code>  <code class="k">begin</code>
<code class="lineno">4 </code>    <code class="n">Something</code><code class="p">(</code><code class="n">sl</code><code class="p">[</code><code class="n">value</code><code class="p">])</code><code class="o">;</code>
<code class="lineno">5 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>Another is to use an equivalent of <code>for s in sl do Something(s)</code>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="p">(</code><code class="n">sl</code><code class="p">)</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">2 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno">3 </code>  <code class="k">begin</code>
<code class="lineno">4 </code>    <code class="n">Something</code><code class="p">(</code><code class="n">value</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>In the second example, value is passed to the task function as a <a href="chap05.html#introotl-tomnivalue"><code>TOmniValue</code></a> parameter. In the example above, it will be automatically converted into a string, but sometimes you’ll have to do it manually, by calling <code>value.AsString</code> (or use appropriate casting function when iterating over a different container).</p>

<p>A variation of the second approach is to tell the <code>ForEach</code> that the container contains strings. OmniThreadLibrary will then do the conversion for you.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="o">&lt;</code><code class="k">string</code><code class="o">&gt;</code><code class="p">(</code><code class="n">sl</code><code class="p">)</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">2 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code>
<code class="lineno">3 </code>  <code class="k">begin</code>
<code class="lineno">4 </code>    <code class="n">Something</code><code class="p">(</code><code class="n">value</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>You may wonder which of those approaches is better. The answer depends on whether you can simultaneously access different items in the container from different threads at the same time. In other words, you have to know whether the container is thread-safe for reading. Luckily, all important Delphi containers (<code>TList</code>, <code>TObjectList</code>, <code>TStringList</code>) fall into this category.</p>

<p>If the container is thread-safe for reading, then the <em>numeric</em> approach (<code>ForEach(0, sl.Count-1)</code>) is <strong>much</strong> faster than the <em>for..in</em> approach (<code>ForEach(sl)</code>). The speed difference comes from the locking - in the former example <code>ForEach</code> never locks anything and in the latter example locking is used to synchronize access to the container.</p>

<p>However, if the container is not thread-safe for reading, you <strong>have</strong> to use the latter approach. </p>

<p>There are three ways to iterate over enumerable containers. You can provide the <code>ForEach</code> call with an <code>IEnumerable</code> interface, with an <code>IEnumerator</code> interface or with an enumerable collection itself. In the latter case, OmniThreadLibrary will use RTTI to access the enumerator for the collection. For this to work, enumerator itself must be implemented as an object, not as a record or interface. Luckily, most if not all the VCL enumerators are implemented in this way.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="p">(</code><code class="k">const</code> <code class="n">enumerable</code><code class="o">:</code> <code class="n">IEnumerable</code><code class="p">)</code><code class="o">:</code>
<code class="lineno"> 2 </code>  <code class="n">IOmniParallelLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="p">(</code><code class="k">const</code> <code class="n">enum</code><code class="o">:</code> <code class="n">IEnumerator</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 4 </code>  <code class="n">IOmniParallelLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="p">(</code><code class="k">const</code> <code class="n">enumerable</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 6 </code>  <code class="n">IOmniParallelLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 7 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">enumerable</code><code class="o">:</code> <code class="n">IEnumerable</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 8 </code>  <code class="n">IOmniParallelLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 9 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">enum</code><code class="o">:</code> <code class="n">IEnumerator</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">10 </code>  <code class="n">IOmniParallelLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">11 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">enumerable</code><code class="o">:</code> <code class="n">TEnumerable</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">12 </code>  <code class="n">IOmniParallelLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">13 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">enum</code><code class="o">:</code> <code class="n">TEnumerator</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">14 </code>  <code class="n">IOmniParallelLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">15 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">enumerable</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">16 </code>  <code class="n">IOmniParallelLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">17 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">enum</code><code class="o">:</code> <code class="n">IEnumerator</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">18 </code>  <code class="n">IOmniParallelLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">19 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">enumerable</code><code class="o">:</code> <code class="n">IEnumerable</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">20 </code>  <code class="n">IOmniParallelLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code>  
</pre></div>

</figure>

<p>Support for enumerating over <code>IEnumerator&lt;T&gt;</code> and <code>IEnumerable&lt;T&gt;</code> was added in version <sup>[3.07.7]</sup>.</p>

<h5 id="leanpub-auto-thread-safe-enumerable-collections">
<span class="section-number">3.12.2.3 </span>… Thread-safe enumerable collections</h5>

<p>Collection enumeration uses locking to synchronize access to the collection enumerator, which slows down the enumeration process. In some special cases, collection may be enumerable without the locking. To support enumeration, such collection must implement <code>IOmniValueEnumerable</code> and <code>IOmniValueEnumerator</code> interfaces, which are defined in the <em>OtlCommon</em> unit.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="p">(</code><code class="k">const</code> <code class="n">enumerable</code><code class="o">:</code> <code class="n">IOmniValueEnumerable</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">2 </code>  <code class="n">IOmniParallelLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">3 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="p">(</code><code class="k">const</code> <code class="n">enum</code><code class="o">:</code> <code class="n">IOmniValueEnumerator</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">4 </code>  <code class="n">IOmniParallelLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">5 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">enumerable</code><code class="o">:</code> <code class="n">IOmniValueEnumerable</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">6 </code>  <code class="n">IOmniParallelLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">7 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">enum</code><code class="o">:</code> <code class="n">IOmniValueEnumerator</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">8 </code>  <code class="n">IOmniParallelLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<h5 id="leanpub-auto-blocking-collections">
<span class="section-number">3.12.2.4 </span>… Blocking collections</h5>

<p>To simplify enumerating over <a href="chap06.html#highlevel-blocking-collection">blocking collections</a>, the <code>Parallel</code> class implements two <code>ForEach</code> overloads accepting a blocking collection. Internally, blocking collection is enumerated with the <code>IOmniValueEnumerable</code> interface. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="p">(</code><code class="k">const</code> <code class="n">source</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">2 </code>  <code class="n">IOmniParallelLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">3 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">source</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">4 </code>  <code class="n">IOmniParallelLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<h5 id="leanpub-auto-anything">
<span class="section-number">3.12.2.5 </span>… Anything</h5>

<p>As a last resort, the <code>Parallel</code> class implements three <code>ForEach</code> overloads that will (with some help from the programmer) iterate over any data.</p>

<p>The <code>TOmniSourceProvider</code> way is powerful, but complicated. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="p">(</code><code class="k">const</code> <code class="n">sourceProvider</code><code class="o">:</code> <code class="n">TOmniSourceProvider</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">2 </code>  <code class="n">IOmniParallelLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<p>You must implement a descendant of the <code>TOmniSourceProvider</code> class. All methods must be thread-safe. For more information about the source providers, see the <a href="chap15.html#highlevel-foreach-internals">Internals</a> section, below.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">TOmniSourceProvider</code> <code class="o">=</code> <code class="k">class</code> <code class="kp">abstract</code>
<code class="lineno"> 2 </code><code class="kp">public</code>
<code class="lineno"> 3 </code>  <code class="k">function</code>  <code class="nf">Count</code><code class="o">:</code> <code class="kt">int64</code><code class="o">;</code> <code class="kp">virtual</code><code class="o">;</code> <code class="kp">abstract</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="k">function</code>  <code class="nf">CreateDataPackage</code><code class="o">:</code> <code class="n">TOmniDataPackage</code><code class="o">;</code> <code class="kp">virtual</code><code class="o">;</code> <code class="kp">abstract</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="k">function</code>  <code class="nf">GetCapabilities</code><code class="o">:</code> <code class="n">TOmniSourceProviderCapabilities</code><code class="o">;</code> 
<code class="lineno"> 6 </code>    <code class="kp">virtual</code><code class="o">;</code> <code class="kp">abstract</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="k">function</code>  <code class="nf">GetPackage</code><code class="p">(</code><code class="n">dataCount</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">package</code><code class="o">:</code> <code class="n">TOmniDataPackage</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 8 </code>    <code class="kt">boolean</code><code class="o">;</code> <code class="kp">virtual</code><code class="o">;</code> <code class="kp">abstract</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="k">function</code>  <code class="nf">GetPackageSizeLimit</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="kp">virtual</code><code class="o">;</code> <code class="kp">abstract</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">end</code><code class="o">;</code> 
</pre></div>

</figure>

<p>As this approach is not for the faint of heart, OmniThreadLibrary provides a slower but much simpler version.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="p">(</code><code class="n">enumerator</code><code class="o">:</code> <code class="n">TEnumeratorDelegate</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">2 </code>  <code class="n">IOmniParallelLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">3 </code><code class="k">class</code> <code class="k">function</code>  <code class="nf">ForEach</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">enumerator</code><code class="o">:</code> <code class="n">TEnumeratorDelegate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">4 </code>  <code class="n">IOmniParallelLoop</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<p>Here, you must provide a function that will return <em>next</em> data whenever the <code>ForEach</code> asks for it.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">TEnumeratorDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">function</code><code class="p">(</code><code class="k">var</code> <code class="n">next</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">TEnumeratorDelegate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">function</code><code class="p">(</code><code class="k">var</code> <code class="n">next</code><code class="o">:</code> <code class="n">T</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
</pre></div>

</figure>

<p>OmniThreadLibrary will provide the synchronisation (locking) so you can be sure this method will only be called from one thread at a time. As you may expect, this will slow things down, but parallelization may still give you a reasonable performance increase if <code>ForEach</code> payload is substantial (i.e. if the method you are executing in the <code>ForEach</code> loop takes non-trivial time to execute).</p>

<p>The <code>TEnumeratorDelegate</code> function can also be used as a generator; that is it can <em>calculate</em> the values that will then be processed in the parallel for loop.</p>

<h4 id="leanpub-auto-providing-external-input">
<span class="section-number">3.12.3 </span>Providing external input</h4>

<p>Sometimes, especially when you are dealing with datasets, synchronized access to the container will not be enough. When you are dealing with database connections, datasets etc you can easily run into <em>thread affinity</em> problems - that is the inability of some component to work correctly if it is called from a different thread than the one that it was created in. </p>

<aside class="tip blurb">
    <p>Always initialize database connections and datasets in the thread that will use them. You code <em>may</em> work without that precaution but unless you have extensively tested database components in multiple threads, you should not assume that they will work correctly unless that condition (initialization and use in the same thread) is met.</p>

</aside>

<p>In such case, the best way is to provide the input directly from the main thread. There are few different ways to achieve that.</p>

<ol class="numeric">
  <li>Repackage data into another collection that can be easily consumed in <em>ForEach</em> (<code>TObjectList</code>, <code>TStringList</code>, <code>TOmniBlockingCollection</code>).</li>
  <li>Run the <em>ForEach</em> in <code>NoWait</code> mode, then write the data into the input queue and when you run out of data, wait for the <em>ForEach</em> loop to terminate. This approach is also useful when you want to push <em>ForEach</em> into background and provide it with data from some asynchronous event handler.</li>
</ol>

<p>An example of the second approach will help clarify the idea.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">uses</code>
<code class="lineno"> 2 </code>  <code class="n">OtlCommon</code><code class="o">,</code>
<code class="lineno"> 3 </code>  <code class="n">OtlCollections</code><code class="o">,</code>
<code class="lineno"> 4 </code>  <code class="n">OtlParallel</code><code class="o">;</code>
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code><code class="k">procedure</code> <code class="nf">Test</code><code class="o">;</code>
<code class="lineno"> 7 </code><code class="k">var</code>
<code class="lineno"> 8 </code>  <code class="n">i</code>    <code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="n">input</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="o">;</code>
<code class="lineno">10 </code>  <code class="n">loop</code> <code class="o">:</code> <code class="n">IOmniParallelLoop</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;;</code>
<code class="lineno">11 </code>  <code class="n">wait</code> <code class="o">:</code> <code class="n">IOmniWaitableValue</code><code class="o">;</code>
<code class="lineno">12 </code><code class="k">begin</code>
<code class="lineno">13 </code>  <code class="c1">// create the container</code>
<code class="lineno">14 </code>  <code class="n">input</code> <code class="o">:=</code> <code class="n">TOmniBlockingCollection</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">15 </code>  <code class="c1">// create the 'end of work' signal</code>
<code class="lineno">16 </code>  <code class="n">wait</code> <code class="o">:=</code> <code class="n">CreateWaitableValue</code><code class="o">;</code>
<code class="lineno">17 </code>  <code class="n">loop</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;</code><code class="p">(</code><code class="n">input</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">18 </code>  <code class="c1">// set up the termination method which will signal 'end of work'</code>
<code class="lineno">19 </code>  <code class="n">loop</code><code class="o">.</code><code class="n">OnStop</code><code class="p">(</code>
<code class="lineno">20 </code>    <code class="k">procedure</code>
<code class="lineno">21 </code>    <code class="k">begin</code>
<code class="lineno">22 </code>      <code class="nc">wait</code><code class="o">.</code><code class="nf">Signal</code><code class="o">;</code>
<code class="lineno">23 </code>    <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">24 </code>  <code class="c1">// start the parallel for loop in NoWait mode</code>
<code class="lineno">25 </code>  <code class="n">loop</code><code class="o">.</code><code class="n">NoWait</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">26 </code>    <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code>
<code class="lineno">27 </code>    <code class="k">begin</code>
<code class="lineno">28 </code>      <code class="c1">// do something with the input value</code>
<code class="lineno">29 </code>      <code class="n">OutputDebugString</code><code class="p">(</code><code class="kt">PChar</code><code class="p">(</code><code class="nb">Format</code><code class="p">(</code><code class="s">'%d'</code><code class="o">,</code> <code class="p">[</code><code class="n">value</code><code class="p">])))</code><code class="o">;</code>
<code class="lineno">30 </code>    <code class="k">end</code>
<code class="lineno">31 </code>  <code class="p">)</code><code class="o">;</code>
<code class="lineno">32 </code>  <code class="c1">// provide the data to the parallel for loop</code>
<code class="lineno">33 </code>  <code class="k">for</code> <code class="n">i</code> <code class="o">:=</code> <code class="mi">1</code> <code class="k">to</code> <code class="mi">1000</code> <code class="k">do</code>
<code class="lineno">34 </code>    <code class="n">input</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">35 </code>  <code class="c1">// signal to the parallel for loop that there's no more data to process</code>
<code class="lineno">36 </code>  <code class="n">input</code><code class="o">.</code><code class="n">CompleteAdding</code><code class="o">;</code>
<code class="lineno">37 </code>  <code class="c1">// wait for the parallel for loop to stop</code>
<code class="lineno">38 </code>  <code class="n">wait</code><code class="o">.</code><code class="n">WaitFor</code><code class="o">;</code>
<code class="lineno">39 </code>  <code class="c1">// destroy the parallel for loop</code>
<code class="lineno">40 </code>  <code class="n">loop</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
<code class="lineno">41 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-iomniparallelloop-interface">
<span class="section-number">3.12.4 </span>IOmniParallelLoop interface</h4>

<p>The <code>Parallel.ForEach</code> returns an <code>IOmniParallelLoop</code> interface which is used to configure and run the parallel for loop.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">IOmniParallelLoop</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 2 </code>  <code class="k">function</code>  <code class="nf">Aggregate</code><code class="p">(</code><code class="n">defaultAggregateValue</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno"> 3 </code>    <code class="n">aggregator</code><code class="o">:</code> <code class="n">TOmniAggregatorDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelAggregatorLoop</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="k">function</code>  <code class="nf">AggregateSum</code><code class="o">:</code> <code class="n">IOmniParallelAggregatorLoop</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="k">procedure</code> <code class="nf">Execute</code><code class="p">(</code><code class="n">loopBody</code><code class="o">:</code> <code class="n">TOmniIteratorDelegate</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="k">procedure</code> <code class="nf">Execute</code><code class="p">(</code><code class="n">loopBody</code><code class="o">:</code> <code class="n">TOmniIteratorTaskDelegate</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="k">function</code>  <code class="nf">CancelWith</code><code class="p">(</code><code class="k">const</code> <code class="n">token</code><code class="o">:</code> <code class="n">IOmniCancellationToken</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 8 </code>    <code class="n">IOmniParallelLoop</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="k">function</code>  <code class="nf">Initialize</code><code class="p">(</code><code class="n">taskInitializer</code><code class="o">:</code> <code class="n">TOmniTaskInitializerDelegate</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">10 </code>    <code class="n">IOmniParallelInitializedLoop</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="k">function</code>  <code class="nf">Into</code><code class="p">(</code><code class="k">const</code> <code class="n">queue</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">12 </code>    <code class="n">IOmniParallelIntoLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="k">function</code>  <code class="nf">NoWait</code><code class="o">:</code> <code class="n">IOmniParallelLoop</code><code class="o">;</code>
<code class="lineno">14 </code>  <code class="k">function</code>  <code class="nf">NumTasks</code><code class="p">(</code><code class="n">taskCount</code> <code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelLoop</code><code class="o">;</code>
<code class="lineno">15 </code>  <code class="k">function</code>  <code class="nf">OnMessage</code><code class="p">(</code><code class="n">eventDispatcher</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">16 </code>    <code class="n">IOmniParallelLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code> <code class="n">deprecated</code> <code class="s">'use TaskConfig'</code><code class="o">;</code>
<code class="lineno">17 </code>  <code class="k">function</code>  <code class="nf">OnMessage</code><code class="p">(</code><code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> <code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniTaskMessageEvent</code><code class="p">)</code><code class="o">:</code>
<code class="lineno">18 </code>    <code class="n">IOmniParallelLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code> <code class="n">deprecated</code> <code class="s">'use TaskConfig'</code><code class="o">;</code>
<code class="lineno">19 </code>  <code class="k">function</code>  <code class="nf">OnMessage</code><code class="p">(</code><code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> <code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniOnMessageFunction</code><code class="p">)</code><code class="o">:</code>
<code class="lineno">20 </code>    <code class="n">IOmniParallelLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code> <code class="n">deprecated</code> <code class="s">'use TaskConfig'</code><code class="o">;</code>
<code class="lineno">21 </code>  <code class="k">function</code>  <code class="nf">OnTaskCreate</code><code class="p">(</code><code class="n">taskCreateDelegate</code><code class="o">:</code> <code class="n">TOmniTaskCreateDelegate</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">22 </code>    <code class="n">IOmniParallelLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">23 </code>  <code class="k">function</code>  <code class="nf">OnTaskCreate</code><code class="p">(</code><code class="n">taskCreateDelegate</code><code class="o">:</code> 
<code class="lineno">24 </code>    <code class="n">TOmniTaskControlCreateDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">25 </code>  <code class="k">function</code>  <code class="nf">OnStop</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelLoop</code><code class="o">;</code>
<code class="lineno">26 </code>  <code class="k">function</code>  <code class="nf">OnStop</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TOmniTaskStopDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelLoop</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">27 </code>  <code class="k">function</code>  <code class="nf">OnStopInvoke</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelLoop</code><code class="o">;</code>
<code class="lineno">28 </code>  <code class="k">function</code>  <code class="nf">PreserveOrder</code><code class="o">:</code> <code class="n">IOmniParallelLoop</code><code class="o">;</code>
<code class="lineno">29 </code>  <code class="k">function</code>  <code class="nf">TaskConfig</code><code class="p">(</code><code class="k">const</code> <code class="n">config</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelLoop</code><code class="o">;</code>
<code class="lineno">30 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>ForEach&lt;T&gt;</code> returns an <code>IOmniParallelLoop&lt;T&gt;</code> interface, which is exactly the same as the <code>IOmniParallelLoop</code> except that each method returns the appropriate <code>&lt;T&gt;</code> version of the interface.</p>

<p><code>Aggregate</code> and <code>AggregateSum</code> are used to implement aggregation. See the <a href="chap06.html#highlevel-foreach-aggregation">Aggregation</a> section, below.</p>

<p><code>Execute</code> accepts the block of code to be executed for each value in the input container. Two method signatures are supported, both having the <code>&lt;T&gt;</code> variant. One accepts only the iteration value parameter, and another accepts an additional <a href="chap05.html#introotl-tasksvsthreads"><code>IOmniTask</code></a> parameter.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">TOmniIteratorDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">TOmniIteratorDelegate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">T</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">3 </code><code class="n">TOmniIteratorTaskDelegate</code> <code class="o">=</code>
<code class="lineno">4 </code>  <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="o">;</code> <code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code><code class="n">TOmniIteratorTaskDelegate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="o">=</code> 
<code class="lineno">6 </code>  <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="o">;</code> <code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">T</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>CancelWith</code> enables the <a href="chap06.html#highlevel-foreach-cancellation">cancellation</a> mechanism.</p>

<p>With <code>Initialize</code> and <code>OnTaskCreate</code>, you can initialize per-task data before the task begins execution. See the <a href="chap06.html#highlevel-foreach-taskinit">Task initialization</a> section, below.</p>

<p><code>Into</code> sets up the output queue, see <a href="chap06.html#highlevel-foreach-preserveorder">Preserving output order</a>.</p>

<p>If you call the <code>NoWait</code> function, parallel for will start in the background and control will be returned to the main thread immediately. If <code>NoWait</code> is not called, <code>Execute</code>  will only return after all tasks have stopped working.</p>

<p>By calling <code>NumTasks</code> you can set up the number of worker tasks. By default, the number of tasks is set to <em>[number of cores available to the process] - 1</em> if <code>NoWait</code> or <code>PreserveOrder</code> modifiers are used and to <em>[number of cores available to the process]</em> in all other cases. </p>

<p>If <code>NumTasks</code> receives a positive parameter (<code>&gt; 0</code>), the number of worker tasks is set to that number. For example, <code>NumTasks(16)</code> starts <em>16</em> worker tasks, even if that is more than number of available cores. </p>

<p>If <code>NumTasks</code> receives a negative parameter (<code>&lt; 0</code>), it specifies the number of cores that should be reserved for other use. The number of worker tasks is then set to <code>&lt;number of available cores&gt; - &lt;number of reserved cores&gt;</code>. If, for example, current process can use <em>16</em> cores and <code>NumTasks(-4)</code> is used, only <em>12</em> (<em>16-4</em>) worker tasks will be started.</p>

<p>Value <em>0</em> is not allowed and results in an exception.                       </p>

<p><code>OnMessage</code> functions are deprecated, use <code>TaskConfig</code> instead.</p>

<p><code>OnStop</code> sets up a termination handler which will be called after all parallel for tasks will have completed their work. If <code>NoWait</code> function was called, <code>OnStop</code> will be called from one of the worker threads. If, however, <code>NoWait</code> function was not called, <code>OnStop</code> will be called from the thread that created the <code>ForEach</code> abstraction. This behaviour makes it hard to execute VCL code from the <code>OnStop</code> so release <sup>[3.02]</sup> introduced another variation accepting a delegate with an <code>IOmniTask</code> parameter.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">TOmniTaskStopDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">IOmniParallelLoop</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno">3 </code>  <code class="k">function</code>  <code class="nf">OnStop</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TOmniTaskStopDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelLoop</code><code class="o">;</code>
<code class="lineno">4 </code>    <code class="n">overload</code><code class="o">;</code>
<code class="lineno">5 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>Using this version of <code>OnStop</code>, the termination handler can use <a href="chap07.html#lowlevel-tomniworker-tomniworkerinvoke"><code>task.Invoke</code></a> to execute code in the main thread. This, however, requires the <em>ForEach</em> abstraction to stay alive until the <code>Invoke</code>d code is executed so you must store the result of the <code>ForEach</code> method in a global variable (form field, for example) and destroy it only in the termination handler.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">var</code>
<code class="lineno"> 2 </code>  <code class="n">loop</code><code class="o">:</code> <code class="n">IOmniParallelLoop</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;;</code>
<code class="lineno"> 3 </code>
<code class="lineno"> 4 </code><code class="n">loop</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="p">(</code><code class="mi">1</code><code class="o">,</code> <code class="n">N</code><code class="p">)</code><code class="o">.</code><code class="n">NoWait</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="n">loop</code><code class="o">.</code><code class="n">OnStop</code><code class="p">(</code>
<code class="lineno"> 6 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code>
<code class="lineno"> 7 </code>  <code class="k">begin</code>
<code class="lineno"> 8 </code>    <code class="n">task</code><code class="o">.</code><code class="n">Invoke</code><code class="p">(</code>
<code class="lineno"> 9 </code>      <code class="k">procedure</code>
<code class="lineno">10 </code>      <code class="k">begin</code>
<code class="lineno">11 </code>        <code class="c1">// do anything</code>
<code class="lineno">12 </code>        <code class="nf">loop</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
<code class="lineno">13 </code>      <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">14 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">15 </code><code class="n">loop</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">16 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code>
<code class="lineno">17 </code>  <code class="k">begin</code>
<code class="lineno">18 </code>    <code class="o">...</code>
<code class="lineno">19 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p id="highlevel-foreach-onstopinvoke">Release <sup>[3.07.2]</sup> introduced method <code>OnStopInvoke</code> which works like <code>OnStop</code> except that the termination handler is automatically executed in the context of the owner thread via implicit <code>Invoke</code>.</p>

<p>The code fragment above can be rewritten using <code>OnStopInvoke</code> as follows.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">var</code>
<code class="lineno"> 2 </code>  <code class="n">loop</code><code class="o">:</code> <code class="n">IOmniParallelLoop</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;;</code>
<code class="lineno"> 3 </code>
<code class="lineno"> 4 </code><code class="n">loop</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="p">(</code><code class="mi">1</code><code class="o">,</code> <code class="n">N</code><code class="p">)</code><code class="o">.</code><code class="n">NoWait</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="n">loop</code><code class="o">.</code><code class="n">OnStopInvoke</code><code class="p">(</code>
<code class="lineno"> 6 </code>  <code class="k">procedure</code>
<code class="lineno"> 7 </code>  <code class="k">begin</code>
<code class="lineno"> 8 </code>    <code class="c1">// do anything</code>
<code class="lineno"> 9 </code>    <code class="nf">loop</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
<code class="lineno">10 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">11 </code><code class="n">loop</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">12 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code>
<code class="lineno">13 </code>  <code class="k">begin</code>
<code class="lineno">14 </code>    <code class="o">...</code>
<code class="lineno">15 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>PreserveOrder</code> modifies the <em>Parallel for</em> behaviour so that output values are generated in the order of the corresponding input values. See the <a href="chap06.html#highlevel-foreach-preserveorder">Preserving output order</a> section, below.</p>

<p><code>TaskConfig</code> sets up a <a href="chap06.html#highlevel-taskconfig">task configuration block</a>. Same task configuration block will be applied to all worker tasks. </p>

<p>The following example uses <code>TaskConfig</code> to set up a message handler which will receive messages sent from <code>ForEach</code> worker tasks.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">FParallel</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="p">(</code><code class="mi">1</code><code class="o">,</code> <code class="mi">17</code><code class="p">)</code>
<code class="lineno"> 2 </code>  <code class="o">.</code><code class="n">TaskConfig</code><code class="p">(</code><code class="n">Parallel</code><code class="o">.</code><code class="n">TaskConfig</code><code class="o">.</code><code class="n">OnMessage</code><code class="p">(</code><code class="k">Self</code><code class="p">))</code>
<code class="lineno"> 3 </code>  <code class="o">.</code><code class="n">NoWait</code>
<code class="lineno"> 4 </code>  <code class="o">.</code><code class="n">OnStop</code><code class="p">(</code><code class="k">procedure</code> <code class="k">begin</code> <code class="nf">FParallel</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code> <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 5 </code>  
<code class="lineno"> 6 </code><code class="n">FParallel</code>
<code class="lineno"> 7 </code>  <code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno"> 8 </code>    <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="o">;</code> <code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code>
<code class="lineno"> 9 </code>    <code class="k">begin</code>
<code class="lineno">10 </code>      <code class="n">task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="n">WM_LOG</code><code class="o">,</code> <code class="n">value</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>Messages sent from the worker task are received and dispatched by the <code>IOmniParallelLoop</code> interface. This requires the <em>ForEach</em> abstraction to stay alive until the messages are processed so you must store the result of the <code>ForEach</code> method in a global variable (form field, for example) and destroy it only in the <code>OnStop</code> handler.</p>

<p>Some functions return a different interface. Typically, it only implements the <code>Execute</code> function accepting a different parameter than the ‘normal’ <code>Execute</code>. For example, <code>Aggregate</code> returns the <code>IOmniParallelAggregatorLoop</code> interface.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">TOmniIteratorIntoDelegate</code> <code class="o">=</code> 
<code class="lineno">2 </code>  <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code> <code class="k">var</code> <code class="bp">result</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">3 </code>
<code class="lineno">4 </code><code class="n">IOmniParallelAggregatorLoop</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno">5 </code>  <code class="k">function</code>  <code class="nf">Execute</code><code class="p">(</code><code class="n">loopBody</code><code class="o">:</code> <code class="n">TOmniIteratorIntoDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno">6 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>These variants of the <code>IOmniParallelLoop</code> interface will be described in following sections.</p>

<h4 id="highlevel-foreach-preserveorder">
<span class="section-number">3.12.5 </span>Preserving output order</h4>

<p>When you run a <em>ForEach</em> loop, you can’t tell in advance in which order elements from the input collection will be processed in. For example, the code below will generate all primes from <code>1</code> to <code>CMaxPrime</code> and write them into the output queue (<code>primeQueue</code>) in a nondeterministic order.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">primeQueue</code> <code class="o">:=</code> <code class="n">TOmniBlockingCollection</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="p">(</code><code class="mi">1</code><code class="o">,</code> <code class="n">CMaxPrime</code><code class="p">)</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">3 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code>
<code class="lineno">4 </code>  <code class="k">begin</code>
<code class="lineno">5 </code>    <code class="k">if</code> <code class="n">IsPrime</code><code class="p">(</code><code class="n">value</code><code class="p">)</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno">6 </code>      <code class="n">primeQueue</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">value</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">7 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">8 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>Sometimes this will represent a big problem and you’ll have to write a sorting function that will re-sort the output before it can be processed further. To ease the problem, <code>IOmniParallelLoop</code> implements the <code>PreserveOrder</code> modifier. When used, <em>ForEach</em> internally sorts the results produced in the worker task method.</p>

<p>Using <code>PreserveOrder</code> also forces you to use the <code>Into</code> method which returns the <code>IOmniParallelIntoLoop</code> interface. (As you may expect, there’s also the <code>&lt;T&gt;</code> version of that interface.)</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">TOmniIteratorIntoDelegate</code> <code class="o">=</code> 
<code class="lineno"> 2 </code>  <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code> <code class="k">var</code> <code class="bp">result</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="n">TOmniIteratorIntoTaskDelegate</code> <code class="o">=</code> 
<code class="lineno"> 4 </code>  <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="o">;</code> <code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code> 
<code class="lineno"> 5 </code>                         <code class="k">var</code> <code class="bp">result</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 6 </code>
<code class="lineno"> 7 </code><code class="n">IOmniParallelIntoLoop</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 8 </code>  <code class="k">procedure</code> <code class="nf">Execute</code><code class="p">(</code><code class="n">loopBody</code><code class="o">:</code> <code class="n">TOmniIteratorIntoDelegate</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="k">procedure</code> <code class="nf">Execute</code><code class="p">(</code><code class="n">loopBody</code><code class="o">:</code> <code class="n">TOmniIteratorIntoTaskDelegate</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>As you can see, the <code>Execute</code> method in <code>IOmniParallelIntoLoop</code> takes a different parameter than the ‘normal’ <code>Execute</code>. Because of that, you’ll have to change a code that is passed to the <code>Execute</code> to return a result.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">primeQueue</code> <code class="o">:=</code> <code class="n">TOmniBlockingCollection</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="p">(</code><code class="mi">1</code><code class="o">,</code> <code class="n">CMaxPrime</code><code class="p">)</code>
<code class="lineno"> 3 </code>  <code class="o">.</code><code class="n">PreserveOrder</code>
<code class="lineno"> 4 </code>  <code class="o">.</code><code class="n">Into</code><code class="p">(</code><code class="n">primeQueue</code><code class="p">)</code>
<code class="lineno"> 5 </code>  <code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno"> 6 </code>    <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="k">var</code> <code class="n">res</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno"> 7 </code>    <code class="k">begin</code>
<code class="lineno"> 8 </code>      <code class="k">if</code> <code class="n">IsPrime</code><code class="p">(</code><code class="n">value</code><code class="p">)</code> <code class="k">then</code>
<code class="lineno"> 9 </code>        <code class="n">res</code> <code class="o">:=</code> <code class="n">value</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>When using <code>PreserveOrder</code> and <code>Into</code>, <code>ForEach</code> calls your worker code for each input value. If the worker code sets output parameter (<code>res</code>) to any value, it will be inserted into a temporary buffer. Then the magic happens (see the <a href="chap15.html#highlevel-foreach-internals">Internals</a> section, below) and as soon as the appropriate (sorted) value is available in the temporary buffer, it is inserted into the output queue (the one passed to the <code>Into</code> parameter).</p>

<p>You can also use <code>Into</code> without the <code>PreserveOrder</code>. This will give you queue management but no ordering.</p>

<h4 id="highlevel-foreach-aggregation">
<span class="section-number">3.12.6 </span>Aggregation</h4>

<p>Aggregation allows you to collect data from <em>ForEach</em> tasks and calculate one number that is returned to the user.</p>

<p>Let’s start with an example - intentionally a terrible one! The following code fragment tries to calculate the number of prime numbers between <code>1</code> and <code>CMaxPrime</code>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">numPrimes</code> <code class="o">:=</code> <code class="mi">0</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="p">(</code><code class="mi">1</code><code class="o">,</code> <code class="n">CMaxPrime</code><code class="p">)</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">3 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code>
<code class="lineno">4 </code>  <code class="k">begin</code>
<code class="lineno">5 </code>    <code class="k">if</code> <code class="n">IsPrime</code><code class="p">(</code><code class="n">value</code><code class="p">)</code> <code class="k">then</code> 
<code class="lineno">6 </code>      <code class="nb">Inc</code><code class="p">(</code><code class="n">numPrimes</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">7 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>Let’s say it out loud - this code is <strong>wrong</strong>! Access to the shared variable is not synchronized between threads and that will make the result indeterminable. One way to solve the problem is to wrap the <code>Inc(numPrimes)</code> with locking and another is to use <code>InterlockedIncrement</code> instead of <code>Inc</code>, but both will slow down the execution a lot.</p>

<p>A solution to this problem is to use the <code>Aggregate</code> function.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">SumPrimes</code><code class="p">(</code><code class="k">var</code> <code class="n">aggregate</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code> <code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="n">aggregate</code> <code class="o">:=</code> <code class="n">aggregate</code><code class="o">.</code><code class="n">AsInt64</code> <code class="o">+</code> <code class="n">value</code><code class="o">.</code><code class="n">AsInt64</code><code class="o">;</code>
<code class="lineno"> 4 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code><code class="k">procedure</code> <code class="nf">CheckPrime</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="k">var</code> <code class="bp">result</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno"> 7 </code><code class="k">begin</code>
<code class="lineno"> 8 </code>  <code class="k">if</code> <code class="n">IsPrime</code><code class="p">(</code><code class="n">value</code><code class="p">)</code> <code class="k">then</code>
<code class="lineno"> 9 </code>    <code class="bp">Result</code> <code class="o">:=</code> <code class="mi">1</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">end</code><code class="o">;</code>  
<code class="lineno">11 </code>
<code class="lineno">12 </code><code class="n">numPrimes</code> <code class="o">:=</code>
<code class="lineno">13 </code>  <code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="p">(</code><code class="mi">1</code><code class="o">,</code> <code class="n">CMaxPrime</code><code class="p">)</code>
<code class="lineno">14 </code>  <code class="o">.</code><code class="n">Aggregate</code><code class="p">(</code><code class="mi">0</code><code class="o">,</code> <code class="n">SumPrimes</code><code class="p">)</code>
<code class="lineno">15 </code>  <code class="o">.</code><code class="n">Execute</code><code class="p">(</code><code class="n">CheckPrime</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>Aggregate</code> takes two parameters - the first is the initial value for the aggregate and the second is an aggregation function - a piece of code that will take the current aggregate value and update it with the value returned from the worker task.</p>

<p>When using <code>Aggregate</code>, worker task (the code passed to the <code>Execute</code> function) has the same signature as when used with <code>Into</code>. It takes the current iteration value and optionally produces a result.</p>

<p>We could approximate the code above with the following <code>for</code> loop which works the same, but uses only one thread. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">agg</code> <code class="o">:=</code> <code class="mi">0</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="bp">result</code><code class="o">.</code><code class="n">Clear</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="k">for</code> <code class="n">value</code> <code class="o">:=</code> <code class="mi">1</code> <code class="k">to</code> <code class="n">CMaxPrime</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno"> 4 </code>  <code class="n">CheckPrime</code><code class="p">(</code><code class="n">value</code><code class="o">,</code> <code class="bp">result</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="k">if</code> <code class="k">not</code> <code class="bp">result</code><code class="o">.</code><code class="n">IsEmpty</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno"> 6 </code>    <code class="n">SumPrimes</code><code class="p">(</code><code class="n">agg</code><code class="o">,</code> <code class="bp">result</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="bp">result</code><code class="o">.</code><code class="n">Clear</code><code class="o">;</code>  
<code class="lineno"> 8 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno"> 9 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">10 </code><code class="n">numPrimes</code> <code class="o">:=</code> <code class="n">agg</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>ForEach</code> executes the aggregation in two stages. While the worker task is running, it will aggregate data into a local variable. When it runs out of work, it will call the same aggregation method to aggregate this local variable into a global result. In this second stage, however, locking will be used to protect the access to the global result.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 468px;">
    <img src="images/highlevel----aggregation.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<p>Because the summation is the most common usage of aggregation, <code>IOmniParallelLoop</code> implements function <code>AggregateSum</code>, which works exactly the same as the <code>SumPrimes</code> above.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">numPrimes</code> <code class="o">:=</code>
<code class="lineno"> 2 </code>  <code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="p">(</code><code class="mi">1</code><code class="o">,</code> <code class="n">CMaxPrime</code><code class="p">)</code>
<code class="lineno"> 3 </code>  <code class="o">.</code><code class="n">AggregateSum</code>
<code class="lineno"> 4 </code>  <code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno"> 5 </code>    <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="k">var</code> <code class="bp">result</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno"> 6 </code>    <code class="k">begin</code>
<code class="lineno"> 7 </code>      <code class="k">if</code> <code class="n">IsPrime</code><code class="p">(</code><code class="n">value</code><code class="p">)</code> <code class="k">then</code>
<code class="lineno"> 8 </code>        <code class="bp">Result</code> <code class="o">:=</code> <code class="mi">1</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">end</code>
<code class="lineno">10 </code>  <code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>Aggregation function can do something else but the summation. The following code segment uses aggregation to find the length of the longest line in a file.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">function</code> <code class="nf">GetLongestLineInFile</code><code class="p">(</code><code class="k">const</code> <code class="n">fileName</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">maxLength</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">sl</code>       <code class="o">:</code> <code class="n">TStringList</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="n">sl</code> <code class="o">:=</code> <code class="n">TStringList</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="k">try</code>
<code class="lineno"> 8 </code>    <code class="n">sl</code><code class="o">.</code><code class="n">LoadFromFile</code><code class="p">(</code><code class="n">fileName</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="n">maxLength</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="o">&lt;</code><code class="k">string</code><code class="o">&gt;</code><code class="p">(</code><code class="n">sl</code><code class="p">)</code>
<code class="lineno">10 </code>      <code class="o">.</code><code class="n">Aggregate</code><code class="p">(</code><code class="mi">0</code><code class="o">,</code>
<code class="lineno">11 </code>        <code class="k">procedure</code><code class="p">(</code><code class="k">var</code> <code class="n">aggregate</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code> <code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno">12 </code>        <code class="k">begin</code>
<code class="lineno">13 </code>          <code class="k">if</code> <code class="n">value</code><code class="o">.</code><code class="n">AsInteger</code> <code class="o">&gt;</code> <code class="n">aggregate</code><code class="o">.</code><code class="n">AsInteger</code> <code class="k">then</code>
<code class="lineno">14 </code>            <code class="n">aggregate</code> <code class="o">:=</code> <code class="n">value</code><code class="o">.</code><code class="n">AsInteger</code><code class="o">;</code>
<code class="lineno">15 </code>        <code class="k">end</code><code class="p">)</code>
<code class="lineno">16 </code>      <code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">17 </code>        <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code> <code class="k">var</code> <code class="bp">result</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno">18 </code>        <code class="k">begin</code>
<code class="lineno">19 </code>          <code class="bp">result</code> <code class="o">:=</code> <code class="nb">Length</code><code class="p">(</code><code class="n">value</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">20 </code>        <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">21 </code>	  <code class="bp">Result</code> <code class="o">:=</code> <code class="n">maxLength</code><code class="o">;</code>
<code class="lineno">22 </code>  <code class="k">finally</code> <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">sl</code><code class="p">)</code><code class="o">;</code> <code class="k">end</code><code class="o">;</code>
<code class="lineno">23 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="highlevel-foreach-cancellation">
<span class="section-number">3.12.7 </span>Cancellation</h4>

<p><em>ForEach</em> has a built-in cancellation mechanism. To use it, create a <a href="chap07.html#lowlevel-simpletasks-cancellationtoken">cancellation token</a> and pass it to the <code>CancelWith</code> function. When a cancellation token gets signalled, all worker loops will complete the current iteration and then stop.</p>

<p>An example of using cancellation token can be found in the chapter <a href="chap10.html#howto-parallelSearch">Parallel search in a tree</a>.</p>

<h4 id="highlevel-foreach-taskinit">
<span class="section-number">3.12.8 </span>Task initialization and finalization</h4>

<p><em>ForEach</em> implements a mechanism that can be used by worker tasks to initialize and destroy task-specific structures. In such cases, you have to call the <code>Initialize</code> function.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">TOmniTaskInitializerDelegate</code> <code class="o">=</code> 
<code class="lineno"> 2 </code>  <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">var</code> <code class="n">taskState</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="n">TOmniTaskFinalizerDelegate</code> <code class="o">=</code> 
<code class="lineno"> 4 </code>  <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">taskState</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="n">TOmniIteratorStateDelegate</code> <code class="o">=</code> 
<code class="lineno"> 6 </code>  <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code> <code class="k">var</code> <code class="n">taskState</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>
<code class="lineno"> 8 </code><code class="n">IOmniParallelInitializedLoop</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 9 </code>  <code class="k">function</code>  <code class="nf">Finalize</code><code class="p">(</code><code class="n">taskFinalizer</code><code class="o">:</code> <code class="n">TOmniTaskFinalizerDelegate</code><code class="p">)</code><code class="o">:</code>
<code class="lineno">10 </code>    <code class="n">IOmniParallelInitializedLoop</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="k">procedure</code> <code class="nf">Execute</code><code class="p">(</code><code class="n">loopBody</code><code class="o">:</code> <code class="n">TOmniIteratorStateDelegate</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">13 </code>
<code class="lineno">14 </code><code class="n">IOmniParallelLoop</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno">15 </code>  <code class="o">...</code>
<code class="lineno">16 </code>  <code class="k">function</code>  <code class="nf">Initialize</code><code class="p">(</code><code class="n">taskInitializer</code><code class="o">:</code> <code class="n">TOmniTaskInitializerDelegate</code><code class="p">)</code><code class="o">:</code>
<code class="lineno">17 </code>    <code class="n">IOmniParallelInitializedLoop</code><code class="o">;</code>
<code class="lineno">18 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>You provide <code>Initialize</code> with <em>task initializer</em>, a procedure that will be called in each worker task when it is created and before it starts enumerating values. This procedure can initialize the <code>taskState</code> parameter with any value.</p>

<p><code>Initialize</code> returns an <code>IOmniParallelInitializedLoop</code> interface which implements two functions - <code>Finalize</code> and <code>Execute</code>. Call <code>Finalize</code> to set up <em>task finalizer</em>, a procedure that gets called after all values have been enumerated and before the worker task ends its job.</p>

<p><code>Execute</code> accepts a worker method with two parameters - the first one is the usual value from the enumerated container and the second contains the shared task state.</p>

<p>All these functions and interfaces are implemented in the <code>&lt;T&gt;</code> version, too.</p>

<p>The following example shows how to calculate the number of primes from <code>1</code> to <code>CHighPrime</code> by using initializers and finalizers.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">var</code>
<code class="lineno"> 2 </code>  <code class="n">lockNum</code>  <code class="o">:</code> <code class="n">TOmniCS</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">numPrimes</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 4 </code><code class="k">begin</code>
<code class="lineno"> 5 </code>  <code class="n">numPrimes</code> <code class="o">:=</code> <code class="mi">0</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="p">(</code><code class="mi">1</code><code class="o">,</code> <code class="n">CHighPrime</code><code class="p">)</code>
<code class="lineno"> 7 </code>    <code class="o">.</code><code class="n">Initialize</code><code class="p">(</code>
<code class="lineno"> 8 </code>      <code class="k">procedure</code> <code class="p">(</code><code class="k">var</code> <code class="n">taskState</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno"> 9 </code>      <code class="k">begin</code>
<code class="lineno">10 </code>        <code class="n">taskState</code><code class="o">.</code><code class="n">AsInteger</code> <code class="o">:=</code> <code class="mi">0</code><code class="o">;</code>
<code class="lineno">11 </code>      <code class="k">end</code><code class="p">)</code>
<code class="lineno">12 </code>    <code class="o">.</code><code class="n">Finalize</code><code class="p">(</code>
<code class="lineno">13 </code>      <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">taskState</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno">14 </code>      <code class="k">begin</code>
<code class="lineno">15 </code>        <code class="n">lockNum</code><code class="o">.</code><code class="n">Acquire</code><code class="o">;</code>
<code class="lineno">16 </code>        <code class="k">try</code>
<code class="lineno">17 </code>          <code class="n">numPrimes</code> <code class="o">:=</code> <code class="n">numPrimes</code> <code class="o">+</code> <code class="n">taskState</code><code class="o">.</code><code class="n">AsInteger</code><code class="o">;</code>
<code class="lineno">18 </code>        <code class="k">finally</code> <code class="n">lockNum</code><code class="o">.</code><code class="n">Release</code><code class="o">;</code> <code class="k">end</code><code class="o">;</code>
<code class="lineno">19 </code>      <code class="k">end</code><code class="p">)</code>
<code class="lineno">20 </code>    <code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">21 </code>      <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="k">var</code> <code class="n">taskState</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno">22 </code>      <code class="k">begin</code>
<code class="lineno">23 </code>        <code class="k">if</code> <code class="n">IsPrime</code><code class="p">(</code><code class="n">value</code><code class="p">)</code> <code class="k">then</code>
<code class="lineno">24 </code>          <code class="n">taskState</code><code class="o">.</code><code class="n">AsInteger</code> <code class="o">:=</code> <code class="n">taskState</code><code class="o">.</code><code class="n">AsInteger</code> <code class="o">+</code> <code class="mi">1</code><code class="o">;</code>
<code class="lineno">25 </code>      <code class="k">end</code>
<code class="lineno">26 </code>    <code class="p">)</code><code class="o">;</code>
<code class="lineno">27 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="highlevel-foreach-exceptions">
<span class="section-number">3.12.9 </span>Handling exceptions</h4>

<p><em>ForEach</em> abstraction does not yet implement any exception handling. You should always wrap task method (code passed to the <code>Execute</code>) in <code>try..except</code> if you expect the code to raise exceptions.</p>

<h4 id="leanpub-auto-examples-5">
<span class="section-number">3.12.10 </span>Examples</h4>

<p>Practical example of <em>ForEach</em> usage can be found in chapters <a href="chap10.html#howto-parallelForSyncOut">Parallel for with synchronized output</a> and <a href="chap10.html#howto-parallelSearch">Parallel search in a tree</a>.</p>


<div class="page-break"></div>
<h3 id="highlevel-forkjoin">
<span class="section-number">3.13 </span>Fork/Join</h3>

<p><em>Fork/Join</em> abstraction creates a framework for solving <a href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm"><em>divide and conquer</em></a> algorithms.</p>

<aside>

<div class="figure-wrapper center">
  <figure class="image" style="width: 340px;">
    <img src="images/highlevel----forkJoin.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


</aside>

<aside>
  <p><em>Parallel.ForkJoin creates a computation pool into which you can submit requests (subtasks). Each subtask can create multiple sub-subtasks which are again submitted into the computation pool.</em></p>

</aside>

<p>
  <em>See also <a href="chap12.html#demos">demos</a> <code>44_Fork-Join Quicksort</code> and <code>45_Fork-Join max</code>.</em>
</p>

<div class="page-break"></div>
<p>A typical fork/join usage pattern is:</p>

<ul>
  <li>Execute multiple subtasks.</li>
  <li>Wait for subtasks to terminate.</li>
  <li>Collect subtask results.</li>
  <li>Use results to compute higher-level result.</li>
</ul>

<p>The trick here is that subtasks may spawn new subtasks and so on ad infinitum (probably a little less, or you’ll run out of stack ;) ). For optimum execution, <em>Fork/Join</em> must therefore guarantee that the code is never running on too many background threads (an optimal value is usually equal to the number of cores in the system) and that those threads don’t run out of work.</p>

<p>To achieve this, <em>ForkJoin</em> creates multiple worker threads and connects them to a computation pool. Computation requests (i.e. subtasks) are added to this pool. They are removed by worker threads, processed and optional new subtasks are added back to the pool.</p>

<aside class="tip blurb">
    <p>Programs using <em>ForkJoin</em> typically use lots of stack space so it is advised to increase <em>Maximum Stack Size</em> setting in <em>project options</em>.</p>

</aside>

<h4 id="leanpub-auto-iomniforkjoin-interface">
<span class="section-number">3.13.1 </span>IOmniForkJoin interface</h4>

<p><em>Fork/Join</em> computation pool is implemented by the <code>IOmniForkJoin</code> interface and is created in the <code>Parallel.ForkJoin</code> factory function. There are two <code>ForkJoin</code> overloads – one is used for computations that don’t return a result and another is used for computations that return a result of some type <code>T</code>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">class</code> <code class="k">function</code> <code class="nf">ForkJoin</code><code class="o">:</code> <code class="n">IOmniForkJoin</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">class</code> <code class="k">function</code> <code class="nf">ForkJoin</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;:</code> <code class="n">IOmniForkJoin</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<p>Both interfaces declare just a few methods.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">IOmniForkJoin</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 2 </code>  <code class="k">function</code>  <code class="nf">Compute</code><code class="p">(</code><code class="n">action</code><code class="o">:</code> <code class="n">TOmniForkJoinDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniCompute</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="k">function</code>  <code class="nf">NumTasks</code><code class="p">(</code><code class="n">numTasks</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniForkJoin</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="k">function</code>  <code class="nf">TaskConfig</code><code class="p">(</code><code class="k">const</code> <code class="n">config</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniForkJoin</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">end</code><code class="o">;</code> 
<code class="lineno"> 6 </code>
<code class="lineno"> 7 </code><code class="n">IOmniForkJoin</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 8 </code>  <code class="k">function</code>  <code class="nf">Compute</code><code class="p">(</code><code class="n">action</code><code class="o">:</code> <code class="n">TOmniForkJoinDelegate</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniCompute</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code>
<code class="lineno"> 9 </code>  <code class="k">function</code>  <code class="nf">NumTasks</code><code class="p">(</code><code class="n">numTasks</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniForkJoin</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code>
<code class="lineno">10 </code>  <code class="k">function</code>  <code class="nf">TaskConfig</code><code class="p">(</code><code class="k">const</code> <code class="n">config</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniForkJoin</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;;</code>
<code class="lineno">11 </code><code class="k">end</code><code class="o">;</code> 
</pre></div>

</figure>

<p><code>Compute</code> creates new subtask which will execute the <code>action</code>. It returns control interface <code>IOmniCompute</code> (or <code>IOmniCompute&lt;T&gt;</code>).</p>

<p>By calling <code>NumTasks</code>, you can set the degree of parallelism. By default, fork/join uses as many threads as there are cores available to the process. </p>

<p>If <code>NumTasks</code> receives a positive parameter (<code>&gt; 0</code>), the number of worker tasks is set to that number. For example, <code>NumTasks(16)</code> starts <em>16</em> worker tasks, even if that is more than the number of available cores. </p>

<p>If <code>NumTasks</code> receives a negative parameter (<code>&lt; 0</code>), it specifies the number of cores that should be reserved for other use. The number of worker tasks is then set to <code>&lt;number of available cores&gt; - &lt;number of reserved cores&gt;</code>. If, for example, current process can use <em>16</em> cores and <code>NumTasks(-4)</code> is used, only <em>12</em> (<em>16-4</em>) worker tasks will be started.</p>

<p>Value <em>0</em> is not allowed and results in an exception.</p>

<p><code>TaskConfig</code> method is used to set up a <a href="chap06.html#highlevel-taskconfig">task configuration block</a>, which is applied to each worker task.</p>

<h4 id="leanpub-auto-iomnicompute-interface">
<span class="section-number">3.13.2 </span>IOmniCompute interface</h4>

<p>The <code>IOmniCompute</code> interface provides interaction with the computation unit that doesn’t return a result.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">IOmniCompute</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno">2 </code>  <code class="k">procedure</code> <code class="nf">Execute</code><code class="o">;</code>
<code class="lineno">3 </code>  <code class="k">function</code>  <code class="nf">IsDone</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">4 </code>  <code class="k">procedure</code> <code class="nf">Await</code><code class="o">;</code>
<code class="lineno">5 </code><code class="k">end</code><code class="o">;</code> 
</pre></div>

</figure>

<p><code>Execute</code> executes the action that was provided to the <code>Compute</code> method. This method is used internally and should not be called from the user code.</p>

<p><code>IsDone</code> checks whether the computation unit has completed the work.</p>

<p><code>Await</code> waits for the computation unit to complete the work.</p>

<h4 id="leanpub-auto-iomnicomputet-interface">
<span class="section-number">3.13.3 </span>IOmniCompute&lt;T&gt; interface</h4>

<p>The <code>IOmniCompute&lt;T&gt;</code> interface provides interaction with the computation unit that returns a result.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">IOmniCompute</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno">2 </code>  <code class="k">procedure</code> <code class="nf">Execute</code><code class="o">;</code>
<code class="lineno">3 </code>  <code class="k">function</code>  <code class="nf">IsDone</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">4 </code>  <code class="k">function</code>  <code class="nf">TryValue</code><code class="p">(</code><code class="n">timeout_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> <code class="k">var</code> <code class="n">value</code><code class="o">:</code> <code class="n">T</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">5 </code>  <code class="k">function</code>  <code class="nf">Value</code><code class="o">:</code> <code class="n">T</code><code class="o">;</code>
<code class="lineno">6 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>Execute</code> executes the action that was provided to the <code>Compute</code> method. This method is used internally and should not be called from the user code.</p>

<p><code>IsDone</code> checks whether the computation unit has completed the work.</p>

<p><code>TryValue</code> waits for up to <code>timeout_ms</code> milliseconds (or as long as needed if <code>INFINITE</code> is passed for this parameter) for the computation to complete and returns the result (if available) in the <code>value</code> parameter. The function returns <code>True</code> if result is already known, <code>False</code> otherwise.</p>

<p><code>Value</code> returns the computation unit result. This function will block until the result is available.</p>

<h4 id="leanpub-auto-exceptions">
<span class="section-number">3.13.4 </span>Exceptions</h4>

<p>There’s no special exception handling built into the <em>Fork/Join</em> abstraction at the moment. You should always catch and handle exceptions inside the action passed to the <code>Compute</code> method.</p>

<h4 id="leanpub-auto-examples-6">
<span class="section-number">3.13.5 </span>Examples</h4>

<p>Practical examples of <em>Fork/Join</em> usage can be found in chapter <a href="chap10.html#howto-quickSortParallelMax">QuickSort and parallel max</a>.</p>


<div class="page-break"></div>
<h3 id="highlevel-map">
<span class="section-number">3.14 </span>Map</h3>

<p><em>Map</em> abstraction creates a parallelized mapping function which iterates over a source data array. To create a <em>Map</em> abstraction, call <code>Parallel.Map</code>.</p>

<aside class="information blurb">
    <p><code>Parallel.Map</code> is only available on Delphi XE and newer.</p>

</aside>

<aside>

<div class="figure-wrapper center">
  <figure class="image" style="width: 80%;">
    <img src="images/highlevel----map.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


  <p><em>When you call <code>Parallel.Map</code>, a same background task is started in multiple background threads (indicated by the bold vertical line). In each thread, this task runs some</em> filtering function <em>(provided by the programmer) on some subset of the input array and creates output array containing data returned from the filtering function. At the end, all output arrays from background workers are combined together into the final result.</em></p>

  <p><em>Results are ordered in the same way as corresponding input elements. (In other words – results of <code>Parallel.Map</code> are the same as results of a simple single-threaded <code>for</code> loop executing the same filtering function over the same input data.</em></p>

</aside>

<p>
  <em>See also <a href="chap12.html#demos">demos</a> <code>60_Map</code>.</em>
</p>

<div class="page-break"></div>
<p>Example:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">odds</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">Map</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">,</code><code class="k">string</code><code class="o">&gt;</code><code class="p">(</code><code class="n">numbers</code><code class="o">,</code>
<code class="lineno">2 </code>  <code class="k">function</code> <code class="p">(</code><code class="k">const</code> <code class="n">source</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="k">var</code> <code class="n">dest</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code>
<code class="lineno">3 </code>  <code class="k">begin</code>
<code class="lineno">4 </code>    <code class="bp">Result</code> <code class="o">:=</code> <code class="nb">Odd</code><code class="p">(</code><code class="n">source</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code>    <code class="k">if</code> <code class="bp">Result</code> <code class="k">then</code>
<code class="lineno">6 </code>      <code class="n">dest</code> <code class="o">:=</code> <code class="nb">IntTostr</code><code class="p">(</code><code class="n">source</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">7 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>This simple code fragment takes an array of integers <code>numbers: TArray&lt;integer&gt;</code>, converts all odd values in that array to a string representation and assigns resulting <code>TArray&lt;string&gt;</code> to <code>odds</code>. Worker code runs in parallel on all available cores. The filtering function is coded as an anonymous method but you can also use a <a href="chap06.html#highLevel-intro-AnonymousEtAl">method or a normal procedure</a>.</p>

<p>The <code>Parallel</code> class defines two <code>Map</code> overloads. The first creates an <code>IOmniParallelMapper&lt;T1,T2&gt;</code> interface which you can then further configure before workers are started. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">type</code>
<code class="lineno">2 </code>  <code class="n">TMapProc</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">function</code><code class="p">(</code><code class="k">const</code> <code class="n">source</code><code class="o">:</code> <code class="n">T1</code><code class="o">;</code> <code class="k">var</code> <code class="n">target</code><code class="o">:</code> <code class="n">T2</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">3 </code>	
<code class="lineno">4 </code>  <code class="n">Parallel</code> <code class="o">=</code> <code class="k">class</code>
<code class="lineno">5 </code>    <code class="k">class</code> <code class="k">function</code> <code class="nf">Map</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;:</code> <code class="n">IOmniParallelMapper</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">6 </code>    <code class="k">class</code> <code class="k">function</code> <code class="nf">Map</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">source</code><code class="o">:</code> <code class="n">TArray</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">&gt;;</code>
<code class="lineno">7 </code>      <code class="n">mapper</code><code class="o">:</code> <code class="n">TMapProc</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> <code class="n">TArray</code><code class="o">&lt;</code><code class="n">T2</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">8 </code>    <code class="o">...</code>
<code class="lineno">9 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The second overload is just a shorthand which runs mapping function on all cores and waits for the result. It is defined in the <em>OtlParallel</em> as follows.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">class</code> <code class="k">function</code> <code class="nc">Parallel</code><code class="o">.</code><code class="nf">Map</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code> <code class="n">T2</code><code class="o">&gt;</code><code class="p">(</code><code class="k">const</code> <code class="n">source</code><code class="o">:</code> <code class="n">TArray</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">&gt;;</code> <code class="n">mapper</code><code class="o">:</code> <code class="n">TMapProc</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code>
<code class="lineno"> 2 </code>  <code class="n">TArray</code><code class="o">&lt;</code><code class="n">T2</code><code class="o">&gt;;</code>
<code class="lineno"> 3 </code><code class="k">var</code>
<code class="lineno"> 4 </code>  <code class="n">map</code><code class="o">:</code> <code class="n">IOmniParallelMapper</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="n">map</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">Map</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;.</code><code class="n">Source</code><code class="p">(</code><code class="n">source</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="n">map</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code><code class="n">mapper</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="n">map</code><code class="o">.</code><code class="n">WaitFor</code><code class="p">(</code><code class="n">INFINITE</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="bp">Result</code> <code class="o">:=</code> <code class="n">map</code><code class="o">.</code><code class="bp">Result</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-iomniparallelmappert1t2-interface">
<span class="section-number">3.14.1 </span>IOmniParallelMapper&lt;T1,T2&gt; interface</h4>

<p>The <code>IOmniParallelMapper&lt;T1,T2&gt;</code> interface provides methods that configure and control the parallel mapper.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">IOmniParallelMapper</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 2 </code>  <code class="k">function</code>  <code class="nf">Execute</code><code class="p">(</code><code class="n">mapper</code><code class="o">:</code> <code class="n">TMapProc</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelMapper</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;;</code>
<code class="lineno"> 3 </code>  <code class="k">function</code>  <code class="nf">NoWait</code><code class="o">:</code> <code class="n">IOmniParallelMapper</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;;</code>
<code class="lineno"> 4 </code>  <code class="k">function</code>  <code class="nf">NumTasks</code><code class="p">(</code><code class="n">numTasks</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelMapper</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;;</code>
<code class="lineno"> 5 </code>  <code class="k">function</code>  <code class="nf">OnStop</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelMapper</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="k">function</code>  <code class="nf">OnStop</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TOmniTaskStopDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelMapper</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="k">function</code>  <code class="nf">OnStopInvoke</code><code class="p">(</code><code class="n">stopCode</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelMapper</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;;</code>
<code class="lineno"> 8 </code>  <code class="k">function</code>  <code class="bp">Result</code><code class="o">:</code> <code class="nf">TArray</code><code class="o">&lt;</code><code class="n">T2</code><code class="o">&gt;;</code>
<code class="lineno"> 9 </code>  <code class="k">function</code>  <code class="nf">Source</code><code class="p">(</code><code class="k">const</code> <code class="n">data</code><code class="o">:</code> <code class="n">TArray</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">&gt;;</code> 
<code class="lineno">10 </code>    <code class="n">makeCopy</code><code class="o">:</code> <code class="kt">boolean</code> <code class="o">=</code> <code class="k">false</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelMapper</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;;</code>
<code class="lineno">11 </code>  <code class="k">function</code>  <code class="nf">TaskConfig</code><code class="p">(</code><code class="k">const</code> <code class="n">config</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniParallelMapper</code><code class="o">&lt;</code><code class="n">T1</code><code class="o">,</code><code class="n">T2</code><code class="o">&gt;;</code>
<code class="lineno">12 </code>  <code class="k">function</code>  <code class="nf">WaitFor</code><code class="p">(</code><code class="n">maxWait_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">13 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>Source</code> sets the input data array. If <code>makeCopy</code> parameter is set, data is copied to an internal array. If not (default), original data is referenced from all worker threads.</p>

<p><code>TaskConfig</code> sets up a <a href="chap06.html#highlevel-taskconfig">task configuration block</a>. Same task configuration block will be applied to all worker tasks. </p>

<p>By calling <code>NumTasks</code> you can set up the number of worker tasks. By default, the number of tasks is set to <em>[number of cores available to the process] - 1</em> if <code>NoWait</code> modifier is used and to <em>[number of cores available to the process]</em> if <code>NoWait</code> is not used. </p>

<p>If <code>NumTasks</code> receives a positive parameter (<code>&gt; 0</code>), the number of worker tasks is set to that number. For example, <code>NumTasks(16)</code> starts <em>16</em> worker tasks, even if that is more than the number of available cores. </p>

<p>If <code>NumTasks</code> receives a negative parameter (<code>&lt; 0</code>), it specifies the number of cores that should be reserved for other use. The number of worker tasks is then set to <code>&lt;number of available cores&gt; - &lt;number of reserved cores&gt;</code>. If, for example, current process can use <em>16</em> cores and <code>NumTasks(-4)</code> is used, only <em>12</em> (<em>16-4</em>) worker tasks will be started.</p>

<p>Value <em>0</em> is not allowed and results in an exception.</p>

<p><code>Execute</code> starts the worker tasks. As a parameter it takes a mapping function which is executed in worker tasks. The same mapping function is executed from multiple tasks and must therefore be thread-safe.</p>

<p>If you call the <code>NoWait</code> function, <em>Map</em> starts in the background and control is returned to the main thread immediately. If <code>NoWait</code> is not called, <code>Execute</code>  only returns after all tasks have stopped working.</p>

<p><code>OnStop</code> sets up a termination handler which will be called after all parallel tasks will have completed their work. If <code>NoWait</code> function was called, <code>OnStop</code> will be called from one of the worker threads. If, however, <code>NoWait</code> function was not called, <code>OnStop</code> will be called from the thread that created the <code>Map</code> abstraction. </p>

<p id="highlevel-map-onstopinvoke">Release <sup>[3.07.2]</sup> introduced method <code>OnStopInvoke</code> which works like <code>OnStop</code> except that the termination handler is automatically executed in the context of the owner thread via implicit <code>Invoke</code>. For example, see <a href="chap06.html#highlevel-foreach-onstopinvoke"><code>Parallel.ForEach.OnStopInvoke</code></a>.</p>

<p>A call to the <code>WaitFor</code> function will wait for up to <code>timeout_ms</code> milliseconds (this value can be set to <code>INFINITE</code>) for all background tasks to terminate. If the tasks terminate in the specified time, <code>WaitFor</code> returns <code>True</code>. Otherwise, it returns <code>False</code>.</p>

<p>The <code>Result</code> function returns the resulting array. This function should only be called after all worker threads have finished their work (i.e. from <code>OnStop</code>, after successful <code>WaitFor</code>, or after <code>Execute</code> if <code>NoWait</code> is not used).</p>


<div class="page-break"></div>
<h3 id="highlevel-timedtask">
<span class="section-number">3.15 </span>Timed task</h3>

<p><em>Timed task</em> abstraction creates a threaded timer. To create a <em>Timed task</em>, call <code>Parallel.TimedTask</code>.</p>

<aside>

<div class="figure-wrapper center">
  <figure class="image" style="width: 286px;">
    <img src="images/highlevel----timedTask.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


</aside>

<aside>
  <p><em>When you call <code>Parallel.TimedTask</code>, a background task is started in a background thread. At a specified interval it will execute an anonymous method. You can think of it as of a <code>TTimer</code> which executes the <code>OnTimer</code> event in a background thread.</em> </p>

</aside>

<p>
  <em>See also <a href="chap12.html#demos">demos</a> <code>65_TimedTask</code>.</em>
</p>

<div class="page-break"></div>
<p>Example:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FTimedTask</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">TimedTask</code><code class="o">.</code><code class="n">Every</code><code class="p">(</code><code class="mi">5000</code><code class="p">)</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">2 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code>
<code class="lineno">3 </code>  <code class="k">begin</code>
<code class="lineno">4 </code>    <code class="n">task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="n">MSG_WATCHDOG</code><code class="o">,</code> <code class="s">'Still alive ...'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>This code fragment creates a <em>Timed task</em> which every <em>5</em> seconds (<em>5000</em> milliseconds) sends a message <code>MSG_WATCHDOG</code> to its owner.</p>

<h4 id="highlevel-timedtask-iomnitimedtask">
<span class="section-number">3.15.1 </span>IOmniTimedTask interface</h4>

<p>The <code>Parallel.TimedTask</code> function returns an <code>IOmniTimedTask</code> interface which is used to configure and control a <em>Timed task</em>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniTaskDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code>
<code class="lineno"> 4 </code>  <code class="n">IOmniTimedTask</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 5 </code>    <code class="k">function</code>  <code class="nf">Every</code><code class="p">(</code><code class="n">interval_ms</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTimedTask</code><code class="o">;</code>
<code class="lineno"> 6 </code>    <code class="k">function</code>  <code class="nf">Execute</code><code class="p">(</code><code class="k">const</code> <code class="n">aTask</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTimedTask</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">function</code>  <code class="nf">Execute</code><code class="p">(</code><code class="k">const</code> <code class="n">aTask</code><code class="o">:</code> <code class="n">TOmniTaskDelegate</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTimedTask</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 8 </code>    <code class="k">procedure</code> <code class="nf">ExecuteNow</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">procedure</code> <code class="nf">Start</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">procedure</code> <code class="nf">Stop</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">function</code>  <code class="nf">TaskConfig</code><code class="p">(</code><code class="k">const</code> <code class="n">config</code><code class="o">:</code> <code class="n">IOmniTaskConfig</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTimedTask</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">function</code>  <code class="nf">Terminate</code><code class="p">(</code><code class="n">maxWait_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">13 </code>    <code class="k">function</code>  <code class="nf">WaitFor</code><code class="p">(</code><code class="n">maxWait_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">14 </code>    <code class="k">property</code> <code class="py">Active</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">15 </code>    <code class="k">property</code> <code class="py">Interval</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">16 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>Every</code> sets the timer interval (in milliseconds). Interval must be a positive number. If you set it to a value which is less than or equal to zero, the timer will be disabled. (It is, however,  advisable to use <code>Stop</code> or <code>Active := false</code> for this purpose as that more clearly states the intention of the code.)</p>

<p>When a timed task is created, its interval is set to <em>0</em> ms. </p>

<p>You can inspect and modify the interval by using the <code>Interval</code> property. Setting an interval by assigning a value to this property (<code>Interval := value;</code>) is equivalent to calling <code>Every(value)</code>.</p>

<p><code>Execute</code> specifies the code that will be called each <code>Interval</code> milliseconds (<em>timer event handler</em> code). This can be a parameter-less anonymous method (or <a href="chap06.html#highLevel-intro-AnonymousEtAl">normal procedure, or an object method</a>) or procedure/method/anonymous method accepting one parameter of type <code>IOmniTask</code> which holds the interface of the background task executing the timer method.</p>

<p>After you set an interval (even if the current value is equal to the previous value), the background task will wait for <code>Interval</code> milliseconds before calling the timer event handler code.          </p>

<p>If you want to execute timer event handler immediately, call the <code>ExecuteNow</code> method. This will also reset the timer so that next automatic invocation of the timer event handler will occur <code>Interval</code> milliseconds from now.</p>

<p><code>Start</code> will start (enable) the timer. To stop (disable) the timer call the <code>Stop</code> method. Current state of the timer is available via the <code>Active</code> property.</p>

<p>You can also start/stop a timer by changing the <code>Active</code> property. Setting <code>Active := true</code> is equivalent to calling <code>Start</code> and setting <code>Active := false</code> is equivalent to calling <code>Stop</code>.</p>

<p>A timer is automatically started (enabled) when you call <code>Execute</code> – if and only if the <code>Interval</code> has already been set.   </p>

<p>If you want to create a stopped timer with a very small <code>Interval</code> value, it is advisable to use the following pattern:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">timedTask</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">TimedTask</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code><code class="n">SomeCode</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">timedTask</code><code class="o">.</code><code class="n">Stop</code><code class="o">;</code>
<code class="lineno">3 </code><code class="n">timedTask</code><code class="o">.</code><code class="n">Interval</code> <code class="o">:=</code> <code class="mi">1</code><code class="o">;</code>  
</pre></div>

</figure>

<p><code>TaskConfig</code> sets up a <a href="chap06.html#highlevel-taskconfig">task configuration block</a>.  </p>

<p>Calling <code>Terminate</code> will stop the timed task. If it stops in <code>maxWait_ms</code>, <code>True</code> is returned, <code>False</code> otherwise. <code>WaitFor</code> waits for the task to stop (without commanding it to stop beforehand so you would have to call <code>Terminate</code> before <code>WaitFor</code>) and returns <code>True</code>/<code>False</code> just as <code>Terminate</code> does.</p>

<p>It is usually enough to just set the <code>IOmniTimedTask</code> instance to <code>nil</code> as that effectively calls the <code>Terminate(INFINITE)</code>.</p>



</div>
</body>

<!-- Mirrored from www.omnithreadlibrary.com/book/chap06.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 19 Oct 2025 22:28:51 GMT -->
</html>
