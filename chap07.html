<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from www.omnithreadlibrary.com/book/chap07.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 19 Oct 2025 22:28:58 GMT -->
<head>
  <meta charset="utf-8">
  <title>4. Low-level multi-threading</title>
  <link href="stylesheet.css" rel="stylesheet" />
</head>
<body dir="ltr" class="kramdown">
<div id="leanpub-toc">
<h2></h2>
<ol class="toc">
<ul class='toc no-parts'>
  <li>
    <a href='chap00.html#intro-advert'>About me</a>
  </li>
  <li>
    <a href='chap01.html#credits'>Credits</a>
  </li>
  <li>
    <a href='chap02.html#introduction'>Introduction</a>
    <ul>
      <li>
        <a href='chap02.html#leanpub-auto-formatting-conventions'>Formatting conventions</a>
      </li>
      <li>
        <a href='chap02.html#leanpub-auto-learn-more'>Learn more</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap03.html#leanpub-auto-release-notes'>Release notes</a>
  </li>
  <li>
    <a href='chap04.html#intro-mt'><span class="section-number">1. </span>Introduction to multi-threading</a>
    <ul>
      <li>
        <a href='chap04.html#leanpub-auto-multi-threading-as-a-source-of-problems'><span class="section-number">1.1 </span>Multi-threading as a source of problems</a>
        <ul>
          <li>
            <a href='chap04.html#leanpub-auto-reading-and-writing-shared-data'><span class="section-number">1.1.1 </span>Reading and writing shared data</a>
          </li>
          <li>
            <a href='chap04.html#leanpub-auto-modifying-shared-data'><span class="section-number">1.1.2 </span>Modifying shared data</a>
          </li>
          <li>
            <a href='chap04.html#leanpub-auto-writes-masquerading-as-reads'><span class="section-number">1.1.3 </span>Writes masquerading as reads</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap05.html#intro-otl'><span class="section-number">2. </span>Introduction to OmniThreadLibrary</a>
    <ul>
      <li>
        <a href='chap05.html#leanpub-auto-requirements'><span class="section-number">2.1 </span>Requirements</a>
      </li>
      <li>
        <a href='chap05.html#leanpub-auto-license'><span class="section-number">2.2 </span>License</a>
      </li>
      <li>
        <a href='chap05.html#installation'><span class="section-number">2.3 </span>Installation</a>
        <ul>
          <li>
            <a href='chap05.html#appendix-installing-getit'><span class="section-number">2.3.1 </span>Installing with GetIt</a>
          </li>
          <li>
            <a href='chap05.html#appendix-installing-delphinus'><span class="section-number">2.3.2 </span>Installing with Delphinus</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-installing-design-package'><span class="section-number">2.3.3 </span>Installing design package</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap05.html#leanpub-auto-why-use-omnithreadlibrary'><span class="section-number">2.4 </span>Why use OmniThreadLibrary?</a>
      </li>
      <li>
        <a href='chap05.html#introotl-tasksvsthreads'><span class="section-number">2.5 </span>Tasks vs. threads</a>
      </li>
      <li>
        <a href='chap05.html#introotl-lockingvsmessaging'><span class="section-number">2.6 </span>Locking vs. messaging</a>
      </li>
      <li>
        <a href='chap05.html#introotl-messagelooprequired'><span class="section-number">2.7 </span>Message loop required</a>
        <ul>
          <li>
            <a href='chap05.html#introotl-messagelooprequired-console'><span class="section-number">2.7.1 </span>OmniThreadLibrary and console</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-omnithreadlibrary-task-started-from-another-task'><span class="section-number">2.7.2 </span>OmniThreadLibrary task started from another task</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-omnithreadlibrary-task-started-from-a-tthread'><span class="section-number">2.7.3 </span>OmniThreadLibrary task started from a TThread</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap05.html#introotl-tomnivalue'><span class="section-number">2.8 </span>TOmniValue</a>
        <ul>
          <li>
            <a href='chap05.html#leanpub-auto-data-access'><span class="section-number">2.8.1 </span>Data access</a>
          </li>
          <li>
            <a href='chap05.html#introotl-tomnivalue-typetesting'><span class="section-number">2.8.2 </span>Type testing</a>
          </li>
          <li>
            <a href='chap05.html#introotl-tomnivalue-clearing'><span class="section-number">2.8.3 </span>Clearing the content</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-operators'><span class="section-number">2.8.4 </span>Operators</a>
          </li>
          <li>
            <a href='chap05.html#introotl-tomnivalue-generictypes'><span class="section-number">2.8.5 </span>Using with generic types</a>
          </li>
          <li>
            <a href='chap05.html#introotl-tomnivalue-array'><span class="section-number">2.8.6 </span>Array access</a>
          </li>
          <li>
            <a href='chap05.html#introotl-tomnivalue-records'><span class="section-number">2.8.7 </span>Handling records</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-object-ownership'><span class="section-number">2.8.8 </span>Object ownership</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-working-with-tvalue'><span class="section-number">2.8.9 </span>Working with TValue</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-low-level-methods'><span class="section-number">2.8.10 </span>Low-level methods</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap05.html#leanpub-auto-tomnivalueobj'><span class="section-number">2.9 </span>TOmniValueObj</a>
      </li>
      <li>
        <a href='chap05.html#introotl-fluentinterfaces'><span class="section-number">2.10 </span>Fluent interfaces</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap06.html#highlevel'><span class="section-number">3. </span>High-level multi-threading</a>
    <ul>
      <li>
        <a href='chap06.html#highlevel-introduction'><span class="section-number">3.1 </span>Introduction</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-a-life-cycle-of-an-abstraction'><span class="section-number">3.1.1 </span>A life cycle of an abstraction</a>
          </li>
          <li>
            <a href='chap06.html#highLevel-intro-AnonymousEtAl'><span class="section-number">3.1.2 </span>Anonymous methods, procedures, and methods</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-introduction-pooling'><span class="section-number">3.1.3 </span>Pooling</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-blocking-collection'><span class="section-number">3.2 </span>Blocking collection</a>
        <ul>
          <li>
            <a href='chap06.html#highlevel-blocking-collection-iomniblockingcollection'><span class="section-number">3.2.1 </span>IOmniBlockingCollection</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-blocking-collection-bulk-impexp'><span class="section-number">3.2.2 </span>Bulk import and export</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-blocking-collection-throttling'><span class="section-number">3.2.3 </span>Throttling</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-taskconfig'><span class="section-number">3.3 </span>Task configuration</a>
      </li>
      <li>
        <a href='chap06.html#highlevel-async'><span class="section-number">3.4 </span>Async</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-handling-exceptions'><span class="section-number">3.4.1 </span>Handling exceptions</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-asyncawait'><span class="section-number">3.5 </span>Async/Await</a>
      </li>
      <li>
        <a href='chap06.html#highlevel-future'><span class="section-number">3.6 </span>Future</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-iomnifuturet-interface'><span class="section-number">3.6.1 </span>IOmniFuture&lt;T&gt; interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-completion-detection'><span class="section-number">3.6.2 </span>Completion detection</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-cancellation'><span class="section-number">3.6.3 </span>Cancellation</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-handling-exceptions-1'><span class="section-number">3.6.4 </span>Handling exceptions</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples'><span class="section-number">3.6.5 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-join'><span class="section-number">3.7 </span>Join</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-iomniparalleljoin-interface'><span class="section-number">3.7.1 </span>IOmniParallelJoin interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomnijoinstate-interface'><span class="section-number">3.7.2 </span>IOmniJoinState interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-cancellation-1'><span class="section-number">3.7.3 </span>Cancellation</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-join-exceptions'><span class="section-number">3.7.4 </span>Handling exceptions</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-paralleltask'><span class="section-number">3.8 </span>Parallel task</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-iomniparalleltask-interface'><span class="section-number">3.8.1 </span>IOmniParallelTask interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-example'><span class="section-number">3.8.2 </span>Example</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-handling-exceptions-2'><span class="section-number">3.8.3 </span>Handling exceptions</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-1'><span class="section-number">3.8.4 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-backgroundworker'><span class="section-number">3.9 </span>Background worker</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-basics'><span class="section-number">3.9.1 </span>Basics</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomnibackgroundworker-interface'><span class="section-number">3.9.2 </span>IOmniBackgroundWorker interface</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-backgroundworker-initialization'><span class="section-number">3.9.3 </span>Task initialization</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-work-item-configuration'><span class="section-number">3.9.4 </span>Work item configuration</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-backgroundworker-iomniworkitem'><span class="section-number">3.9.5 </span>Work item interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-2'><span class="section-number">3.9.6 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-pipeline'><span class="section-number">3.10 </span>Pipeline</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-background'><span class="section-number">3.10.1 </span>Background</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-basics-1'><span class="section-number">3.10.2 </span>Basics</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomnipipeline-interface'><span class="section-number">3.10.3 </span>IOmniPipeline interface</a>
            <ul>
              <li>
                <a href='chap06.html#leanpub-auto-example-1'><span class="section-number">3.10.3.1 </span>Example</a>
              </li>
            </ul>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-generators-mutators-and-aggregators'><span class="section-number">3.10.4 </span>Generators, mutators, and aggregators</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-pipeline-throttling'><span class="section-number">3.10.5 </span>Throttling</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-pipeline-parallel'><span class="section-number">3.10.6 </span>Parallel stages</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-pipeline-exceptions'><span class="section-number">3.10.7 </span>Exceptions</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-3'><span class="section-number">3.10.8 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-for'><span class="section-number">3.11 </span>Parallel for</a>
        <ul>
          <li>
            <a href='chap06.html#highlevel-for-iomniparallelsimpleloop'><span class="section-number">3.11.1 </span>IOmniParallelSimpleLoop interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iterating-over-an-array'><span class="section-number">3.11.2 </span>Iterating over an array</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-4'><span class="section-number">3.11.3 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-foreach'><span class="section-number">3.12 </span>ForEach</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-cooperation'><span class="section-number">3.12.1 </span>Cooperation</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iterating-over-'><span class="section-number">3.12.2 </span>Iterating over …</a>
            <ul>
              <li>
                <a href='chap06.html#leanpub-auto-number-ranges'><span class="section-number">3.12.2.1 </span>… Number ranges</a>
              </li>
              <li>
                <a href='chap06.html#leanpub-auto-enumerable-collections'><span class="section-number">3.12.2.2 </span>… Enumerable collections</a>
              </li>
              <li>
                <a href='chap06.html#leanpub-auto-thread-safe-enumerable-collections'><span class="section-number">3.12.2.3 </span>… Thread-safe enumerable collections</a>
              </li>
              <li>
                <a href='chap06.html#leanpub-auto-blocking-collections'><span class="section-number">3.12.2.4 </span>… Blocking collections</a>
              </li>
              <li>
                <a href='chap06.html#leanpub-auto-anything'><span class="section-number">3.12.2.5 </span>… Anything</a>
              </li>
            </ul>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-providing-external-input'><span class="section-number">3.12.3 </span>Providing external input</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomniparallelloop-interface'><span class="section-number">3.12.4 </span>IOmniParallelLoop interface</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-foreach-preserveorder'><span class="section-number">3.12.5 </span>Preserving output order</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-foreach-aggregation'><span class="section-number">3.12.6 </span>Aggregation</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-foreach-cancellation'><span class="section-number">3.12.7 </span>Cancellation</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-foreach-taskinit'><span class="section-number">3.12.8 </span>Task initialization and finalization</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-foreach-exceptions'><span class="section-number">3.12.9 </span>Handling exceptions</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-5'><span class="section-number">3.12.10 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-forkjoin'><span class="section-number">3.13 </span>Fork/Join</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-iomniforkjoin-interface'><span class="section-number">3.13.1 </span>IOmniForkJoin interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomnicompute-interface'><span class="section-number">3.13.2 </span>IOmniCompute interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomnicomputet-interface'><span class="section-number">3.13.3 </span>IOmniCompute&lt;T&gt; interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-exceptions'><span class="section-number">3.13.4 </span>Exceptions</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-6'><span class="section-number">3.13.5 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-map'><span class="section-number">3.14 </span>Map</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-iomniparallelmappert1t2-interface'><span class="section-number">3.14.1 </span>IOmniParallelMapper&lt;T1,T2&gt; interface</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-timedtask'><span class="section-number">3.15 </span>Timed task</a>
        <ul>
          <li>
            <a href='chap06.html#highlevel-timedtask-iomnitimedtask'><span class="section-number">3.15.1 </span>IOmniTimedTask interface</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap07.html#lowlevel'><span class="section-number">4. </span>Low-level multi-threading</a>
    <ul>
      <li>
        <a href='chap07.html#leanpub-auto-low-level-for-the-impatient'><span class="section-number">4.1 </span>Low-level for the impatient</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-fourways'><span class="section-number">4.2 </span>Four ways to create a task</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-iomnitaskcontrol'><span class="section-number">4.3 </span>IOmniTaskControl and IOmniTask interfaces</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-taskControllerOwner'><span class="section-number">4.4 </span>Task controller needs an owner</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-communication'><span class="section-number">4.5 </span>Communication subsystem</a>
      </li>
      <li>
        <a href='chap07.html#leanpub-auto-processor-groups-and-numa-nodes'><span class="section-number">4.6 </span>Processor groups and NUMA nodes</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-threadpool'><span class="section-number">4.7 </span>Thread pooling</a>
        <ul>
          <li>
            <a href='chap07.html#leanpub-auto-execution-flow'><span class="section-number">4.7.1 </span>Execution flow</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-threadpool-interface'><span class="section-number">4.7.2 </span>IOmniThreadPool interface</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-threadpool-exitcode'><span class="section-number">4.7.3 </span>Task exit code</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-threadpool-monitoring'><span class="section-number">4.7.4 </span>Monitoring thread pool operations</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-processor-groups-and-numa-nodes-1'><span class="section-number">4.7.5 </span>Processor groups and NUMA nodes</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap07.html#lowlevel-lockfree'><span class="section-number">4.8 </span>Lock-free collections</a>
        <ul>
          <li>
            <a href='chap07.html#lowlevel-lockfree-boundedstack'><span class="section-number">4.8.1 </span>Bounded Stack</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-lockfree-boundedqueue'><span class="section-number">4.8.2 </span>Bounded queue</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-lockfree-messagequeue'><span class="section-number">4.8.3 </span>Message queue</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-lockfree-dynamicqueue'><span class="section-number">4.8.4 </span>Dynamic queue</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-lockfree-observing'><span class="section-number">4.8.5 </span>Observing lock-free collections</a>
            <ul>
              <li>
                <a href='chap07.html#leanpub-auto-examples-7'><span class="section-number">4.8.5.1 </span>Examples</a>
              </li>
            </ul>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-benchmarks'><span class="section-number">4.8.6 </span>Benchmarks</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap07.html#lowlevel-eventmonitor'><span class="section-number">4.9 </span>Event monitor</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-simpletasks'><span class="section-number">4.10 </span>Simple tasks</a>
        <ul>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-name'><span class="section-number">4.10.1 </span>Name</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-uniqueid'><span class="section-number">4.10.2 </span>UniqueID</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-parameters'><span class="section-number">4.10.3 </span>Parameters</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-termination'><span class="section-number">4.10.4 </span>Termination</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-exitcode'><span class="section-number">4.10.5 </span>ExitCode</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-taskexceptions'><span class="section-number">4.10.6 </span>Exceptions</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-communication'><span class="section-number">4.10.7 </span>Sending messages to a task</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-receiving'><span class="section-number">4.10.8 </span>Receiving messages from a task</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-chainto'><span class="section-number">4.10.9 </span>ChainTo</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-joinleave'><span class="section-number">4.10.10 </span>Join / Leave</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-monitorwith'><span class="section-number">4.10.11 </span>MonitorWith / RemoveMonitor</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-enforced'><span class="section-number">4.10.12 </span>Enforced</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-unobserved'><span class="section-number">4.10.13 </span>Unobserved</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-cancellationtoken'><span class="section-number">4.10.14 </span>Cancellation token / CancelWith</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-tasklock'><span class="section-number">4.10.15 </span>Lock / WithLock</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-counter'><span class="section-number">4.10.16 </span>WithCounter</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-setpriority'><span class="section-number">4.10.17 </span>SetPriority</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-setqueuesize'><span class="section-number">4.10.18 </span>SetQueueSize</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap07.html#lowlevel-tomniworker'><span class="section-number">4.11 </span>TOmniWorker tasks</a>
        <ul>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-waitforinit'><span class="section-number">4.11.1 </span>WaitForInit</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-task'><span class="section-number">4.11.2 </span>Task</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-communication'><span class="section-number">4.11.3 </span>Receiving messages</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-registercomm'><span class="section-number">4.11.4 </span>RegisterComm</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-tomniworkerinvoke'><span class="section-number">4.11.5 </span>Invoke</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-msgwait'><span class="section-number">4.11.6 </span>Windows message &amp; APC processing</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-timers'><span class="section-number">4.11.7 </span>Timers</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-terminateWhen'><span class="section-number">4.11.8 </span>TerminateWhen</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-userdata'><span class="section-number">4.11.9 </span>UserData</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap07.html#lowlevel-taskgroup'><span class="section-number">4.12 </span>Task groups</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-iomnitask'><span class="section-number">4.13 </span>IOmniTask interface</a>
        <ul>
          <li>
            <a href='chap07.html#leanpub-auto-name-and-id'><span class="section-number">4.13.1 </span>Name and ID</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-parameters'><span class="section-number">4.13.2 </span>Parameters</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-termination'><span class="section-number">4.13.3 </span>Termination</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-exitstatus'><span class="section-number">4.13.4 </span>Exit status</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-exceptions-1'><span class="section-number">4.13.5 </span>Exceptions</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-communication'><span class="section-number">4.13.6 </span>Communication</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-timers'><span class="section-number">4.13.7 </span>Timers</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-registerwaitobject'><span class="section-number">4.13.8 </span>RegisterWaitObject</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-cancellationtoken'><span class="section-number">4.13.9 </span>CancellationToken</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-lock'><span class="section-number">4.13.10 </span>Lock</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-counter'><span class="section-number">4.13.11 </span>Counter</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-processor-groups-and-numa-nodes-2'><span class="section-number">4.13.12 </span>Processor groups and NUMA nodes</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-internal-and-obsolete-functions'><span class="section-number">4.13.13 </span>Internal and obsolete functions</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap08.html#synch'><span class="section-number">5. </span>Synchronization</a>
    <ul>
      <li>
        <a href='chap08.html#synch-criticalsections'><span class="section-number">5.1 </span>Critical sections</a>
        <ul>
          <li>
            <a href='chap08.html#synch-criticalsections-iomnicriticalsection'><span class="section-number">5.1.1 </span>IOmniCriticalSection</a>
          </li>
          <li>
            <a href='chap08.html#synch-criticalsections-tomnics'><span class="section-number">5.1.2 </span>TOmniCS</a>
          </li>
          <li>
            <a href='chap08.html#synch-criticalsections-lockedt'><span class="section-number">5.1.3 </span>Locked&lt;T&gt;</a>
            <ul>
              <li>
                <a href='chap08.html#leanpub-auto-why-not-use-tmonitor'><span class="section-number">5.1.3.1 </span>Why not use TMonitor?</a>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap08.html#synch-tomnimrew'><span class="section-number">5.2 </span>TOmniMREW</a>
      </li>
      <li>
        <a href='chap08.html#synch-cancellationtoken'><span class="section-number">5.3 </span>Cancellation token</a>
      </li>
      <li>
        <a href='chap08.html#synch-waitablevalue'><span class="section-number">5.4 </span>Waitable value</a>
      </li>
      <li>
        <a href='chap08.html#synch-inversesemaphore'><span class="section-number">5.5 </span>Inverse semaphore</a>
      </li>
      <li>
        <a href='chap08.html#synch-initialization'><span class="section-number">5.6 </span>Initialization</a>
        <ul>
          <li>
            <a href='chap08.html#synch-initialization-pessimistic'><span class="section-number">5.6.1 </span>Pessimistic initialization</a>
          </li>
          <li>
            <a href='chap08.html#synch-initialization-optimistic'><span class="section-number">5.6.2 </span>Optimistic initialization</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap08.html#synch-twaitfor'><span class="section-number">5.7 </span>TWaitFor</a>
      </li>
      <li>
        <a href='chap08.html#synch-tomnilockmanager'><span class="section-number">5.8 </span>TOmniLockManager&lt;K&gt;</a>
      </li>
      <li>
        <a href='chap08.html#synch-tomnisinglethreadusechecker'><span class="section-number">5.9 </span>TOmniSingleThreadUseChecker</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap09.html#misc'><span class="section-number">6. </span>Miscellaneous</a>
    <ul>
      <li>
        <a href='chap09.html#misc-tOmniTwoWayChannel'><span class="section-number">6.1 </span>TOmniTwoWayChannel</a>
      </li>
      <li>
        <a href='chap09.html#misc-tomnivaluecontainer'><span class="section-number">6.2 </span>TOmniValueContainer</a>
      </li>
      <li>
        <a href='chap09.html#misc-tomnicounter'><span class="section-number">6.3 </span>TOmniCounter</a>
      </li>
      <li>
        <a href='chap09.html#misc-TOmniAlignedInt32'><span class="section-number">6.4 </span>TOmniAlignedInt32 and TOmniAlignedInt64</a>
      </li>
      <li>
        <a href='chap09.html#misc-tomnirecordwrapper'><span class="section-number">6.5 </span>TOmniRecordWrapper</a>
      </li>
      <li>
        <a href='chap09.html#misc-tomnirecord'><span class="section-number">6.6 </span>TOmniRecord</a>
      </li>
      <li>
        <a href='chap09.html#misc-iomniautodestroyobject'><span class="section-number">6.7 </span>IOmniAutoDestroyObject</a>
      </li>
      <li>
        <a href='chap09.html#misc-iomniintegerset'><span class="section-number">6.8 </span>IOmniIntegerSet</a>
      </li>
      <li>
        <a href='chap09.html#misc-environment'><span class="section-number">6.9 </span>Environment</a>
        <ul>
          <li>
            <a href='chap09.html#leanpub-auto-iomniaffinity'><span class="section-number">6.9.1 </span>IOmniAffinity</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap10.html#howto'><span class="section-number">7. </span>How-to</a>
    <ul>
      <li>
        <a href='chap10.html#howto-backgroundFileScanning'><span class="section-number">7.1 </span>Background file scanning</a>
      </li>
      <li>
        <a href='chap10.html#howto-webDownload'><span class="section-number">7.2 </span>Web download and database storage</a>
      </li>
      <li>
        <a href='chap10.html#howto-parallelForSyncOut'><span class="section-number">7.3 </span>Parallel for with synchronized output</a>
      </li>
      <li>
        <a href='chap10.html#howto-parallelForTaskInit'><span class="section-number">7.4 </span>Using taskIndex and task initializer in parallel for</a>
      </li>
      <li>
        <a href='chap10.html#howto-listPartitioning'><span class="section-number">7.5 </span>Background worker and list partitioning</a>
      </li>
      <li>
        <a href='chap10.html#howto-parallelDataProduction'><span class="section-number">7.6 </span>Parallel data production</a>
      </li>
      <li>
        <a href='chap10.html#howto-connectionPool'><span class="section-number">7.7 </span>Building a connection pool</a>
        <ul>
          <li>
            <a href='chap10.html#leanpub-auto-from-theory-to-practice'><span class="section-number">7.7.1 </span>From theory to practice</a>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-running-the-demo'><span class="section-number">7.7.2 </span>Running the demo</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap10.html#howto-quickSortParallelMax'><span class="section-number">7.8 </span>QuickSort and parallel max</a>
        <ul>
          <li>
            <a href='chap10.html#leanpub-auto-quicksort'><span class="section-number">7.8.1 </span>QuickSort</a>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-parallel-max'><span class="section-number">7.8.2 </span>Parallel max</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap10.html#howto-parallelSearch'><span class="section-number">7.9 </span>Parallel search in a tree</a>
      </li>
      <li>
        <a href='chap10.html#howto-multiFrame'><span class="section-number">7.10 </span>Multiple workers with multiple frames</a>
        <ul>
          <li>
            <a href='chap10.html#leanpub-auto-the-worker'><span class="section-number">7.10.1 </span>The worker</a>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-the-frame'><span class="section-number">7.10.2 </span>The frame</a>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-the-form'><span class="section-number">7.10.3 </span>The form</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap10.html#howto-databases'><span class="section-number">7.11 </span>OmniThreadLibrary and databases</a>
        <ul>
          <li>
            <a href='chap10.html#leanpub-auto-database-model'><span class="section-number">7.11.1 </span>Database model</a>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-frame-and-worker'><span class="section-number">7.11.2 </span>Frame and worker</a>
            <ul>
              <li>
                <a href='chap10.html#leanpub-auto-connecting-to-the-database'><span class="section-number">7.11.2.1 </span>Connecting to the database</a>
              </li>
              <li>
                <a href='chap10.html#leanpub-auto-retrieving-the-data'><span class="section-number">7.11.2.2 </span>Retrieving the data</a>
              </li>
            </ul>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-main-program'><span class="section-number">7.11.3 </span>Main program</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap10.html#howto-com'><span class="section-number">7.12 </span>OmniThreadLibrary and COM/OLE</a>
      </li>
      <li>
        <a href='chap10.html#howto-mqtthread'><span class="section-number">7.13 </span>Using a message queue with a TThread worker</a>
        <ul>
          <li>
            <a href='chap10.html#leanpub-auto-sending-data-from-multiple-producers-to-a-single-worker'><span class="section-number">7.13.1 </span>Sending data from multiple producers to a single worker</a>
            <ul>
              <li>
                <a href='chap10.html#leanpub-auto-initialization-and-cleanup'><span class="section-number">7.13.1.1 </span>Initialization and cleanup</a>
              </li>
              <li>
                <a href='chap10.html#leanpub-auto-sending-data-to-the-worker'><span class="section-number">7.13.1.2 </span>Sending data to the worker</a>
              </li>
              <li>
                <a href='chap10.html#leanpub-auto-receiving-the-data'><span class="section-number">7.13.1.3 </span>Receiving the data</a>
              </li>
            </ul>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-sending-data-from-a-worker-to-a-form'><span class="section-number">7.13.2 </span>Sending data from a worker to a form</a>
            <ul>
              <li>
                <a href='chap10.html#leanpub-auto-initialization-and-cleanup-1'><span class="section-number">7.13.2.1 </span>Initialization and cleanup</a>
              </li>
              <li>
                <a href='chap10.html#leanpub-auto-sending-data-to-the-form'><span class="section-number">7.13.2.2 </span>Sending data to the form</a>
              </li>
              <li>
                <a href='chap10.html#leanpub-auto-receiving-the-data-1'><span class="section-number">7.13.2.3 </span>Receiving the data</a>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap11.html#appendix-units'>A. Units</a>
  </li>
  <li>
    <a href='chap12.html#demos'>B. Demo applications</a>
  </li>
  <li>
    <a href='chap13.html#examples'>C. Examples</a>
  </li>
  <li>
    <a href='chap14.html#appendix-hooking'>D. Hooking into OmniThreadLibrary</a>
    <ul>
      <li>
        <a href='chap14.html#leanpub-auto-exception-notifications'>Exception notifications</a>
      </li>
      <li>
        <a href='chap14.html#leanpub-auto-thread-notifications'>Thread notifications</a>
      </li>
      <li>
        <a href='chap14.html#leanpub-auto-pool-notifications'>Pool notifications</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap15.html#highlevel-foreach-internals'>E. ForEach internals</a>
    <ul>
      <li>
        <a href='chap15.html#leanpub-auto-source-provider'>Source provider</a>
      </li>
      <li>
        <a href='chap15.html#leanpub-auto-data-manager'>Data manager</a>
      </li>
      <li>
        <a href='chap15.html#leanpub-auto-local-queue'>Local queue</a>
      </li>
      <li>
        <a href='chap15.html#leanpub-auto-output-ordering'>Output ordering</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap16.html#leanpub-auto-f-hyperlinks'>F. Hyperlinks</a>
  </li>
  <li>
    <a href='chap17.html#leanpub-endnotes'>Notes</a>
  </li>
</ul>

</ol>
</div>
<div id="leanpub-main" class="kramdown">
<h2 id="lowlevel">
<span class="section-number">4. </span>Low-level multi-threading</h2>

<p>The low-level OmniThreadLibrary layer focuses on the <a href="chap05.html#introotl-tasksvsthreads"><code>task</code></a> concept. In most aspects this is similar to the Delphi’s <code>TThread</code> approach except that OmniThreadLibrary focuses on the code (a.k.a. task) and interaction with the code, while the Delphi focuses on the operating system primitive required for executing additional threads. </p>

<p>A task is created using the <code>CreateTask</code> function, which takes as a parameter a global procedure, a method, an instance of the <code>TOmniWorker</code> class (or, usually, a descendant of that class) or an anonymous procedure (in Delphi 2009 and newer). <code>CreateTask</code> will also accept an optional second parameter, a task name, which will be displayed in the Delphi’s Thread view on the thread running the task.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniTaskProcedure</code> <code class="o">=</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">TOmniTaskMethod</code> <code class="o">=</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">TOmniTaskDelegate</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code><code class="k">function</code> <code class="nf">CreateTask</code><code class="p">(</code><code class="n">worker</code><code class="o">:</code> <code class="n">TOmniTaskProcedure</code><code class="o">;</code> <code class="k">const</code> <code class="n">taskName</code><code class="o">:</code> <code class="k">string</code> <code class="o">=</code> <code class="s">''</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 7 </code>  <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 8 </code><code class="k">function</code> <code class="nf">CreateTask</code><code class="p">(</code><code class="n">worker</code><code class="o">:</code> <code class="n">TOmniTaskMethod</code><code class="o">;</code> <code class="k">const</code> <code class="n">taskName</code><code class="o">:</code> <code class="k">string</code> <code class="o">=</code> <code class="s">''</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 9 </code>  <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">function</code> <code class="nf">CreateTask</code><code class="p">(</code><code class="n">worker</code><code class="o">:</code> <code class="n">TOmniTaskDelegate</code><code class="o">;</code> <code class="k">const</code> <code class="n">taskName</code><code class="o">:</code> <code class="k">string</code> <code class="o">=</code> <code class="s">''</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">11 </code>  <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">12 </code><code class="k">function</code> <code class="nf">CreateTask</code><code class="p">(</code><code class="k">const</code> <code class="n">worker</code><code class="o">:</code> <code class="n">IOmniWorker</code><code class="o">;</code> <code class="k">const</code> <code class="n">taskName</code><code class="o">:</code> <code class="k">string</code> <code class="o">=</code> <code class="s">''</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">13 </code>  <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>CreateTask</code> returns a feature-full interface <code>IOmniTaskControl</code> which we will explore in this chapter. The most important function in this interface, <code>Run</code>, creates a new thread and starts your task in it.</p>

<h3 id="leanpub-auto-low-level-for-the-impatient">
<span class="section-number">4.1 </span>Low-level for the impatient</h3>

<p>The following code represents the simplest low-level OmniThreadLibrary example. It executes the <code>Beep</code> function in a background thread. The <code>Beep</code> function merely beeps and exits. By exiting from the task function, the Windows thread running the task is also terminated.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmTestSimple</code><code class="o">.</code><code class="nf">Beep</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="c1">//Executed in a background thread</code>
<code class="lineno">4 </code>  <code class="n">MessageBeep</code><code class="p">(</code><code class="n">MB_ICONEXCLAMATION</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">6 </code>
<code class="lineno">7 </code><code class="n">CreateTask</code><code class="p">(</code><code class="nb">Beep</code><code class="o">,</code> <code class="s">'Beep'</code><code class="p">)</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
</pre></div>

</figure>

<p>Another way to start a task is to call a <code>Schedule</code> function which starts it in a thread allocated from a thread pool. This is covered in the <a href="chap07.html#lowlevel-threadpool">Thread pooling</a> chapter.</p>

<h3 id="lowlevel-fourways">
<span class="section-number">4.2 </span>Four ways to create a task</h3>

<p>Let’s examine all four ways of creating a task. The simplest way (<a href="chap12.html#demos">demoed</a> in application <code>2_TwoWayHello</code>) is to pass a name of a global procedure to the <code>CreateTask</code>. This global procedure must accept one parameter of type <code>IOmniTask </code>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">RunHelloWorld</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="c1">//</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">5 </code>
<code class="lineno">6 </code><code class="n">CreateTask</code><code class="p">(</code><code class="n">RunHelloWorld</code><code class="o">,</code> <code class="s">'HelloWorld'</code><code class="p">)</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
</pre></div>

</figure>

<p>A variation on the theme is passing a name of a method to the <code>CreateTask</code>. This approach is used in the <a href="chap12.html#demos">demo</a> application <code>1_HelloWorld</code>. The interesting point here is that you can declare this method in the same class from which the <code>CreateTask</code> is called. That way you can access all class fields and methods from the threaded code. Just keep in mind you’ll be doing this from another thread so make sure you protect shared access with locking!</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmTestHelloWorld</code><code class="o">.</code><code class="nf">RunHelloWorld</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="c1">//</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">5 </code>
<code class="lineno">6 </code><code class="k">procedure</code> <code class="nc">TfrmTestHelloWorld</code><code class="o">.</code><code class="nf">StartTask</code><code class="o">;</code>
<code class="lineno">7 </code><code class="k">begin</code>
<code class="lineno">8 </code>  <code class="n">CreateTask</code><code class="p">(</code><code class="n">RunHelloWorld</code><code class="o">,</code> <code class="s">'HelloWorld'</code><code class="p">)</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
<code class="lineno">9 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>In Delphi 2009 and newer you can also write the task code as an anonymous function.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">CreateTask</code><code class="p">(</code>
<code class="lineno">2 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code>
<code class="lineno">3 </code>  <code class="k">begin</code>
<code class="lineno">4 </code>    <code class="c1">//</code>
<code class="lineno">5 </code>  <code class="k">end</code><code class="o">,</code>
<code class="lineno">6 </code>  <code class="s">'HellowWorld'</code><code class="p">)</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
</pre></div>

</figure>

<p>For all except the simplest tasks, you’ll use the fourth approach as it will give you access to the true OmniThreadLibrary power (namely internal wait loop and message dispatching). To use it, you have to create a worker object deriving from the <code>TOmniWorker</code> class.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">THelloWorker</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TOmniWorker</code><code class="p">)</code>
<code class="lineno"> 3 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno"> 4 </code>
<code class="lineno"> 5 </code><code class="k">procedure</code> <code class="nc">TfrmTestTwoWayHello</code><code class="o">.</code><code class="nf">actStartHelloExecute</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 6 </code><code class="k">begin</code>
<code class="lineno"> 7 </code>  <code class="n">FHelloTask</code> <code class="o">:=</code>
<code class="lineno"> 8 </code>    <code class="n">CreateTask</code><code class="p">(</code><code class="n">THelloWorker</code><code class="o">.</code><code class="n">Create</code><code class="p">()</code><code class="o">,</code> <code class="s">'Hello'</code><code class="p">)</code><code class="o">.</code>
<code class="lineno"> 9 </code>    <code class="n">Run</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h3 id="lowlevel-iomnitaskcontrol">
<span class="section-number">4.3 </span>IOmniTaskControl and IOmniTask interfaces</h3>

<p>When you create a low-level task, OmniThreadLibrary returns a <em>task controller</em> interface <code>IOmniTaskControl</code>. This interface, which is defined in the <em>OtlTaskControl</em> unit, can be used to control the task from the owner’s side. The task code, on the other hand, has access to another interface, <code>IOmniTask</code> (defined in the <em>OtlTask</em> unit), which can be used to communicate with the owner and manipulate the task itself. A picture in the <a href="chap05.html#introotl-tasksvsthreads">Tasks vs. threads</a> chapter shows the relationship between these interfaces.</p>

<p>This chapter deals mainly with these two interfaces. For the reference reasons, the <code>IOmniTaskControl</code> is reprinted here in full. In the rest of the chapter I’ll just show relevant interface parts.</p>

<p>The <code>IOmniTask</code> interface is described <a href="chap07.html#lowlevel-iomnitask">at the end</a> of this chapter.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">IOmniTaskControl</code> <code class="o">=</code> <code class="k">interface</code> 
<code class="lineno"> 3 </code>    <code class="k">function</code>  <code class="nf">Alertable</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno"> 4 </code>    <code class="k">function</code>  <code class="nf">CancelWith</code><code class="p">(</code><code class="k">const</code> <code class="n">token</code><code class="o">:</code> <code class="n">IOmniCancellationToken</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno"> 5 </code>    <code class="k">function</code>  <code class="nf">ChainTo</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno"> 6 </code>      <code class="n">ignoreErrors</code><code class="o">:</code> <code class="kt">boolean</code> <code class="o">=</code> <code class="k">false</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">function</code>  <code class="nf">ClearTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno"> 8 </code>    <code class="k">function</code>  <code class="nf">DetachException</code><code class="o">:</code> <code class="n">Exception</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">function</code>  <code class="nf">Enforced</code><code class="p">(</code><code class="n">forceExecution</code><code class="o">:</code> <code class="kt">boolean</code> <code class="o">=</code> <code class="k">true</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">function</code>  <code class="nf">GetFatalException</code><code class="o">:</code> <code class="n">Exception</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">function</code>  <code class="nf">GetParam</code><code class="o">:</code> <code class="n">TOmniValueContainer</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">function</code>  <code class="nf">Invoke</code><code class="p">(</code><code class="k">const</code> <code class="n">msgMethod</code><code class="o">:</code> <code class="kt">pointer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">13 </code>    <code class="k">function</code>  <code class="nf">Invoke</code><code class="p">(</code><code class="k">const</code> <code class="n">msgMethod</code><code class="o">:</code> <code class="kt">pointer</code><code class="o">;</code> 
<code class="lineno">14 </code>      <code class="n">msgData</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="k">const</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">15 </code>    <code class="k">function</code>  <code class="nf">Invoke</code><code class="p">(</code><code class="k">const</code> <code class="n">msgMethod</code><code class="o">:</code> <code class="kt">pointer</code><code class="o">;</code> 
<code class="lineno">16 </code>      <code class="n">msgData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">17 </code>    <code class="k">function</code>  <code class="nf">Invoke</code><code class="p">(</code><code class="k">const</code> <code class="n">msgName</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">18 </code>    <code class="k">function</code>  <code class="nf">Invoke</code><code class="p">(</code><code class="k">const</code> <code class="n">msgName</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code> 
<code class="lineno">19 </code>      <code class="n">msgData</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="k">const</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">20 </code>    <code class="k">function</code>  <code class="nf">Invoke</code><code class="p">(</code><code class="k">const</code> <code class="n">msgName</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code> 
<code class="lineno">21 </code>      <code class="n">msgData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">22 </code>    <code class="k">function</code>  <code class="nf">Invoke</code><code class="p">(</code><code class="n">remoteFunc</code><code class="o">:</code> <code class="n">TOmniTaskControlInvokeFunction</code><code class="p">)</code><code class="o">:</code>
<code class="lineno">23 </code>      <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">24 </code>    <code class="k">function</code>  <code class="nf">Invoke</code><code class="p">(</code><code class="n">remoteFunc</code><code class="o">:</code> <code class="n">TOmniTaskControlInvokeFunctionEx</code><code class="p">)</code><code class="o">:</code>
<code class="lineno">25 </code>      <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">26 </code>    <code class="k">function</code>  <code class="nf">Join</code><code class="p">(</code><code class="k">const</code> <code class="n">group</code><code class="o">:</code> <code class="n">IOmniTaskGroup</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">27 </code>    <code class="k">function</code>  <code class="nf">Leave</code><code class="p">(</code><code class="k">const</code> <code class="n">group</code><code class="o">:</code> <code class="n">IOmniTaskGroup</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">28 </code>    <code class="k">function</code>  <code class="nf">MonitorWith</code><code class="p">(</code><code class="k">const</code> <code class="n">monitor</code><code class="o">:</code> <code class="n">IOmniTaskControlMonitor</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">29 </code>      <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">30 </code>    <code class="k">function</code>  <code class="nf">MsgWait</code><code class="p">(</code><code class="n">wakeMask</code><code class="o">:</code> <code class="kt">DWORD</code> <code class="o">=</code> <code class="n">QS_ALLEVENTS</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">31 </code>    <code class="k">function</code>  <code class="nf">NUMANode</code><code class="p">(</code><code class="n">numaNodeNumber</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">32 </code>    <code class="k">function</code>  <code class="nf">OnMessage</code><code class="p">(</code><code class="n">eventDispatcher</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">33 </code>    <code class="k">function</code>  <code class="nf">OnMessage</code><code class="p">(</code><code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniTaskMessageEvent</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">34 </code>    <code class="k">function</code>  <code class="nf">OnMessage</code><code class="p">(</code><code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> <code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniTaskMessageEvent</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">35 </code>      <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">36 </code>    <code class="k">function</code>  <code class="nf">OnMessage</code><code class="p">(</code><code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> <code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniMessageExec</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">37 </code>      <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">38 </code>    <code class="k">function</code>  <code class="nf">OnMessage</code><code class="p">(</code><code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniOnMessageFunction</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">39 </code>      <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">40 </code>    <code class="k">function</code>  <code class="nf">OnMessage</code><code class="p">(</code><code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> <code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniOnMessageFunction</code><code class="p">)</code><code class="o">:</code>
<code class="lineno">41 </code>      <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">42 </code>    <code class="k">function</code>  <code class="nf">OnTerminated</code><code class="p">(</code><code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniOnTerminatedFunction</code><code class="p">)</code><code class="o">:</code>
<code class="lineno">43 </code>      <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">44 </code>    <code class="k">function</code>  <code class="nf">OnTerminated</code><code class="p">(</code><code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniOnTerminatedFunctionSimple</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">45 </code>      <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">46 </code>    <code class="k">function</code>  <code class="nf">OnTerminated</code><code class="p">(</code><code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniTaskTerminatedEvent</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">47 </code>      <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">48 </code>    <code class="k">function</code>  <code class="nf">ProcessorGroup</code><code class="p">(</code><code class="n">procGroupNumber</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">49 </code>    <code class="k">function</code>  <code class="nf">RemoveMonitor</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">50 </code>    <code class="k">function</code>  <code class="nf">Run</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">51 </code>    <code class="k">function</code>  <code class="nf">Schedule</code><code class="p">(</code><code class="k">const</code> <code class="n">threadPool</code><code class="o">:</code> <code class="n">IOmniThreadPool</code> <code class="o">=</code> <code class="k">nil</code> <code class="cm">{default pool}</code><code class="p">)</code><code class="o">:</code>
<code class="lineno">52 </code>      <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">53 </code>    <code class="k">function</code>  <code class="nf">SetMonitor</code><code class="p">(</code><code class="n">hWindow</code><code class="o">:</code> <code class="kt">THandle</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">54 </code>    <code class="k">function</code>  <code class="nf">SetParameter</code><code class="p">(</code><code class="k">const</code> <code class="n">paramName</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code> 
<code class="lineno">55 </code>      <code class="k">const</code> <code class="n">paramValue</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">56 </code>    <code class="k">function</code>  <code class="nf">SetParameter</code><code class="p">(</code><code class="k">const</code> <code class="n">paramValue</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">57 </code>      <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">58 </code>    <code class="k">function</code>  <code class="nf">SetParameters</code><code class="p">(</code><code class="k">const</code> <code class="n">parameters</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code>
<code class="lineno">59 </code>      <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">60 </code>    <code class="k">function</code>  <code class="nf">SetPriority</code><code class="p">(</code><code class="n">threadPriority</code><code class="o">:</code> <code class="n">TOTLThreadPriority</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">61 </code>    <code class="k">function</code>  <code class="nf">SetQueueSize</code><code class="p">(</code><code class="n">numMessages</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">62 </code>    <code class="k">function</code>  <code class="nf">SetTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">interval_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> 
<code class="lineno">63 </code>      <code class="k">const</code> <code class="n">timerMessage</code><code class="o">:</code> <code class="n">TOmniMessageID</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">64 </code>    <code class="k">procedure</code> <code class="nf">SetTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">interval_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> 
<code class="lineno">65 </code>      <code class="k">const</code> <code class="n">timerMessage</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">66 </code>    <code class="k">procedure</code> <code class="nf">SetTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">interval_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> 
<code class="lineno">67 </code>      <code class="k">const</code> <code class="n">timerMessage</code><code class="o">:</code> <code class="n">TProc</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">68 </code>    <code class="k">function</code>  <code class="nf">SetUserData</code><code class="p">(</code><code class="k">const</code> <code class="n">idxData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code> 
<code class="lineno">69 </code>      <code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">70 </code>    <code class="k">procedure</code> <code class="nf">Stop</code><code class="o">;</code>
<code class="lineno">71 </code>    <code class="k">function</code>  <code class="nf">Terminate</code><code class="p">(</code><code class="n">maxWait_ms</code><code class="o">:</code> <code class="kt">cardinal</code> <code class="o">=</code> <code class="n">INFINITE</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> 
<code class="lineno">72 </code>    <code class="k">function</code>  <code class="nf">TerminateWhen</code><code class="p">(</code><code class="n">event</code><code class="o">:</code> <code class="kt">THandle</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">73 </code>    <code class="k">function</code>  <code class="nf">TerminateWhen</code><code class="p">(</code><code class="n">token</code><code class="o">:</code> <code class="n">IOmniCancellationToken</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">74 </code>      <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">75 </code>    <code class="k">function</code>  <code class="nf">Unobserved</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">76 </code>    <code class="k">function</code>  <code class="nf">WaitFor</code><code class="p">(</code><code class="n">maxWait_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">77 </code>    <code class="k">function</code>  <code class="nf">WaitForInit</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">78 </code>    <code class="k">function</code>  <code class="nf">WithCounter</code><code class="p">(</code><code class="k">const</code> <code class="n">counter</code><code class="o">:</code> <code class="n">IOmniCounter</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">79 </code>    <code class="k">function</code>  <code class="nf">WithLock</code><code class="p">(</code><code class="k">const</code> <code class="n">lock</code><code class="o">:</code> <code class="n">TSynchroObject</code><code class="o">;</code> 
<code class="lineno">80 </code>      <code class="n">autoDestroyLock</code><code class="o">:</code> <code class="kt">boolean</code> <code class="o">=</code> <code class="k">true</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">81 </code>    <code class="k">function</code>  <code class="nf">WithLock</code><code class="p">(</code><code class="k">const</code> <code class="n">lock</code><code class="o">:</code> <code class="n">IOmniCriticalSection</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">82 </code>      <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">83 </code>  <code class="c1">//</code>
<code class="lineno">84 </code>    <code class="k">property</code> <code class="py">CancellationToken</code><code class="o">:</code> <code class="n">IOmniCancellationToken</code> 
<code class="lineno">85 </code>      <code class="kp">read</code> <code class="nf">GetCancellationToken</code><code class="o">;</code>
<code class="lineno">86 </code>    <code class="k">property</code> <code class="py">Comm</code><code class="o">:</code> <code class="n">IOmniCommunicationEndpoint</code> <code class="kp">read</code> <code class="nf">GetComm</code><code class="o">;</code>
<code class="lineno">87 </code>    <code class="k">property</code> <code class="py">ExitCode</code><code class="o">:</code> <code class="kt">integer</code> <code class="kp">read</code> <code class="nf">GetExitCode</code><code class="o">;</code>
<code class="lineno">88 </code>    <code class="k">property</code> <code class="py">ExitMessage</code><code class="o">:</code> <code class="k">string</code> <code class="kp">read</code> <code class="nf">GetExitMessage</code><code class="o">;</code>
<code class="lineno">89 </code>    <code class="k">property</code> <code class="py">FatalException</code><code class="o">:</code> <code class="n">Exception</code> <code class="kp">read</code> <code class="nf">GetFatalException</code><code class="o">;</code>
<code class="lineno">90 </code>    <code class="k">property</code> <code class="py">Lock</code><code class="o">:</code> <code class="n">TSynchroObject</code> <code class="kp">read</code> <code class="nf">GetLock</code><code class="o">;</code>
<code class="lineno">91 </code>    <code class="k">property</code> <code class="py">Name</code><code class="o">:</code> <code class="k">string</code> <code class="kp">read</code> <code class="nf">GetName</code><code class="o">;</code>
<code class="lineno">92 </code>    <code class="k">property</code> <code class="py">Param</code><code class="o">:</code> <code class="n">TOmniValueContainer</code> <code class="kp">read</code> <code class="nf">GetParam</code><code class="o">;</code>
<code class="lineno">93 </code>    <code class="k">property</code> <code class="py">UniqueID</code><code class="o">:</code> <code class="kt">int64</code> <code class="kp">read</code> <code class="nf">GetUniqueID</code><code class="o">;</code>
<code class="lineno">94 </code>    <code class="k">property</code> <code class="py">UserData</code><code class="p">[</code><code class="k">const</code> <code class="n">idxData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">]</code><code class="o">:</code> <code class="n">TOmniValue</code> 
<code class="lineno">95 </code>      <code class="kp">read</code> <code class="nf">GetUserDataVal</code> <code class="kp">write</code> <code class="nf">SetUserDataVal</code><code class="o">;</code>
<code class="lineno">96 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h3 id="lowlevel-taskControllerOwner">
<span class="section-number">4.4 </span>Task controller needs an owner</h3>

<p>The <code>IOmniTaskController</code> interface returned from the <code>CreateTask</code> must always be stored in a variable/field with a scope that exceeds the lifetime of the background task. In other words, don’t store a long-term background task interface in a local variable. </p>

<p>The simplest example of the wrong approach can be written in one line: </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">CreateTask</code><code class="p">(</code><code class="n">MyWorker</code><code class="p">)</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
</pre></div>

</figure>

<p>This code looks fine, but it doesn’t work. In this case, the <code>IOmniTaskController</code> interface is stored in a hidden temporary variable which is destroyed at the end of the current method. This then causes the task controller to be destroyed which in turn causes the background task to be destroyed. Running this code would therefore just create and then destroy the task.</p>

<p>A common solution is to just store the interface in some field.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FTaskControl</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">MyWorker</code><code class="p">)</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
</pre></div>

</figure>

<p>When you don’t need background worker anymore, you should terminate the task and free the task controller.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FTaskControl</code><code class="o">.</code><code class="n">Terminate</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">FTaskControl</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
</pre></div>

</figure>

<p>Another solution is to provide the task with an implicit owner. You can, for example, use the <a href="chap07.html#lowlevel-eventmonitor">event monitor</a> to monitor tasks lifetime or messages sent from the task and that will make the task owned by the monitor. The following code is therefore valid: </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">CreateTask</code><code class="p">(</code><code class="n">MyWorker</code><code class="p">)</code><code class="o">.</code><code class="n">MonitorWith</code><code class="p">(</code><code class="n">eventMonitor</code><code class="p">)</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
</pre></div>

</figure>

<p>Yet another possibility is to call the <a href="chap07.html#lowlevel-simpletasks-unobserved"><code>Unobserved</code></a> before the <code>Run</code>. This method makes the task being observed by an internal monitor.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">CreateTask</code><code class="p">(</code><code class="n">MyWorker</code><code class="p">)</code><code class="o">.</code><code class="n">Unobserved</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
</pre></div>

</figure>

<p>When you use a <a href="chap07.html#lowlevel-threadpool">thread pool</a> to run a task, the thread pool acts as a task owner so there’s no need for an additional explicit owner.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">Beep</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="n">MessageBeep</code><code class="p">(</code><code class="n">MB_ICONEXCLAMATION</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">5 </code>
<code class="lineno">6 </code><code class="n">CreateTask</code><code class="p">(</code><code class="nb">Beep</code><code class="o">,</code> <code class="s">'Beep'</code><code class="p">)</code><code class="o">.</code><code class="n">Schedule</code><code class="o">;</code>
</pre></div>

</figure>

<h3 id="lowlevel-communication">
<span class="section-number">4.5 </span>Communication subsystem</h3>

<p>As it is explained in the <a href="chap05.html#introotl-lockingvsmessaging">Locking vs. messaging</a> section, OmniThreadLibrary automatically creates a communication channel between the task controller and the task and exposes it through the <code>Comm</code> property. The communication channel is not exclusive to the OmniThreadLibrary; you could use it equally well from a <code>TThread</code>-based multi-threading code.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">property</code> <code class="py">Comm</code><code class="o">:</code> <code class="n">IOmniCommunicationEndpoint</code> <code class="kp">read</code> <code class="nf">GetComm</code><code class="o">;</code>
</pre></div>

</figure>

<p>The <code>IOmniCommunicationEndpoint</code> interface exposes a simple interface for sending and receiving messages.  </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniMessage</code> <code class="o">=</code> <code class="k">record</code>
<code class="lineno"> 3 </code>    <code class="n">MsgID</code>  <code class="o">:</code> <code class="kt">word</code><code class="o">;</code>
<code class="lineno"> 4 </code>    <code class="n">MsgData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno"> 5 </code>    <code class="k">constructor</code> <code class="nf">Create</code><code class="p">(</code><code class="n">aMsgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> <code class="n">aMsgData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 6 </code>    <code class="k">constructor</code> <code class="nf">Create</code><code class="p">(</code><code class="n">aMsgID</code><code class="o">:</code> <code class="kt">word</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno"> 8 </code>  
<code class="lineno"> 9 </code>  <code class="n">IOmniCommunicationEndpoint</code> <code class="o">=</code> <code class="k">interface</code> 
<code class="lineno">10 </code>    <code class="k">function</code>  <code class="nf">Receive</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">function</code>  <code class="nf">Receive</code><code class="p">(</code><code class="k">var</code> <code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> <code class="k">var</code> <code class="n">msgData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">function</code>  <code class="nf">ReceiveWait</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="o">;</code> <code class="n">timeout_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">13 </code>    <code class="k">function</code>  <code class="nf">ReceiveWait</code><code class="p">(</code><code class="k">var</code> <code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> <code class="k">var</code> <code class="n">msgData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code> 
<code class="lineno">14 </code>      <code class="n">timeout_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">15 </code>    <code class="k">procedure</code> <code class="nf">Send</code><code class="p">(</code><code class="k">const</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">16 </code>    <code class="k">procedure</code> <code class="nf">Send</code><code class="p">(</code><code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">17 </code>    <code class="k">procedure</code> <code class="nf">Send</code><code class="p">(</code><code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> <code class="n">msgData</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="k">const</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">18 </code>    <code class="k">procedure</code> <code class="nf">Send</code><code class="p">(</code><code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> <code class="n">msgData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">19 </code>    <code class="k">function</code>  <code class="nf">SendWait</code><code class="p">(</code><code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> 
<code class="lineno">20 </code>      <code class="n">timeout_ms</code><code class="o">:</code> <code class="kt">cardinal</code> <code class="o">=</code> <code class="n">CMaxSendWaitTime_ms</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">21 </code>    <code class="k">function</code>  <code class="nf">SendWait</code><code class="p">(</code><code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> <code class="n">msgData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code> 
<code class="lineno">22 </code>      <code class="n">timeout_ms</code><code class="o">:</code> <code class="kt">cardinal</code> <code class="o">=</code> <code class="n">CMaxSendWaitTime_ms</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">23 </code>    <code class="k">property</code> <code class="py">NewMessageEvent</code><code class="o">:</code> <code class="kt">THandle</code> <code class="kp">read</code> <code class="nf">GetNewMessageEvent</code><code class="o">;</code>
<code class="lineno">24 </code>    <code class="k">property</code> <code class="py">OtherEndpoint</code><code class="o">:</code> <code class="n">IOmniCommunicationEndpoint</code> <code class="kp">read</code> <code class="nf">GetOtherEndpoint</code><code class="o">;</code>
<code class="lineno">25 </code>    <code class="k">property</code> <code class="py">Reader</code><code class="o">:</code> <code class="n">TOmniMessageQueue</code> <code class="kp">read</code> <code class="nf">GetReader</code><code class="o">;</code>
<code class="lineno">26 </code>    <code class="k">property</code> <code class="py">Writer</code><code class="o">:</code> <code class="n">TOmniMessageQueue</code> <code class="kp">read</code> <code class="nf">GetWriter</code><code class="o">;</code>
<code class="lineno">27 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<ul>
  <li>
<code>Receive</code>
    <p>Both variants of <code>Receive</code> return the first message from the message queue, either as a <code>TOmniMessage</code> record or as a (<em>message ID</em>, <em>message data</em>) pair. Data is always passed as a <a href="chap05.html#introotl-tomnivalue"><code>TOmniValue</code></a> record.</p>

    <p>The function returns <code>True</code> if a message was returned, <code>False</code> if the message queue is empty.</p>
  </li>
  <li>
<code>ReceiveWait</code>
    <p>These two variations of the <code>Receive</code> allow you to specify the maximum timeout (in milliseconds) you are willing to wait for the next message. Timeout of <em>0</em> milliseconds makes the function behave just like the <code>Receive</code>. Special timeout value <code>INFINITE</code> (defined in the <em>Windows</em> unit) will make the function wait until a message is available.</p>

    <p>The function returns <code>True</code> if a message was returned, <code>False</code> if the message queue is still empty after the timeout.</p>
  </li>
  <li>
<code>Send</code>
    <p>Four overloaded versions of <code>Send</code> all write a message to the message queue and raise an exception if the queue is full. [Message queue size defaults to 1000 elements and can be increased by calling the <code>OmniTaskControl.SetQueueSize</code> before the communication channel is used for the first time.]</p>

    <p>The <code>Send(msgID: word)</code> version sends an empty message data (<code>TOmniValue.Null</code>).</p>

    <p>The <code>Send(msgID: word; msgData: array of const)</code> version packs the data array into one <code>TOmniValue</code> value by calling <a href="chap05.html#introotl-tomnivalue-array"><code>TOmniValue.Create(msgData)</code></a>.</p>
  </li>
  <li>
<code>SendWait</code>
    <p>These two variations of the <code>Send</code> method allow you to specify the maximum timeout (in milliseconds) you are willing to wait if a message queue is full and there’s no place for the messages. The timeout of <em>0</em> ms makes the function behave just like the <code>Send</code>. A timeout of <code>INFINITE</code> milliseconds is also supported.</p>

    <p>The function returns <code>True</code> if the message was successfully sent, <code>False</code> if the message queue is still full after the timeout.</p>
  </li>
  <li>
<code>NewMessageEvent</code>
    <p>This property returns Windows <em>event</em> which is signalled every time new data is inserted in the queue. This event is not created until the code accesses the <code>NewMessageEvent</code> property for the first time.</p>
  </li>
  <li>
<code>OtherEndpoint</code>
    <p>Returns the other end of the communication channel (task’s end if accessed through the <code>IOmniTaskControl.Comm</code> and task controller’s end if accessed through the <code>IOmniTask.Comm</code> interface).</p>
  </li>
  <li>
<code>Reader</code>
    <p>Returns the <a href="chap07.html#lowlevel-lockfree-messagequeue">input queue</a> associated with this endpoint.</p>
  </li>
  <li>
<code>Writer</code>
    <p>Returns the <a href="chap07.html#lowlevel-lockfree-messagequeue">output queue</a> associated with this endpoint.</p>
  </li>
</ul>

<aside class="warning blurb">
    <p>In versions up to <sup>[3.04a]</sup>, both <code>SendWait</code> and <code>ReceiveWait</code> were designed to be used from only one thread at a time. Since OmniThreadLibrary <sup>[3.04b]</sup> they are both fully thread-safe and can be used from multiple producers and consumers at the same time.</p>

</aside>

<p>For practical examples on a communication channel usage, see the Communication subsection of <a href="chap07.html#lowlevel-simpletasks-communication">simple tasks</a> and <a href="chap07.html#lowlevel-tomniworker-communication"><code>TOmniWorker</code> tasks</a> sections.</p>

<aside class="information blurb">
    <p>Communication message queue is implemented using the <a href="chap07.html#lowlevel-lockfree-boundedqueue">Bounded Queue</a> structure.</p>

</aside>

<h3 id="leanpub-auto-processor-groups-and-numa-nodes">
<span class="section-number">4.6 </span>Processor groups and NUMA nodes</h3>

<p>On a system with multiple processor groups you can use <code>ProcessorGroup</code> <sup>[3.06]</sup> function to specify a processor group this task should run on. </p>

<p>On a system with multiple NUMA nodes you can use <code>NUMANode</code> <sup>[3.06]</sup> function to specify a NUMA node this task should run on.</p>

<p>When a task is not started directly (<code>Run</code>) but executed via thread pool (<code>Schedule</code>), <a href="chap07.html#lowlevel-threadpool"><code>IOmniThreadPool.ProcessorGroups</code></a> and <a href="chap07.html#lowlevel-threadpool"><code>IOmniThreadPool.NUMANodes</code></a> should be used instead.</p>

<p>An information about existing processor groups and NUMA nodes can be accessed through the <a href="chap09.html#misc-environment"><code>Environment</code></a> object.</p>

<p><a href="chap12.html#demos">Demo</a> <code>64_ProcessorGroups_NUMA</code> demonstrates the use of <code>ProcessorGroup</code> and <code>NUMANode</code> functions.</p>


<h3 id="lowlevel-threadpool">
<span class="section-number">4.7 </span>Thread pooling</h3>

<p>Starting a new thread in the Windows OS is not a very fast operation. If you are frequently scheduling background tasks, the overhead of creating new threads can significantly impact your program. To solve this, OmniThreadLibrary implements a <em>thread pool</em>, which is a basically a cache for threads.</p>

<aside class="information blurb">
    <p>All <a href="chap06.html#highlevel">high-level tasks</a> are executed in a thread pool unless <a href="chap06.html#highlevel-taskconfig-nothreadpool"><code>NoThreadPool</code></a> is used. </p>

</aside>

<p>You don’t <em>run</em> a task in a thread pool but <em>schedule</em> it by calling the <code>Schedule</code> method. A very short example of a scheduled task would be: </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">Beep</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="n">MessageBeep</code><code class="p">(</code><code class="n">MB_ICONEXCLAMATION</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">5 </code>
<code class="lineno">6 </code><code class="n">CreateTask</code><code class="p">(</code><code class="nb">Beep</code><code class="o">,</code> <code class="s">'Beep'</code><code class="p">)</code><code class="o">.</code><code class="n">Schedule</code><code class="o">;</code>
</pre></div>

</figure>

<p>A thread pool is created by calling the <code>CreateThreadPool</code> function. A thread pool should have a name (you can set it to an empty string) which is used as part of a pool management thread’s name.</p>

<p>You can also use the default <code>GlobalOmniThreadPool</code> pool which is created on the first use.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">CreateThreadPool</code><code class="p">(</code><code class="k">const</code> <code class="n">threadPoolName</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniThreadPool</code><code class="o">;</code>
<code class="lineno">2 </code>
<code class="lineno">3 </code><code class="k">function</code> <code class="nf">GlobalOmniThreadPool</code><code class="o">:</code> <code class="n">IOmniThreadPool</code><code class="o">;</code>
</pre></div>

</figure>

<aside class="information blurb">
    <p>High-level tasks use their own pool called <a href="chap06.html#highlevel-introduction-pooling"><code>GlobalParallelPool</code></a>.</p>

</aside>

<p>All thread pool-related code is stored in the <em>OtlThreadPool</em> unit.</p>

<p>
  <em>See also <a href="chap12.html#demos">demo</a> <code>11_ThreadPool</code>.</em>
</p>

<h4 id="leanpub-auto-execution-flow">
<span class="section-number">4.7.1 </span>Execution flow</h4>

<p>When you schedule a task into a thread pool, it merely enters a queue. The thread pool management thread detects this and tries to start this task in an already existing but idle thread. If there is no such thread, it tries to create a new thread (you can limit the maximum number of concurrent threads so this may not always succeed) and run the task in it.</p>

<p>When a task finishes execution, the thread it was running in is put into an idle state and may be reused for execution of new tasks.</p>

<p>Next section explains the various configuration options implemented by the thread pool.</p>

<h4 id="lowlevel-threadpool-interface">
<span class="section-number">4.7.2 </span>IOmniThreadPool interface</h4>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOTPThreadDataFactoryFunction</code> <code class="o">=</code> <code class="k">function</code><code class="o">:</code> <code class="nf">IInterface</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">TOTPThreadDataFactoryMethod</code> <code class="o">=</code> <code class="k">function</code><code class="o">:</code> <code class="nf">IInterface</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>  
<code class="lineno"> 4 </code>  
<code class="lineno"> 5 </code>  <code class="n">IOmniThreadPool</code> <code class="o">=</code> <code class="k">interface</code> 
<code class="lineno"> 6 </code>    <code class="k">function</code>  <code class="nf">Cancel</code><code class="p">(</code><code class="n">taskID</code><code class="o">:</code> <code class="kt">int64</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">function</code>  <code class="nf">Cancel</code><code class="p">(</code><code class="n">taskID</code><code class="o">:</code> <code class="kt">int64</code><code class="o">;</code> <code class="n">signalCancellationToken</code><code class="o">:</code> <code class="kt">boolean</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 8 </code>    <code class="k">procedure</code> <code class="nf">CancelAll</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">procedure</code> <code class="nf">CancelAll</code><code class="p">(</code><code class="n">signalCancellationToken</code><code class="o">:</code> <code class="kt">boolean</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">function</code>  <code class="nf">CountExecuting</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">function</code>  <code class="nf">CountQueued</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">function</code>  <code class="nf">IsIdle</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">13 </code>    <code class="k">function</code>  <code class="nf">MonitorWith</code><code class="p">(</code><code class="k">const</code> <code class="n">monitor</code><code class="o">:</code> <code class="n">IOmniThreadPoolMonitor</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniThreadPool</code><code class="o">;</code>
<code class="lineno">14 </code>    <code class="k">function</code>  <code class="nf">RemoveMonitor</code><code class="o">:</code> <code class="n">IOmniThreadPool</code><code class="o">;</code>
<code class="lineno">15 </code>    <code class="k">function</code>  <code class="nf">SetMonitor</code><code class="p">(</code><code class="n">hWindow</code><code class="o">:</code> <code class="kt">THandle</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniThreadPool</code><code class="o">;</code>
<code class="lineno">16 </code>    <code class="k">procedure</code> <code class="nf">SetThreadDataFactory</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOTPThreadDataFactoryMethod</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">17 </code>    <code class="k">procedure</code> <code class="nf">SetThreadDataFactory</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOTPThreadDataFactoryFunction</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">18 </code>    <code class="k">property</code> <code class="py">Asy_OnUnhandledWorkerException</code><code class="o">:</code> <code class="n">TOTPUnhandledWorkerException</code> <code class="kp">read</code>
<code class="lineno">19 </code>      <code class="nf">GetAsy_OnUnhandledWorkerException</code> <code class="kp">write</code> <code class="nf">SetAsy_OnUnhandledWorkerException</code><code class="o">;</code>
<code class="lineno">20 </code>    <code class="k">property</code> <code class="py">Affinity</code><code class="o">:</code> <code class="n">IOmniIntegerSet</code> <code class="kp">read</code> <code class="nf">GetAffinity</code><code class="o">;</code>
<code class="lineno">21 </code>    <code class="k">property</code> <code class="py">IdleWorkerThreadTimeout_sec</code><code class="o">:</code> <code class="kt">integer</code> <code class="kp">read</code> <code class="nf">GetIdleWorkerThreadTimeout_sec</code>
<code class="lineno">22 </code>      <code class="kp">write</code> <code class="nf">SetIdleWorkerThreadTimeout_sec</code><code class="o">;</code>
<code class="lineno">23 </code>    <code class="k">property</code> <code class="py">MaxExecuting</code><code class="o">:</code> <code class="kt">integer</code> <code class="kp">read</code> <code class="nf">GetMaxExecuting</code> <code class="kp">write</code> <code class="nf">SetMaxExecuting</code><code class="o">;</code>
<code class="lineno">24 </code>    <code class="k">property</code> <code class="py">MaxQueued</code><code class="o">:</code> <code class="kt">integer</code> <code class="kp">read</code> <code class="nf">GetMaxQueued</code> <code class="kp">write</code> <code class="nf">SetMaxQueued</code><code class="o">;</code>
<code class="lineno">25 </code>    <code class="k">property</code> <code class="py">MaxQueuedTime_sec</code><code class="o">:</code> <code class="kt">integer</code> <code class="kp">read</code> <code class="nf">GetMaxQueuedTime_sec</code> <code class="kp">write</code>
<code class="lineno">26 </code>      <code class="nf">SetMaxQueuedTime_sec</code><code class="o">;</code>
<code class="lineno">27 </code>    <code class="k">property</code> <code class="py">MinWorkers</code><code class="o">:</code> <code class="kt">integer</code> <code class="kp">read</code> <code class="nf">GetMinWorkers</code> <code class="kp">write</code> <code class="nf">SetMinWorkers</code><code class="o">;</code>
<code class="lineno">28 </code>    <code class="k">property</code> <code class="py">Name</code><code class="o">:</code> <code class="k">string</code> <code class="kp">read</code> <code class="nf">GetName</code> <code class="kp">write</code> <code class="nf">SetName</code><code class="o">;</code>
<code class="lineno">29 </code>    <code class="k">property</code> <code class="py">NumCores</code><code class="o">:</code> <code class="kt">integer</code> <code class="kp">read</code> <code class="nf">GetNumCores</code><code class="o">;</code>
<code class="lineno">30 </code>    <code class="k">property</code> <code class="py">Options</code><code class="o">:</code> <code class="n">TOmniThreadPoolOptions</code> <code class="kp">read</code> <code class="nf">GetOptions</code> <code class="kp">write</code> <code class="nf">SetOptions</code><code class="o">;</code>
<code class="lineno">31 </code>    <code class="k">property</code> <code class="py">UniqueID</code><code class="o">:</code> <code class="kt">int64</code> <code class="kp">read</code> <code class="nf">GetUniqueID</code><code class="o">;</code>
<code class="lineno">32 </code>    <code class="k">property</code> <code class="py">WaitOnTerminate_sec</code><code class="o">:</code> <code class="kt">integer</code> <code class="kp">read</code> <code class="nf">GetWaitOnTerminate_sec</code>
<code class="lineno">33 </code>      <code class="kp">write</code> <code class="nf">SetWaitOnTerminate_sec</code><code class="o">;</code>
<code class="lineno">34 </code>    <code class="cm">{$IFDEF OTL_NUMASupport}</code>
<code class="lineno">35 </code>    <code class="k">property</code> <code class="py">ProcessorGroups</code><code class="o">:</code> <code class="n">IOmniIntegerSet</code> <code class="kp">read</code> <code class="nf">GetProcessorGroups</code> <code class="kp">write</code>
<code class="lineno">36 </code>      <code class="nf">SetProcessorGroups</code><code class="o">;</code>
<code class="lineno">37 </code>    <code class="k">property</code> <code class="py">NUMANodes</code><code class="o">:</code> <code class="n">IOmniIntegerSet</code> <code class="kp">read</code> <code class="nf">GetNUMANodes</code> <code class="kp">write</code> <code class="nf">SetNUMANodes</code><code class="o">;</code>
<code class="lineno">38 </code>    <code class="cm">{$ENDIF OTL_NUMASupport}</code>
<code class="lineno">39 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>Methods</p>

<ul>
  <li>
<code>Cancel</code>
    <p>Cancels a task with specified <a href="chap07.html#lowlevel-simpletasks-uniqueid">unique ID</a> by calling task’s <a href="chap07.html#lowlevel-simpletasks-termination"><code>Terminate</code></a> method. If a task does not stop within <code>WaitOnTerminate_sec</code> seconds, the thread that is running the task will be killed by calling the <code>TerminateThread</code> Windows function.</p>

    <p>Since <sup>[3.07.2]</sup>, <code>Cancel</code> signals task’s <a href="chap08.html#synch-cancellationtoken">cancellation token</a> before calling Terminate. Old behaviour (without signalling cancellation token) can be achieved by calling overloaded version accepting the <code>signalCancellationToken</code> parameter or by setting <code>Option</code> to <code>[tpoPreventCancellationTokenOnCancel]</code>.   </p>

    <p>If a task is not yet executing, it will simply be removed from the input queue.</p>
  </li>
  <li>
<code>CancelAll</code>
    <p>Cancels all tasks, waiting and running. </p>
  </li>
  <li>
<code>CountExecuting</code>
    <p>Returns the number of executing tasks.</p>
  </li>
  <li>
<code>CountQueued</code>
    <p>Returns the number of queued (waiting) tasks.</p>
  </li>
  <li>
<code>IsIdle</code>
    <p>Returns <code>True</code> when thread pool has no work to do.</p>
  </li>
  <li>
<code>MonitorWith</code>
    <p>Attaches external <a href="chap07.html#lowlevel-threadpool-monitoring">monitor</a> to the thread pool.</p>
  </li>
  <li><code>RemoveMonitor</code></li>
</ul>

<p>Detaches external monitor from the thread pool. </p>

<ul>
  <li>
<code>SetMonitor</code>
    <p>This is an internal function, called from the external monitor when attaching to the thread pool.  </p>
  </li>
  <li>
<code>SetThreadDataFactory</code>
    <p>Associates a <em>data factory</em> function with the thread pool. A data factory can be used to create thread local data whenever a new thread is created.</p>

    <p><sup>[3.07]</sup> If <code>ThreadDataFactory.Execute</code> throws an exception, that exception is caught, ignored and <code>ThreadData</code> is set to nil.  </p>

    <p>The <a href="chap10.html#howto-connectionPool">Building a connection pool</a> example contains more information on this topic.</p>
  </li>
</ul>

<p>Properties</p>

<ul>
  <li>
<code>Affinity</code> <sup>[3.06]</sup>
    <p>Provides a set of all processors that are used for executing tasks in this thread pool. By changing this set you can specify which processors will be used to run tasks scheduled to this thread pool.</p>
  </li>
  <li>
<code>IdleWorkerThreadTimeout_sec</code>
    <p>Specifies the maximum time a thread can spend in an idle state. After that, the thread will be terminated. By default, this value is set to <em>10</em> seconds.</p>

    <p>By setting this value to <em>0</em>, idle threads are never terminated.</p>

    <p>OmniThreadLibrary will always keep <code>MinWorkers</code> threads alive, even if they are idle for more than <code>IdleWorkerThreadTimeout_sec</code> seconds.</p>
  </li>
  <li>
<code>MaxExecuting</code>
    <p>Specifies the maximum number of working threads in the thread pool. Initially, this value is set to the number of cores current process is allowed to run on.</p>

    <p>By setting this value to <em>0</em> you can prevent the thread pool from creating any threads. You can use this to temporarily stop a thread pool without destroying it.</p>

    <p>If <code>MaxExecuting</code> is set to <em>-1</em>, the number of running threads is only limited by the implementation.</p>
  </li>
</ul>

<aside class="warning blurb">
    <p>Starting with <sup>[3.04]</sup>, a maximum number of concurrent threads in a thread pool is not limited. Before that, it was limited to <em>60</em> concurrent threads.</p>

</aside>

<ul>
  <li>
<code>MaxQueued</code>
    <p>Specifies maximum number of tasks waiting in the input queue. If there are already <code>MaxQueued</code> tasks in the queue and a new task is scheduled, it will be immediately rejected (see <a href="chap07.html#lowlevel-threadpool-monitoring">Monitoring thread pool operations</a> for more information). </p>

    <p>If <code>MaxQueued</code> is set to <em>0</em> (which is the default value), the size of the input queue is not limited.</p>
  </li>
  <li>
<code>MaxQueuedTime_sec</code>
    <p>Specifies the maximum time a task will wait in the input queue before it is rejected (see <a href="chap07.html#lowlevel-threadpool-monitoring">Monitoring thread pool operations</a> for more information). </p>

    <p>If set to <em>0</em> (which is the default value), the time a task can spend in the input queue is not limited.</p>
  </li>
  <li>
<code>MinWorkers</code>
    <p>Specifies the minimum number of threads that should be created in any moment. Both idle and working threads are counted. By default this value is set to <em>0</em>.</p>

    <p>Since <sup>[3.05]</sup> setting this value to a positive number will create specified number of worker threads even if no tasks are waiting for the execution.</p>
  </li>
  <li>
<code>Name</code>
    <p>Specifies the name of the thread pool.</p>
  </li>
  <li>
<code>NumCores</code>
    <p>Returns the number of cores this pool uses for running tasks. Changing <code>Affinity</code>, <code>ProcessorGroups</code>, or <code>NUMANodes</code> properties may modify this value.</p>
  </li>
  <li>
<code>Options</code>
    <p>Contains a set of options that govern how thread pool operates internally. See <code>Cancel</code> for more information.</p>
  </li>
  <li>
<code>UniqueID</code>
    <p>Gives readonly access to the unique ID associated with the pool. This value is guaranteed to be greater than <em>0</em>.</p>
  </li>
  <li>
<code>WaitOnTerminate_sec</code>
    <p>When a pooled task is terminated after a <code>Cancel</code> or <code>CancelAll</code> is called, a thread pool manager will wait up to this number of seconds for the task to stop execution. After that, it will kill the thread with the <code>TerminateThread</code> call.</p>

    <p>By default this value is set to <em>30</em> seconds.</p>
  </li>
</ul>

<ul id="lowlevel-threadpool-unhandledexception">
  <li>
<code>Asy_OnUnhandledWorkerException</code> <sup>[3.06]</sup>
    <p>Before version 3.06, unhandled exceptions in the code handling the task execution were lost. Now, they are passed up to the <code>IOmniThreadPool</code>. If the property <code>Asy_OnUnhandledWorkerException</code> is set, such exception will be passed to the event handler and application should react to it. The only safe way at that point is to log the error and terminate the application.</p>
  </li>
</ul>

<h4 id="lowlevel-threadpool-exitcode">
<span class="section-number">4.7.3 </span>Task exit code</h4>

<p>Various reasons for task termination are signalled through its <a href="chap07.html#lowlevel-simpletasks-exitcode"><code>ExitCode</code></a> property. Following thread pool-specific exit codes are defined.</p>

<ul>
  <li>
<code>EXIT_THREADPOOL_QUEUE_TOO_LONG</code>
    <p>Task was rejected because the input queue already contains at least <code>MaxQueued</code> tasks.</p>
  </li>
  <li>
<code>EXIT_THREADPOOL_STALE_TASK</code>
    <p>Task was rejected because it was waiting in the input queue for more than <code>MaxQueuedTime_sec</code> seconds.      </p>
  </li>
  <li>
<code>EXIT_THREADPOOL_CANCELLED</code>
    <p>Task was cancelled with a <code>Cancel</code> or <code>CancelAll</code> call.</p>
  </li>
  <li>
<code>EXIT_THREADPOOL_INTERNAL_ERROR</code>
    <p>This exit code is currently not in use.</p>
  </li>
</ul>

<h4 id="lowlevel-threadpool-monitoring">
<span class="section-number">4.7.4 </span>Monitoring thread pool operations</h4>

<p>An <a href="chap07.html#lowlevel-eventmonitor">event monitor</a> component can be used to monitor thread pool events. First you have to attach it to the thread pool by calling the <code>MonitorWith</code> method. After that, following event monitor event handlers can be used:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniMonitorPoolThreadEvent</code> <code class="o">=</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">pool</code><code class="o">:</code> <code class="n">IOmniThreadPool</code><code class="o">;</code> 
<code class="lineno"> 3 </code>    <code class="n">threadID</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">TOmniMonitorPoolWorkItemEvent</code> <code class="o">=</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">pool</code><code class="o">:</code> <code class="n">IOmniThreadPool</code><code class="o">;</code> 
<code class="lineno"> 5 </code>    <code class="n">taskID</code><code class="o">:</code> <code class="kt">int64</code><code class="p">)</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>
<code class="lineno"> 6 </code>
<code class="lineno"> 7 </code>  <code class="n">TOmniEventMonitor</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TComponent</code><code class="o">,</code> 
<code class="lineno"> 8 </code>                            <code class="n">IOmniTaskControlMonitor</code><code class="o">,</code>
<code class="lineno"> 9 </code>                            <code class="n">IOmniThreadPoolMonitor</code><code class="p">)</code>
<code class="lineno">10 </code>  <code class="kp">public</code>
<code class="lineno">11 </code>    <code class="k">property</code> <code class="py">OnPoolThreadCreated</code><code class="o">:</code> <code class="n">TOmniMonitorPoolThreadEvent</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">property</code> <code class="py">OnPoolThreadDestroying</code><code class="o">:</code> <code class="n">TOmniMonitorPoolThreadEvent</code><code class="o">;</code>
<code class="lineno">13 </code>    <code class="k">property</code> <code class="py">OnPoolThreadKilled</code><code class="o">:</code> <code class="n">TOmniMonitorPoolThreadEvent</code><code class="o">;</code>
<code class="lineno">14 </code>    <code class="k">property</code> <code class="py">OnPoolWorkItemCompleted</code><code class="o">:</code> <code class="n">TOmniMonitorPoolWorkItemEvent</code><code class="o">;</code>
<code class="lineno">15 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<ul>
  <li>
<code>OnPoolThreadCreated</code>
    <p>This event is called whenever a new thread is created in the pool.</p>
  </li>
  <li>
<code>OnPoolThreadDestroying</code>
    <p>This event is called just before a thread is destroyed.</p>
  </li>
  <li>
<code>OnPollThreadKilled</code>
    <p>This event is called when a thread is killed because the task did not stop in the allowed time.</p>
  </li>
  <li>
<code>OnPoolWorkItemCompleted</code>
    <p>This event is called when a task is removed from the thread pool. This can occur on task completion, when a task is removed before it has even started (<code>Cancel</code>, <code>CancelAll</code>) and when a thread containing a task is killed because the <code>Cancel</code> was called and the task didn’t stop in the allowed time.</p>
  </li>
</ul>

<aside class="tip blurb">
    <p>Single event monitor can be used to monitor multiple thread pools.</p>

</aside>

<h4 id="leanpub-auto-processor-groups-and-numa-nodes-1">
<span class="section-number">4.7.5 </span>Processor groups and NUMA nodes</h4>

<p>Through the property <code>ProcessorGroups</code> you can specify all processor groups the tasks can be scheduled to. By default this set is empty which means that tasks will only be scheduled to the default processor group. </p>

<p>By setting the property <code>NUMANodes</code> you can specify all NUMA nodes  the tasks can be scheduled to. By default this set is empty which means that tasks will only be scheduled to the default NUMA node.</p>

<p>An information about existing processor groups and NUMA nodes can be accessed through the <a href="chap09.html#misc-environment"><code>Environment</code></a> object.</p>

<p><a href="chap12.html#demos">Demo</a> <code>64_ProcessorGroups_NUMA</code> demonstrates the use of <code>ProcessorGroup</code> and <code>NUMANode</code> functions.</p>


<h3 id="lowlevel-lockfree">
<span class="section-number">4.8 </span>Lock-free collections</h3>

<p>OmniThreadLibrary implements three lock-free data structures suitable for low-level usage – <a href="chap07.html#lowlevel-lockfree-boundedstack">bounded stack</a>, <a href="chap07.html#lowlevel-lockfree-boundedqueue">bounded queue</a> and <a href="chap07.html#lowlevel-lockfree-dynamicqueue">dynamic queue</a>. Bounded queue is used inside the OmniThreadLibrary for messaging while dynamic queue is used as a basis of the <a href="chap06.html#highlevel-blocking-collection">blocking collection</a>.</p>

<p>All three data structures are fully thread-safe. They support multiple simultaneous readers and writers. They are implemented in the <em>OtlContainers</em> unit. </p>

<p>Another lock-free data structure, a <a href="chap07.html#lowlevel-lockfree-messagequeue">message queue</a>, is defined in the <em>OtlComm</em> unit and is mostly intended for internal operation (such as sending messages to and from a thread) although it can also be used for other tasks. An example of such usage is shown in the <a href="chap10.html#howto-mqtthread">Using message queue with a <code>TThread</code> worker</a> chapter. </p>

<blockquote>
  <p>The term <em>lock-free</em> is not well defined (and not even universally accepted). In the context of this book <em>lock-free</em> means that the synchronisation between threads is not achieved with the user- or kernel-level synchronisation primitives such as critical sections, but with bus-locking CPU instructions. With modern CPU architectures this approach is much faster than locking on the operating system level.</p>
</blockquote>

<p>
  <em>See also <a href="chap12.html#demos">demos</a> <code>10_Containers</code> and <code>32_Queue</code>.</em>
</p>

<h4 id="lowlevel-lockfree-boundedstack">
<span class="section-number">4.8.1 </span>Bounded Stack</h4>

<p>The bounded <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">stack</a> structure is a very fast stack with limited length. The core of the implementation is stored in the <code>TOmniBaseBoundedStack</code> class.</p>

<p>Derived class <code>TOmniBoundedStack</code> adds support for <a href="chap07.html#lowlevel-lockfree-observing">external observers</a>. Both classes implement the same interface – <code>IOmniStack</code> – so you can code against the class or against the interface.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">IOmniStack</code> <code class="o">=</code> <code class="k">interface</code> 
<code class="lineno"> 3 </code>    <code class="k">procedure</code> <code class="nf">Empty</code><code class="o">;</code>
<code class="lineno"> 4 </code>    <code class="k">procedure</code> <code class="nf">Initialize</code><code class="p">(</code><code class="n">numElements</code><code class="o">,</code> <code class="n">elementSize</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 5 </code>    <code class="k">function</code>  <code class="nf">IsEmpty</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 6 </code>    <code class="k">function</code>  <code class="nf">IsFull</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">function</code>  <code class="nf">Pop</code><code class="p">(</code><code class="k">var</code> <code class="n">value</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 8 </code>    <code class="k">function</code>  <code class="nf">Push</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">10 </code>                                                                        
<code class="lineno">11 </code>  <code class="n">TOmniBaseBoundedStack</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TInterfacedObject</code><code class="o">,</code> <code class="n">IOmniStack</code><code class="p">)</code>
<code class="lineno">12 </code>  <code class="kp">public</code>
<code class="lineno">13 </code>    <code class="k">destructor</code> <code class="nf">Destroy</code><code class="o">;</code> <code class="kp">override</code><code class="o">;</code>
<code class="lineno">14 </code>    <code class="k">procedure</code> <code class="nf">Empty</code><code class="o">;</code>
<code class="lineno">15 </code>    <code class="k">procedure</code> <code class="nf">Initialize</code><code class="p">(</code><code class="n">numElements</code><code class="o">,</code> <code class="n">elementSize</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code> <code class="kp">virtual</code><code class="o">;</code>
<code class="lineno">16 </code>    <code class="k">function</code>  <code class="nf">IsEmpty</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> <code class="k">inline</code><code class="o">;</code>
<code class="lineno">17 </code>    <code class="k">function</code>  <code class="nf">IsFull</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> <code class="k">inline</code><code class="o">;</code>
<code class="lineno">18 </code>    <code class="k">function</code>  <code class="nf">Pop</code><code class="p">(</code><code class="k">var</code> <code class="n">value</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">19 </code>    <code class="k">function</code>  <code class="nf">Push</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">20 </code>    <code class="k">property</code>  <code class="py">ElementSize</code><code class="o">:</code> <code class="kt">integer</code> <code class="kp">read</code> <code class="nf">obsElementSize</code><code class="o">;</code>
<code class="lineno">21 </code>    <code class="k">property</code>  <code class="py">NumElements</code><code class="o">:</code> <code class="kt">integer</code> <code class="kp">read</code> <code class="nf">obsNumElements</code><code class="o">;</code>
<code class="lineno">22 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">23 </code>  
<code class="lineno">24 </code>  <code class="n">TOmniBoundedStack</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TOmniBaseBoundedStack</code><code class="p">)</code>
<code class="lineno">25 </code>  <code class="kp">public</code>
<code class="lineno">26 </code>    <code class="k">constructor</code> <code class="nf">Create</code><code class="p">(</code><code class="n">numElements</code><code class="o">,</code> <code class="n">elementSize</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">27 </code>      <code class="n">partlyEmptyLoadFactor</code><code class="o">:</code> <code class="kt">real</code> <code class="o">=</code> <code class="n">CPartlyEmptyLoadFactor</code><code class="o">;</code>
<code class="lineno">28 </code>      <code class="n">almostFullLoadFactor</code><code class="o">:</code> <code class="kt">real</code> <code class="o">=</code> <code class="n">CAlmostFullLoadFactor</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">29 </code>    <code class="k">destructor</code>  <code class="nf">Destroy</code><code class="o">;</code> <code class="kp">override</code><code class="o">;</code>
<code class="lineno">30 </code>    <code class="k">function</code> <code class="nf">Pop</code><code class="p">(</code><code class="k">var</code> <code class="n">value</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">31 </code>    <code class="k">function</code> <code class="nf">Push</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">32 </code>    <code class="k">property</code> <code class="py">ContainerSubject</code><code class="o">:</code> <code class="n">TOmniContainerSubject</code> <code class="kp">read</code> <code class="nf">osContainerSubject</code><code class="o">;</code>
<code class="lineno">33 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<ul>
  <li>
<code>Empty</code>
    <p>Empties the stack.</p>
  </li>
  <li>
<code>Initialize</code>
    <p>Initializes the stack for maximum <code>numElements</code> elements of size <code>elementSize</code>.</p>
  </li>
  <li>
<code>IsEmpty</code>
    <p>Returns <code>True</code> when the stack is empty.</p>
  </li>
  <li>
<code>IsFull</code>
    <p>Returns <code>True</code> when the stack is full.</p>
  </li>
  <li>
<code>Pop</code>
    <p>Takes one value from the stack and returns <code>True</code> if the stack was not empty before the operation.</p>
  </li>
  <li>
<code>Push</code>
    <p>Puts one value on the stack and returns <code>True</code> if there was a place for the value (the stack was not full before the operation).</p>
  </li>
  <li>
<code>ElementSize</code>
    <p>Returns the size of the stack element as set in the <code>Initialize</code> call.</p>
  </li>
  <li>
<code>NumElements</code>
    <p>Returns the maximum number of elements in the stack as set in the <code>Initialize</code> call.</p>
  </li>
  <li>
<code>ContainerSubject</code>
    <p>Provides a point for attaching external observers as described in the <a href="chap07.html#lowlevel-lockfree-observing">Observing lock-free collections</a> section.</p>
  </li>
</ul>

<h4 id="lowlevel-lockfree-boundedqueue">
<span class="section-number">4.8.2 </span>Bounded queue</h4>

<p>The bounded <a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">queue</a> structure is a very fast queue with limited length. </p>

<p>The core of the implementation is stored in the <code>TOmniBaseBoundedQueue</code> class. Derived class <code>TOmniBoundedQueue</code> adds support for <a href="chap07.html#lowlevel-lockfree-observing">external observers</a>. Both classes implement the same interface – <code>IOmniQueue</code> – so you can code against the class or against the interface.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">IOmniQueue</code> <code class="o">=</code> <code class="k">interface</code> 
<code class="lineno"> 3 </code>    <code class="k">function</code>  <code class="nf">Dequeue</code><code class="p">(</code><code class="k">var</code> <code class="n">value</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 4 </code>    <code class="k">procedure</code> <code class="nf">Empty</code><code class="o">;</code>
<code class="lineno"> 5 </code>    <code class="k">function</code>  <code class="nf">Enqueue</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 6 </code>    <code class="k">procedure</code> <code class="nf">Initialize</code><code class="p">(</code><code class="n">numElements</code><code class="o">,</code> <code class="n">elementSize</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">function</code>  <code class="nf">IsEmpty</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 8 </code>    <code class="k">function</code>  <code class="nf">IsFull</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">10 </code>
<code class="lineno">11 </code>  <code class="n">TOmniBaseBoundedQueue</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TInterfacedObject</code><code class="o">,</code> <code class="n">IOmniQueue</code><code class="p">)</code>
<code class="lineno">12 </code>  <code class="kp">public</code>
<code class="lineno">13 </code>    <code class="k">destructor</code> <code class="nf">Destroy</code><code class="o">;</code> <code class="kp">override</code><code class="o">;</code>
<code class="lineno">14 </code>    <code class="k">function</code>  <code class="nf">Dequeue</code><code class="p">(</code><code class="k">var</code> <code class="n">value</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">15 </code>    <code class="k">procedure</code> <code class="nf">Empty</code><code class="o">;</code>
<code class="lineno">16 </code>    <code class="k">function</code>  <code class="nf">Enqueue</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">17 </code>    <code class="k">procedure</code> <code class="nf">Initialize</code><code class="p">(</code><code class="n">numElements</code><code class="o">,</code> <code class="n">elementSize</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code> <code class="kp">virtual</code><code class="o">;</code>
<code class="lineno">18 </code>    <code class="k">function</code>  <code class="nf">IsEmpty</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">19 </code>    <code class="k">function</code>  <code class="nf">IsFull</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">20 </code>    <code class="k">property</code>  <code class="py">ElementSize</code><code class="o">:</code> <code class="kt">integer</code> <code class="kp">read</code> <code class="nf">obqElementSize</code><code class="o">;</code>
<code class="lineno">21 </code>    <code class="k">property</code>  <code class="py">NumElements</code><code class="o">:</code> <code class="kt">integer</code> <code class="kp">read</code> <code class="nf">obqNumElements</code><code class="o">;</code>
<code class="lineno">22 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">23 </code>  
<code class="lineno">24 </code>  <code class="n">TOmniBoundedQueue</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TOmniBaseBoundedQueue</code><code class="p">)</code>
<code class="lineno">25 </code>  <code class="kp">public</code>
<code class="lineno">26 </code>    <code class="k">constructor</code> <code class="nf">Create</code><code class="p">(</code><code class="n">numElements</code><code class="o">,</code> <code class="n">elementSize</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">27 </code>      <code class="n">partlyEmptyLoadFactor</code><code class="o">:</code> <code class="kt">real</code> <code class="o">=</code> <code class="n">CPartlyEmptyLoadFactor</code><code class="o">;</code>
<code class="lineno">28 </code>      <code class="n">almostFullLoadFactor</code><code class="o">:</code> <code class="kt">real</code> <code class="o">=</code> <code class="n">CAlmostFullLoadFactor</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">29 </code>    <code class="k">destructor</code>  <code class="nf">Destroy</code><code class="o">;</code> <code class="kp">override</code><code class="o">;</code>
<code class="lineno">30 </code>    <code class="k">function</code>  <code class="nf">Dequeue</code><code class="p">(</code><code class="k">var</code> <code class="n">value</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">31 </code>    <code class="k">function</code>  <code class="nf">Enqueue</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">32 </code>    <code class="k">property</code>  <code class="py">ContainerSubject</code><code class="o">:</code> <code class="n">TOmniContainerSubject</code> <code class="kp">read</code> <code class="nf">oqContainerSubject</code><code class="o">;</code>
<code class="lineno">33 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<ul>
  <li>
<code>Empty</code>
    <p>Empties the stack.</p>
  </li>
  <li>
<code>Dequeue</code>
    <p>Takes one value from the queue’s head and returns <code>True</code> if the queue was not empty before the operation.</p>
  </li>
  <li>
<code>Enqueue</code>
    <p>Inserts one value on the queue’s tail and returns <code>True</code> if there was place for the value (the queue was not full before the operation).</p>
  </li>
  <li>
<code>Initialize</code>
    <p>Initializes the queue for maximum <code>numElements</code> elements of size <code>elementSize</code>.</p>
  </li>
  <li>
<code>IsEmpty</code>
    <p>Returns <code>True</code> when the queue is empty.</p>
  </li>
  <li>
<code>IsFull</code>
    <p>Returns <code>True</code> when the queue is full.</p>
  </li>
  <li>
<code>ElementSize</code>
    <p>Returns the size of the queue element as set in the <code>Initialize</code> call.</p>
  </li>
  <li>
<code>NumElements</code>
    <p>Returns the maximum number of elements in the queue as set in the <code>Initialize</code> call.</p>
  </li>
  <li>
<code>ContainerSubject</code>
    <p>Provides a point for attaching external observers as described in the <a href="chap07.html#lowlevel-lockfree-observing">Observing lock-free collections</a> section.</p>
  </li>
</ul>

<h4 id="lowlevel-lockfree-messagequeue">
<span class="section-number">4.8.3 </span>Message queue</h4>

<p>The <code>TOmniMessageQueue</code> is just a thin wrapper around the <a href="chap07.html#lowlevel-lockfree-boundedqueue">bounded queue</a> data structure. An element of this queue is a (<em>message ID</em>, <em>message data</em>) pair, stored in a <code>TOmniMessage</code> record.</p>

<p>This class greatly simplifies creating and attaching event and window <a href="chap07.html#lowlevel-lockfree-observing">observers</a>. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniMessage</code> <code class="o">=</code> <code class="k">record</code>
<code class="lineno"> 3 </code>    <code class="n">MsgID</code>  <code class="o">:</code> <code class="kt">word</code><code class="o">;</code>
<code class="lineno"> 4 </code>    <code class="n">MsgData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno"> 5 </code>    <code class="k">constructor</code> <code class="nf">Create</code><code class="p">(</code><code class="n">aMsgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> <code class="n">aMsgData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 6 </code>    <code class="k">constructor</code> <code class="nf">Create</code><code class="p">(</code><code class="n">aMsgID</code><code class="o">:</code> <code class="kt">word</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno"> 8 </code>
<code class="lineno"> 9 </code>  <code class="n">TOmniContainerWindowsEventObserver</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TOmniContainerObserver</code><code class="p">)</code>
<code class="lineno">10 </code>  <code class="kp">public</code>
<code class="lineno">11 </code>    <code class="k">function</code>  <code class="nf">GetEvent</code><code class="o">:</code> <code class="kt">THandle</code><code class="o">;</code> <code class="kp">virtual</code><code class="o">;</code> <code class="kp">abstract</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">13 </code>  
<code class="lineno">14 </code>  <code class="n">TOmniMessageQueueMessageEvent</code> <code class="o">=</code> 
<code class="lineno">15 </code>    <code class="k">procedure</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="o">;</code> <code class="k">const</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>
<code class="lineno">16 </code>
<code class="lineno">17 </code>  <code class="n">TOmniMessageQueue</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TOmniBoundedQueue</code><code class="p">)</code>
<code class="lineno">18 </code>  <code class="kp">public</code>
<code class="lineno">19 </code>    <code class="k">constructor</code> <code class="nf">Create</code><code class="p">(</code><code class="n">numMessages</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> 
<code class="lineno">20 </code>      <code class="n">createEventObserver</code><code class="o">:</code> <code class="kt">boolean</code> <code class="o">=</code> <code class="k">true</code><code class="p">)</code><code class="o">;</code> <code class="k">reintroduce</code><code class="o">;</code>
<code class="lineno">21 </code>    <code class="k">destructor</code>  <code class="nf">Destroy</code><code class="o">;</code> <code class="kp">override</code><code class="o">;</code>
<code class="lineno">22 </code>    <code class="k">function</code>  <code class="nf">Dequeue</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="o">;</code> <code class="k">reintroduce</code><code class="o">;</code>
<code class="lineno">23 </code>    <code class="k">function</code>  <code class="nf">Enqueue</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> <code class="k">reintroduce</code><code class="o">;</code>
<code class="lineno">24 </code>    <code class="k">procedure</code> <code class="nf">Empty</code><code class="o">;</code>
<code class="lineno">25 </code>    <code class="k">function</code>  <code class="nf">GetNewMessageEvent</code><code class="o">:</code> <code class="kt">THandle</code><code class="o">;</code>
<code class="lineno">26 </code>    <code class="k">function</code>  <code class="nf">TryDequeue</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> <code class="k">reintroduce</code><code class="o">;</code>
<code class="lineno">27 </code>    <code class="k">property</code> <code class="py">EventObserver</code><code class="o">:</code> <code class="n">TOmniContainerWindowsEventObserver</code> 
<code class="lineno">28 </code>      <code class="kp">read</code> <code class="nf">mqWinEventObserver</code><code class="o">;</code>
<code class="lineno">29 </code>    <code class="k">property</code> <code class="py">OnMessage</code><code class="o">:</code> <code class="n">TOmniMessageQueueMessageEvent</code> 
<code class="lineno">30 </code>      <code class="kp">read</code> <code class="nc">mqWinMsgObserver</code><code class="o">.</code><code class="nf">OnMessage</code> <code class="kp">write</code> <code class="nf">SetOnMessage</code><code class="o">;</code>
<code class="lineno">31 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>TOmniMessageQueue.Create</code> creates an <a href="chap07.html#lowlevel-lockfree-observing">event observer</a> unless the second parameter (<code>createEventObserver</code>) is set to <code>False</code>. It is created with the <code>coiNotifyOnAllInserts</code> interest meaning that an event (accessible through the <code>GetNewMessageEvent</code> function) is signalled each time an element (a message) is added to the queue. The observer itself is accessible through the <code>EventObserver</code> property.  </p>

<p>You can also easily create a <a href="chap07.html#lowlevel-lockfree-observing">window message observer</a> by attaching an event handler to the <code>OnMessage</code> property. This observer is also created with the <code>coiNotifyOnAllInserts</code> interest which causes the <code>OnMessage</code> event handler to be called each time an element (a message) is added to the queue. You can destroy this observer at any time by assigning a <code>nil</code> value to the <code>OnMessage</code> event.</p>

<p>
  <em>For an example, see chapter <a href="chap10.html#howto-mqtthread">Using message queue with a <code>TThread</code> worker</a>.</em>
</p>

<h4 id="lowlevel-lockfree-dynamicqueue">
<span class="section-number">4.8.4 </span>Dynamic queue</h4>

<p>The dynamic <a href="https://en.wikipedia.org/wiki/Queue_(data_structure)">queue</a> is a fast queue with unlimited length. It can grow as required as the data used to store elements is dynamically allocated.</p>

<p>The core of the implementation is stored in the <code>TOmniBaseQueue</code> class. Derived class <code>TOmniQueue</code> adds support for <a href="chap07.html#lowlevel-lockfree-observing">external observers</a>. Both structures store <a href="chap05.html#introotl-tomnivalue"><code>TOmniValue</code></a> elements. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniBaseQueue</code> <code class="o">=</code> <code class="k">class</code>
<code class="lineno"> 3 </code>  <code class="o">...</code>
<code class="lineno"> 4 </code>  <code class="kp">public</code>
<code class="lineno"> 5 </code>    <code class="k">constructor</code> <code class="nf">Create</code><code class="p">(</code><code class="n">blockSize</code><code class="o">:</code> <code class="kt">integer</code> <code class="o">=</code> <code class="mi">65536</code><code class="o">;</code> <code class="n">numCachedBlocks</code><code class="o">:</code> <code class="kt">integer</code> <code class="o">=</code> <code class="mi">4</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 6 </code>    <code class="k">destructor</code>  <code class="nf">Destroy</code><code class="o">;</code> <code class="kp">override</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">function</code>  <code class="nf">Dequeue</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno"> 8 </code>    <code class="k">procedure</code> <code class="nf">Enqueue</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">function</code>  <code class="nf">IsEmpty</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">function</code>  <code class="nf">TryDequeue</code><code class="p">(</code><code class="k">var</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">12 </code>  
<code class="lineno">13 </code>  <code class="n">TOmniQueue</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TOmniBaseQueue</code><code class="p">)</code>
<code class="lineno">14 </code>  <code class="o">...</code>
<code class="lineno">15 </code>  <code class="kp">public</code>
<code class="lineno">16 </code>    <code class="k">function</code>  <code class="nf">Dequeue</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno">17 </code>    <code class="k">procedure</code> <code class="nf">Enqueue</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">18 </code>    <code class="k">function</code>  <code class="nf">TryDequeue</code><code class="p">(</code><code class="k">var</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">19 </code>    <code class="k">property</code> <code class="py">ContainerSubject</code><code class="o">:</code> <code class="n">TOmniContainerSubject</code> <code class="kp">read</code> <code class="nf">ocContainerSubject</code><code class="o">;</code>
<code class="lineno">20 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<ul>
  <li>
<code>Create</code>
    <p>Creates a queue object with a specified page size (<code>blockSize</code>) where <code>numCachedBlocks</code> are always preserved for future use. Defaults (<code>65536</code> and <code>4</code>) should be appropriate for most scenarios.</p>
  </li>
  <li>
<code>Dequeue</code>
    <p>Takes one element from queue’s head and returns it. If the queue is empty, an exception is raised.</p>
  </li>
  <li>
<code>Enqueue</code>
    <p>Inserts an element on the queue’s tail.</p>
  </li>
  <li>
<code>IsEmpty</code>
    <p>Returns <code>True</code> when the queue is empty.</p>
  </li>
  <li>
<code>TryDequeue</code>
    <p>Takes one element from queue’s head and returns it in the <code>value</code> parameter. Returns <code>True</code> if an element was returned (the queue was not empty before the operation).</p>
  </li>
  <li>
<code>ContainerSubject</code>
    <p>Provides a point for attaching external observers as described in the <a href="chap07.html#lowlevel-lockfree-observing">Observing lock-free collections</a> section.</p>
  </li>
</ul>

<h4 id="lowlevel-lockfree-observing">
<span class="section-number">4.8.5 </span>Observing lock-free collections</h4>

<p>OmniThreadLibrary data structures support the <a href="https://en.wikipedia.org/wiki/Observer_pattern"><em>observer</em></a> design pattern. Each structure can be observed by multiple observers at the same time. Supporting code and two observer implementations are stored in the <em>OtlContainerObserver</em> unit.</p>

<p>Current architecture supports four different kinds of events that can be observed:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">type</code>
<code class="lineno">2 </code>  <code class="c1">///&lt;summary&gt;All possible actions observer can take interest in.&lt;/summary&gt;</code>
<code class="lineno">3 </code>  <code class="n">TOmniContainerObserverInterest</code> <code class="o">=</code> <code class="p">(</code>
<code class="lineno">4 </code>    <code class="c1">//Interests with permanent subscription:</code>
<code class="lineno">5 </code>    <code class="n">coiNotifyOnAllInserts</code><code class="o">,</code> <code class="n">coiNotifyOnAllRemoves</code><code class="o">,</code>
<code class="lineno">6 </code>    <code class="c1">//Interests with one-shot subscription:</code>
<code class="lineno">7 </code>    <code class="n">coiNotifyOnPartlyEmpty</code><code class="o">,</code> <code class="n">coiNotifyOnAlmostFull</code>
<code class="lineno">8 </code>  <code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<ul>
  <li>
<code>coiNotifyOnAllInserts</code>
    <p>Observer is notified whenever a data element is inserted into the structure.</p>
  </li>
  <li>
<code>coiNotifyOnAllRemoves</code>
    <p>Observer is notified whenever a data element is removed from the structure.</p>
  </li>
  <li>
<code>coiNotifyOnPartlyEmpty</code>
    <p>Observer is notified whenever a data usage drops below the <code>partlyEmptyLoadFactor</code> (parameter of the data structure constructor, 80% by default). This event is only supported for bounded structures.</p>

    <p>This event can only be observed once. After that you should destroy the observer and (if required) create another one and attach it to the data structure.</p>
  </li>
  <li>
<code>coiNotifyOnAlmostFull</code>
    <p>Observer is notified whenever a data usage rises above the <code>almostFullLoadFactor</code> (parameter of the data structure constructor, 90% by default). This event is only supported for bounded structures.</p>

    <p>This event can only be observed once. After that you should destroy the observer and (if required) create another one and attach it to the data structure.</p>
  </li>
</ul>

<p>The <em>OtlContainerObserver</em> unit implements <em>event</em> and <em>message</em> observers.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code>  <code class="n">TOmniContainerWindowsEventObserver</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TOmniContainerObserver</code><code class="p">)</code>
<code class="lineno"> 2 </code>  <code class="kp">public</code>
<code class="lineno"> 3 </code>    <code class="k">function</code>  <code class="nf">GetEvent</code><code class="o">:</code> <code class="kt">THandle</code><code class="o">;</code> <code class="kp">virtual</code><code class="o">;</code> <code class="kp">abstract</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="k">end</code><code class="o">;</code> 
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code>  <code class="n">TOmniContainerWindowsMessageObserver</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TOmniContainerObserver</code><code class="p">)</code>
<code class="lineno"> 7 </code>  <code class="n">strict</code> <code class="kp">protected</code>
<code class="lineno"> 8 </code>    <code class="k">function</code>  <code class="nf">GetHandle</code><code class="o">:</code> <code class="kt">THandle</code><code class="o">;</code> <code class="kp">virtual</code><code class="o">;</code> <code class="kp">abstract</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="kp">public</code>
<code class="lineno">10 </code>    <code class="k">procedure</code> <code class="nf">Send</code><code class="p">(</code><code class="n">aMessage</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> <code class="n">wParam</code><code class="o">,</code> <code class="n">lParam</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code> 
<code class="lineno">11 </code>      <code class="kp">virtual</code><code class="o">;</code> <code class="kp">abstract</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">property</code> <code class="py">Handle</code><code class="o">:</code> <code class="kt">THandle</code> <code class="kp">read</code> <code class="nf">GetHandle</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="k">end</code><code class="o">;</code> 
<code class="lineno">14 </code>
<code class="lineno">15 </code>  <code class="k">function</code> <code class="nf">CreateContainerWindowsEventObserver</code><code class="p">(</code><code class="n">externalEvent</code><code class="o">:</code> <code class="kt">THandle</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code><code class="o">:</code>
<code class="lineno">16 </code>    <code class="n">TOmniContainerWindowsEventObserver</code><code class="o">;</code>
<code class="lineno">17 </code>    
<code class="lineno">18 </code>  <code class="k">function</code> <code class="nf">CreateContainerWindowsMessageObserver</code><code class="p">(</code><code class="n">hWindow</code><code class="o">:</code> <code class="kt">THandle</code><code class="o">;</code> 
<code class="lineno">19 </code>    <code class="n">msg</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> <code class="n">wParam</code><code class="o">,</code> <code class="n">lParam</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">20 </code>    <code class="n">TOmniContainerWindowsMessageObserver</code><code class="o">;</code>
</pre></div>

</figure>

<p>The <em>event</em> observer <code>TOmniContainerWindowsEventObserver</code> raises an event every time the observed event occurs.</p>

<p>The <em>message</em> observer <code>TOmniContainerWindowsMessageObserver</code> sends a message to a window every time the observed event occurs.</p>

<h5 id="leanpub-auto-examples-7">
<span class="section-number">4.8.5.1 </span>Examples</h5>

<p>Create and attach the <em>event</em> observer:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FObserver</code> <code class="o">:=</code> <code class="n">CreateContainerWindowsEventObserver</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">FCollection</code><code class="o">.</code><code class="n">ContainerSubject</code><code class="o">.</code><code class="n">Attach</code><code class="p">(</code><code class="n">FObserver</code><code class="o">,</code> <code class="n">coiNotifyOnAllInserts</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>Access the observer event so you can wait on it:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FEvent</code> <code class="o">:=</code> <code class="n">FObserver</code><code class="o">.</code><code class="n">GetEvent</code><code class="o">;</code>
</pre></div>

</figure>

<p>Detach and destroy the observer:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FCollection</code><code class="o">.</code><code class="n">ContainerSubject</code><code class="o">.</code><code class="n">Detach</code><code class="p">(</code><code class="n">FObserver</code><code class="o">,</code> <code class="n">coiNotifyOnAllInserts</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">FObserver</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>Create and attach the <em>message</em> observer:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FWindow</code> <code class="o">:=</code> <code class="n">DSiAllocateHWnd</code><code class="p">(</code><code class="n">ObserverWndProc</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">FObserver</code> <code class="o">:=</code> <code class="n">CreateContainerWindowsMessageObserver</code><code class="p">(</code>
<code class="lineno">3 </code>  <code class="n">FWindow</code><code class="o">,</code> <code class="n">MSG_ITEM_INSERTED</code><code class="o">,</code> <code class="mi">0</code><code class="o">,</code> <code class="mi">0</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">4 </code><code class="n">FWorker</code><code class="o">.</code><code class="n">Output</code><code class="o">.</code><code class="n">ContainerSubject</code><code class="o">.</code><code class="n">Attach</code><code class="p">(</code><code class="n">FObserver</code><code class="o">,</code> <code class="n">coiNotifyOnAllInserts</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>Process observer messages:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">ObserverWndProc</code><code class="p">(</code><code class="k">var</code> <code class="n">message</code><code class="o">:</code> <code class="n">TMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">ovWorkItem</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">workItem</code>  <code class="o">:</code> <code class="n">IOmniWorkItem</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="k">if</code> <code class="n">message</code><code class="o">.</code><code class="n">Msg</code> <code class="o">=</code> <code class="n">MSG_ITEM_INSERTED</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno"> 7 </code>    <code class="c1">//...</code>
<code class="lineno"> 8 </code>    <code class="n">message</code><code class="o">.</code><code class="bp">Result</code> <code class="o">:=</code> <code class="nb">Ord</code><code class="p">(</code><code class="k">true</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="k">end</code>
<code class="lineno">10 </code>  <code class="k">else</code>
<code class="lineno">11 </code>    <code class="n">message</code><code class="o">.</code><code class="bp">Result</code> <code class="o">:=</code> <code class="n">DefWindowProc</code><code class="p">(</code><code class="n">FWindow</code><code class="o">,</code> <code class="n">message</code><code class="o">.</code><code class="n">Msg</code><code class="o">,</code> 
<code class="lineno">12 </code>      <code class="n">message</code><code class="o">.</code><code class="n">WParam</code><code class="o">,</code> <code class="n">message</code><code class="o">.</code><code class="n">LParam</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>Detach and destroy the observer:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FWorker</code><code class="o">.</code><code class="n">Output</code><code class="o">.</code><code class="n">ContainerSubject</code><code class="o">.</code><code class="n">Detach</code><code class="p">(</code><code class="n">FObserver</code><code class="o">,</code> <code class="n">coiNotifyOnAllInserts</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">FObserver</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">3 </code><code class="n">DSiDeallocateHWnd</code><code class="p">(</code><code class="n">FWindow</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-benchmarks">
<span class="section-number">4.8.6 </span>Benchmarks</h4>

<p>OmniThreadLibrary contains two <a href="chap12.html#demos">demos</a> that can be used to measure the performance of the lock-free structures. Bounded structures are benchmarked in the <code>10_Containers</code> demo and dynamic queue is benchmarked in the <code>32_Queue</code> demo.  </p>

<p>Following results were measured on 4-core i7-2630QM running at  2 GHz. As you can see, lock-free structures can transfer from 2,5 to 5 million messages per second.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 468px;">
    <img src="images/lowlevel----containersBench.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>



<div class="figure-wrapper center">
  <figure class="image" style="width: 90%;">
    <img src="images/lowlevel----collectionsBench.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>



<h3 id="lowlevel-eventmonitor">
<span class="section-number">4.9 </span>Event monitor</h3>

<p>While the OmniThreadLibrary is mostly a code-oriented framework, it also contains one package (stored in the <em>packages</em> subfolder) with one component (<code>TOmniEventMonitor</code>). This component supports Win32 and Win64 projects and contains some events that can be used to monitor task and thread lifecycle.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniMonitorTaskEvent</code> <code class="o">=</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="p">)</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">TOmniMonitorTaskMessageEvent</code> <code class="o">=</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno"> 4 </code>    <code class="k">const</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="n">TOmniMonitorPoolThreadEvent</code> <code class="o">=</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">pool</code><code class="o">:</code> <code class="n">IOmniThreadPool</code><code class="o">;</code> 
<code class="lineno"> 6 </code>    <code class="n">threadID</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="n">TOmniMonitorPoolWorkItemEvent</code> <code class="o">=</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">pool</code><code class="o">:</code> <code class="n">IOmniThreadPool</code><code class="o">;</code> 
<code class="lineno"> 8 </code>    <code class="n">taskID</code><code class="o">:</code> <code class="kt">int64</code><code class="p">)</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>
<code class="lineno"> 9 </code>
<code class="lineno">10 </code>  <code class="n">TOmniEventMonitor</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TComponent</code><code class="o">,</code> 
<code class="lineno">11 </code>                            <code class="n">IOmniTaskControlMonitor</code><code class="o">,</code> 
<code class="lineno">12 </code>                            <code class="n">IOmniThreadPoolMonitor</code><code class="p">)</code>
<code class="lineno">13 </code>  <code class="kp">published</code>
<code class="lineno">14 </code>    <code class="k">property</code> <code class="py">OnPoolThreadCreated</code><code class="o">:</code> <code class="n">TOmniMonitorPoolThreadEvent</code><code class="o">;</code>
<code class="lineno">15 </code>    <code class="k">property</code> <code class="py">OnPoolThreadDestroying</code><code class="o">:</code> <code class="n">TOmniMonitorPoolThreadEvent</code><code class="o">;</code>
<code class="lineno">16 </code>    <code class="k">property</code> <code class="py">OnPoolThreadKilled</code><code class="o">:</code> <code class="n">TOmniMonitorPoolThreadEvent</code><code class="o">;</code>
<code class="lineno">17 </code>    <code class="k">property</code> <code class="py">OnPoolWorkItemCompleted</code><code class="o">:</code> <code class="n">TOmniMonitorPoolWorkItemEvent</code><code class="o">;</code>
<code class="lineno">18 </code>    <code class="k">property</code> <code class="py">OnTaskMessage</code><code class="o">:</code> <code class="n">TOmniMonitorTaskMessageEvent</code><code class="o">;</code>
<code class="lineno">19 </code>    <code class="k">property</code> <code class="py">OnTaskTerminated</code><code class="o">:</code> <code class="n">TOmniMonitorTaskEvent</code><code class="o">;</code>
<code class="lineno">20 </code>    <code class="k">property</code> <code class="py">OnTaskUndeliveredMessage</code><code class="o">:</code> <code class="n">TOmniMonitorTaskMessageEvent</code><code class="o">;</code>
<code class="lineno">21 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The first four events (<code>OnPoolThread*</code>) are used to monitor thread pool events. They are described in the <a href="chap07.html#lowlevel-threadpool-monitoring">Monitoring thread pool operations</a> section.</p>

<p>The other three events are used to monitor tasks attached to this monitor. See the <a href="chap07.html#lowlevel-simpletasks-monitorwith"><code>MonitorWith</code></a> section for more information.</p>

<aside class="tip blurb">
    <p>Event monitor can be dropped on a form or created in the code (see demo <code>2_TwoWayHello</code> for an example).</p>

</aside>


<div class="page-break"></div>
<h3 id="lowlevel-simpletasks">
<span class="section-number">4.10 </span>Simple tasks</h3>

<p>This part of the book describes properties and methods of the <code>IOmniTaskControl</code> interface that are useful with all <a href="chap07.html#lowlevel-fourways">four</a> kinds of tasks. Next section, <a href="chap07.html#lowlevel-tomniworker"><code>TOmniWorker</code> tasks</a> covers only parts that are useful for <code>TOmniWorker</code>-based tasks.</p>

<h4 id="lowlevel-simpletasks-name">
<span class="section-number">4.10.1 </span>Name</h4>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">property</code> <code class="py">Name</code><code class="o">:</code> <code class="k">string</code> <code class="kp">read</code> <code class="nf">GetName</code><code class="o">;</code>
</pre></div>

</figure>

<p>The <code>Name</code> property returns the task name as set in the <a href="chap07.html#lowlevel-fourways"><code>CreateTask</code></a> call.</p>

<h4 id="lowlevel-simpletasks-uniqueid">
<span class="section-number">4.10.2 </span>UniqueID</h4>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">property</code> <code class="py">UniqueID</code><code class="o">:</code> <code class="kt">int64</code> <code class="kp">read</code> <code class="nf">GetUniqueID</code><code class="o">;</code>
</pre></div>

</figure>

<p>The <code>UniqueID</code> property returns task’s unique ID. This ID is generated automatically when a task is created and is guaranteed to be unique and greater than zero.</p>

<h4 id="lowlevel-simpletasks-parameters">
<span class="section-number">4.10.3 </span>Parameters</h4>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">SetParameter</code><code class="p">(</code><code class="k">const</code> <code class="n">paramName</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code> 
<code class="lineno">2 </code>  <code class="k">const</code> <code class="n">paramValue</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">3 </code><code class="k">function</code> <code class="nf">SetParameter</code><code class="p">(</code><code class="k">const</code> <code class="n">paramValue</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">function</code> <code class="nf">SetParameters</code><code class="p">(</code><code class="k">const</code> <code class="n">parameters</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">5 </code><code class="k">property</code> <code class="py">Param</code><code class="o">:</code> <code class="n">TOmniValueContainer</code> <code class="kp">read</code> <code class="nf">GetParam</code><code class="o">;</code>
</pre></div>

</figure>

<p>Task controller can set parameters for the task by calling the <code>SetParameter</code> and <code>SetParameters</code> methods. Parameters must be set before the task is started or scheduled (IOW, before the <code>Run</code> or <code>Schedule</code> are called).</p>

<p>Parameters can have names or they can be accessed by an index number. </p>

<p>In the former approach you have to pass in a name and a value for each parameter. You can set multiple parameters in one call by calling <code>SetParameters</code> and providing it with an array of (name, value) pairs.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">taskControl</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">MyTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">taskControl</code><code class="o">.</code><code class="n">SetParameter</code><code class="p">(</code><code class="s">'Initial value'</code><code class="o">,</code> <code class="s">'42'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">3 </code><code class="n">taskControl</code><code class="o">.</code><code class="n">SetParameters</code><code class="p">([</code><code class="s">'From'</code><code class="o">,</code> <code class="mi">0</code><code class="o">,</code> <code class="s">'To'</code><code class="o">,</code> <code class="mi">99</code><code class="p">])</code><code class="o">;</code>
</pre></div>

</figure>

<p>Both the controller and the task can access parameters through the <code>Param</code> property.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">task</code><code class="o">.</code><code class="n">Param</code><code class="p">[</code><code class="s">'Initial value'</code><code class="p">]</code> <code class="c1">// '42'</code>
<code class="lineno">2 </code><code class="n">task</code><code class="o">.</code><code class="n">Param</code><code class="p">[</code><code class="s">'From'</code><code class="p">]</code> <code class="c1">// 0</code>
<code class="lineno">3 </code><code class="n">task</code><code class="o">.</code><code class="n">Param</code><code class="p">[</code><code class="s">'To'</code><code class="p">]</code> <code class="c1">// 99</code>
</pre></div>

</figure>

<p>Another approach is to just set parameters one by one by calling <code>SetParameter</code> repeatedly.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">taskControl</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">MyTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">taskControl</code><code class="o">.</code><code class="n">SetParameter</code><code class="p">(</code><code class="s">'42'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">3 </code><code class="n">taskControl</code><code class="o">.</code><code class="n">SetParameter</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">4 </code><code class="n">taskControl</code><code class="o">.</code><code class="n">SetParameter</code><code class="p">(</code><code class="mi">99</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>In this case, a task can index the <code>Param</code> property with a <em>0</em>-based index to access parameters.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">task</code><code class="o">.</code><code class="n">Param</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="c1">// '42'</code>
<code class="lineno">2 </code><code class="n">task</code><code class="o">.</code><code class="n">Param</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="c1">// 0</code>
<code class="lineno">3 </code><code class="n">task</code><code class="o">.</code><code class="n">Param</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="c1">// 99</code>
</pre></div>

</figure>

<p>Parameter storage is implemented in the <a href="chap09.html#misc-tomnivaluecontainer"><code>TOmniValueContainer</code></a> class.</p>

<h4 id="lowlevel-simpletasks-termination">
<span class="section-number">4.10.4 </span>Termination</h4>

<p>A simple background task can function either as a <em>single-shot</em> or as a <em>long term</em> operation. In the former case there’s no need for stopping the task as it will stop by itself but in the latter case we would need to tell the task to stop at some point. </p>

<p>To stop a task, call its <code>Terminate</code> method. It will wait up to <code>maxWait_ms</code> milliseconds for the task to exit, after which it will kill the thread running the task. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">Stop</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">function</code> <code class="nf">Terminate</code><code class="p">(</code><code class="n">maxWait_ms</code><code class="o">:</code> <code class="kt">cardinal</code> <code class="o">=</code> <code class="n">INFINITE</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> 
<code class="lineno">3 </code><code class="k">function</code> <code class="nf">WaitFor</code><code class="p">(</code><code class="n">maxWait_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
</pre></div>

</figure>

<p><a href="chap07.html#lowlevel-iomnitask">Simple tasks</a> should occasionally check either the <code>Terminated</code> function (it will return <code>True</code> once the <code>Terminate</code> has been called) or the <code>TerminateEvent</code> event (it will become signalled once the <code>Terminate</code> has been called).</p>

<p>The two examples below demonstrate how to write a task that does nothing except wait to be terminated.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">TerminateTask1</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="k">while</code> <code class="n">WaitForSingleObject</code><code class="p">(</code><code class="n">task</code><code class="o">.</code><code class="n">TerminateEvent</code><code class="o">,</code> <code class="mi">1000</code><code class="p">)</code> <code class="o">=</code> <code class="n">WAIT_TIMEOUT</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno"> 4 </code>    <code class="c1">// some periodic task</code>
<code class="lineno"> 5 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno"> 6 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno"> 7 </code>
<code class="lineno"> 8 </code><code class="k">procedure</code> <code class="nf">TerminateTask2</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 9 </code><code class="k">begin</code>
<code class="lineno">10 </code>  <code class="k">while</code> <code class="k">not</code> <code class="n">task</code><code class="o">.</code><code class="n">Terminated</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">11 </code>    <code class="c1">// some periodic task</code>
<code class="lineno">12 </code>    <code class="nb">Sleep</code><code class="p">(</code><code class="mi">1000</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">14 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>If you just want to tell the task to stop (without waiting for its termination), you can call the <code>Stop</code> method. You can then check the tasks status by calling the <code>WaitFor</code> function which will wait at most <code>maxWait_ms</code> milliseconds for the task to stop and then return <code>True</code> if the task has stopped.</p>

<aside class="tip blurb">
    <p><code>WaitFor</code> is also useful if your task stops automatically or if you implement some other mechanism to stop the task.</p>

</aside>

<p>Sometimes you may want to be notified when the task has terminated. One way to do that is to attach the task to a <a href="chap07.html#lowlevel-simpletasks-monitorwith">monitor</a> and monitor the <code>OnTaskTerminated</code> event. Another is to write a termination event handler.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniOnTerminatedFunction</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">TOmniOnTerminatedFunctionSimple</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="nf">TOmniTaskTerminatedEvent</code> <code class="o">=</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="p">)</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code><code class="k">function</code> <code class="nf">OnTerminated</code><code class="p">(</code><code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniOnTerminatedFunction</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 7 </code>  <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 8 </code><code class="k">function</code> <code class="nf">OnTerminated</code><code class="p">(</code><code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniOnTerminatedFunctionSimple</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 9 </code>  <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">function</code> <code class="nf">OnTerminated</code><code class="p">(</code><code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniTaskTerminatedEvent</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">11 </code>  <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<p>The termination handler can receive a reference to the controller of the task being terminated or it can be a parameterless procedure.</p>

<p>The termination handler is called in the context of the thread that created the task.  </p>

<p>The example below shows how to write a termination handler to clear the task controller.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">NullTask</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno"> 4 </code>
<code class="lineno"> 5 </code><code class="k">var</code>
<code class="lineno"> 6 </code>  <code class="n">FTaskControl</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno"> 7 </code>
<code class="lineno"> 8 </code><code class="n">FTaskControl</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">NullTask</code><code class="p">)</code>
<code class="lineno"> 9 </code><code class="n">FTaskControl</code><code class="o">.</code><code class="n">OnTerminated</code><code class="p">(</code>
<code class="lineno">10 </code>  <code class="k">procedure</code>
<code class="lineno">11 </code>  <code class="k">begin</code>
<code class="lineno">12 </code>    <code class="nf">ShowMessage</code><code class="p">(</code><code class="s">'Background task has terminated'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code>    <code class="n">FTaskControl</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
<code class="lineno">14 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">15 </code><code class="n">FTaskControl</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
</pre></div>

</figure>

<aside class="tip blurb">
    <p>Tasks running in a thread pool can also be terminated by calling the <a href="chap07.html#lowlevel-threadpool">thread pool’s</a> <code>Cancel</code> or <code>CancelAll</code> functions which call <code>Terminate</code> internally.</p>

</aside>

<h4 id="lowlevel-simpletasks-exitcode">
<span class="section-number">4.10.5 </span>ExitCode</h4>

<p>A task can send a result to the controller by calling the <a href="chap07.html#lowlevel-iomnitask-exitstatus"><code>SetExitStatus</code></a> procedure. The task controller can access this result through the <code>ExitCode</code> and <code>ExitMessage</code> properties. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">property</code> <code class="py">ExitCode</code><code class="o">:</code> <code class="kt">integer</code> <code class="kp">read</code> <code class="nf">GetExitCode</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">property</code> <code class="py">ExitMessage</code><code class="o">:</code> <code class="k">string</code> <code class="kp">read</code> <code class="nf">GetExitMessage</code><code class="o">;</code>
</pre></div>

</figure>

<p>By default, <code>ExitCode</code> contains value <em>0</em> and <code>ExitMessage</code> contains an empty string. </p>

<p>An application can use exit codes from <em>0</em> to <em>$7FFFFFFF</em>. Exit codes from <em>$80000000</em> to <em>$FFFFFFFF</em> are reserved for internal OmniThreadLibrary use. Following exit codes (defined in the <em>OtlCommon</em> unit) have reserved meaning: </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">const</code>
<code class="lineno">2 </code>  <code class="c1">// reserved exit statuses</code>
<code class="lineno">3 </code>  <code class="n">EXIT_OK</code>                        <code class="o">=</code> <code class="mi">0</code><code class="o">;</code>
<code class="lineno">4 </code>  <code class="n">EXIT_INTERNAL</code>                  <code class="o">=</code> <code class="kt">integer</code><code class="p">(</code><code class="mh">$80000000</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code>  <code class="n">EXIT_THREADPOOL_QUEUE_TOO_LONG</code> <code class="o">=</code> <code class="n">EXIT_INTERNAL</code> <code class="o">+</code> <code class="mi">0</code><code class="o">;</code>
<code class="lineno">6 </code>  <code class="n">EXIT_THREADPOOL_STALE_TASK</code>     <code class="o">=</code> <code class="n">EXIT_INTERNAL</code> <code class="o">+</code> <code class="mi">1</code><code class="o">;</code>
<code class="lineno">7 </code>  <code class="n">EXIT_THREADPOOL_CANCELLED</code>      <code class="o">=</code> <code class="n">EXIT_INTERNAL</code> <code class="o">+</code> <code class="mi">2</code><code class="o">;</code>
<code class="lineno">8 </code>  <code class="n">EXIT_THREADPOOL_INTERNAL_ERROR</code> <code class="o">=</code> <code class="n">EXIT_INTERNAL</code> <code class="o">+</code> <code class="mi">3</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>EXIT_THREADPOOL_*</code> exit codes are described in the <a href="chap07.html#lowlevel-threadpool-exitcode">Thread pooling</a> section.</p>

<h4 id="lowlevel-simpletasks-taskexceptions">
<span class="section-number">4.10.6 </span>Exceptions</h4>

<p>If an unhandled exception is raised in the background task, it is caught by the OmniThreadLibrary code and stored in the <code>FatalException</code> property. When that happens, the background task terminates execution in a normal way (<a href="chap07.html#lowlevel-simpletasks-termination">termination handler</a> is called etc.).</p>

<p>The task controller can check the <code>FatalException</code> property to see whether an unhandled exception was raised (if not, the property will contain <code>nil</code>).</p>

<p>When the task controller is destroyed, so is the exception object. If you need to preserve the exception object, you can <em>detach</em> it from the task controller by calling the <code>DetachException</code> function.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code>  <code class="nf">DetachException</code><code class="o">:</code> <code class="n">Exception</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">property</code> <code class="py">FatalException</code><code class="o">:</code> <code class="n">Exception</code> <code class="kp">read</code> <code class="nf">GetFatalException</code><code class="o">;</code>
</pre></div>

</figure>

<p>See also <a href="chap12.html#demos">demo</a> <code>13_Exceptions</code>.</p>

<h4 id="lowlevel-simpletasks-communication">
<span class="section-number">4.10.7 </span>Sending messages to a task</h4>

<p>The <a href="chap07.html#lowlevel-communication">Communication subsystem</a> section explains how the communication subsystem works and what methods can be used in your program. This part of the book will show a practical example of sending messages to a simple (not <code>TOmniWorker</code>-based) task. This example is based on the <code>2_TwoWayHello</code> <a href="chap12.html#demos">demo</a>.</p>

<p>The task is created in a standard manner.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FHelloTask</code> <code class="o">:=</code>
<code class="lineno">2 </code>  <code class="n">OmniEventMonitor1</code><code class="o">.</code><code class="n">Monitor</code><code class="p">(</code><code class="n">CreateTask</code><code class="p">(</code><code class="n">RunHello</code><code class="o">,</code> <code class="s">'Hello'</code><code class="p">))</code>
<code class="lineno">3 </code>    <code class="o">.</code><code class="n">SetParameter</code><code class="p">(</code><code class="s">'Message'</code><code class="o">,</code> <code class="s">'Initial message'</code><code class="p">)</code>
<code class="lineno">4 </code>    <code class="o">.</code><code class="n">Run</code><code class="o">;</code>
</pre></div>

</figure>

<p>A message is sent to the task through the <code>Comm</code> property.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">const</code>
<code class="lineno">2 </code>  <code class="n">MSG_CHANGE_MESSAGE</code> <code class="o">=</code> <code class="mi">1</code><code class="o">;</code>
<code class="lineno">3 </code>
<code class="lineno">4 </code><code class="n">FHelloTask</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="n">MSG_CHANGE_MESSAGE</code><code class="o">,</code> <code class="s">'New message'</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>The task (<code>RunHello</code> procedure) must implement a loop which will wait on two events – <code>task.TerminateEvent</code> (to know when to stop) and <code>task.Comm.NewMessageEvent</code> (to know when a new message arrived). When the latter event is signalled, a message can be read from the message queue.</p>

<p>You should always read and process all waiting messages, not just one.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">RunHello</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">msg</code>    <code class="o">:</code> <code class="k">string</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">msgData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="n">msgID</code>  <code class="o">:</code> <code class="kt">word</code><code class="o">;</code>
<code class="lineno"> 6 </code><code class="k">begin</code>
<code class="lineno"> 7 </code>  <code class="n">msg</code> <code class="o">:=</code> <code class="n">task</code><code class="o">.</code><code class="n">Param</code><code class="p">[</code><code class="s">'Message'</code><code class="p">]</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="k">repeat</code>
<code class="lineno"> 9 </code>    <code class="k">case</code> <code class="n">DSiWaitForTwoObjects</code><code class="p">(</code><code class="n">task</code><code class="o">.</code><code class="n">TerminateEvent</code><code class="o">,</code> <code class="n">task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">NewMessageEvent</code><code class="o">,</code>
<code class="lineno">10 </code>           <code class="k">false</code><code class="o">,</code> <code class="n">task</code><code class="o">.</code><code class="n">Param</code><code class="p">[</code><code class="s">'Delay'</code><code class="p">])</code> 
<code class="lineno">11 </code>    <code class="k">of</code>
<code class="lineno">12 </code>      <code class="n">WAIT_OBJECT_1</code><code class="o">:</code>
<code class="lineno">13 </code>        <code class="k">begin</code>
<code class="lineno">14 </code>          <code class="k">while</code> <code class="n">task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Receive</code><code class="p">(</code><code class="n">msgID</code><code class="o">,</code> <code class="n">msgData</code><code class="p">)</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">15 </code>            <code class="k">if</code> <code class="n">msgID</code> <code class="o">=</code> <code class="n">MSG_CHANGE_MESSAGE</code> <code class="k">then</code>
<code class="lineno">16 </code>              <code class="n">msg</code> <code class="o">:=</code> <code class="n">msgData</code><code class="o">;</code>
<code class="lineno">17 </code>          <code class="k">end</code><code class="o">;</code>
<code class="lineno">18 </code>        <code class="k">end</code><code class="o">;</code>
<code class="lineno">19 </code>      <code class="n">WAIT_TIMEOUT</code><code class="o">:</code>
<code class="lineno">20 </code>        <code class="n">task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="mi">0</code><code class="o">,</code> <code class="n">msg</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">21 </code>      <code class="k">else</code>
<code class="lineno">22 </code>        <code class="k">break</code><code class="o">;</code> <code class="c1">//repeat</code>
<code class="lineno">23 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">24 </code>  <code class="k">until</code> <code class="k">false</code><code class="o">;</code>
<code class="lineno">25 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>This code uses <code>DSiWaitForTwoObjects</code> to wait on two events. That function is just a thin wrapper around Windows’ <code>WaitForMultipleObjects</code><sup id="fnref-st-msdn-wfmo"><a href="chap17.html#fn-st-msdn-wfmo" rel="footnote">5</a></sup>.</p>

<h4 id="lowlevel-simpletasks-receiving">
<span class="section-number">4.10.8 </span>Receiving messages from a task</h4>

<p>Messages sent from a task can be received and processed in many ways. They can all be used with both simple and <code>TOmniWorker</code> tasks.</p>

<p>First approach is to use an <a href="chap07.html#lowlevel-simpletasks-monitorwith">event monitor</a> to process messages.</p>

<p>Another way is to call an <code>OnMessage</code> method providing an event handler which can be a method or an anonymous method.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">type</code>
<code class="lineno">2 </code>  <code class="n">TOmniTaskMessageEvent</code> <code class="o">=</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> 
<code class="lineno">3 </code>    <code class="k">const</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>
<code class="lineno">4 </code>  <code class="n">TOmniOnMessageFunction</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> 
<code class="lineno">5 </code>    <code class="k">const</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">6 </code>
<code class="lineno">7 </code><code class="k">function</code> <code class="nf">OnMessage</code><code class="p">(</code><code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniTaskMessageEvent</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">8 </code><code class="k">function</code> <code class="nf">OnMessage</code><code class="p">(</code><code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniOnMessageFunction</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">task</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">MyTask</code><code class="p">)</code><code class="o">.</code><code class="n">OnMessage</code><code class="p">(</code>
<code class="lineno">2 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="k">const</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code>
<code class="lineno">3 </code>  <code class="k">begin</code>
<code class="lineno">4 </code>    <code class="n">ShowMessage</code><code class="p">(</code><code class="s">'Received message with ID '</code> <code class="o">+</code> <code class="nb">IntToStr</code><code class="p">(</code><code class="n">msg</code><code class="o">.</code><code class="n">MsgID</code><code class="p">))</code><code class="o">;</code>
<code class="lineno">5 </code>  <code class="k">end</code><code class="p">)</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>  
</pre></div>

</figure>

<p>You can also set multiple message handlers, each handling a specific message ID.  </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniTaskMessageEvent</code> <code class="o">=</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> 
<code class="lineno"> 3 </code>    <code class="k">const</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">TOmniOnMessageFunction</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> 
<code class="lineno"> 5 </code>    <code class="k">const</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 6 </code>
<code class="lineno"> 7 </code><code class="k">function</code> <code class="nf">OnMessage</code><code class="p">(</code><code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> <code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniTaskMessageEvent</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 8 </code>  <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 9 </code><code class="k">function</code> <code class="nf">OnMessage</code><code class="p">(</code><code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> <code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniOnMessageFunction</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">10 </code>  <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">task</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">MyTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="n">task</code><code class="o">.</code><code class="n">OnMessage</code><code class="p">(</code>
<code class="lineno"> 3 </code>  <code class="n">MSG_FIRST</code><code class="o">,</code>
<code class="lineno"> 4 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="k">const</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code>
<code class="lineno"> 5 </code>  <code class="k">begin</code>
<code class="lineno"> 6 </code>    <code class="n">ShowMessage</code><code class="p">(</code><code class="s">'Received MSG_FIRST'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>  
<code class="lineno"> 8 </code><code class="n">task</code><code class="o">.</code><code class="n">OnMessage</code><code class="p">(</code>
<code class="lineno"> 9 </code>  <code class="n">MSG_SECOND</code><code class="o">,</code>
<code class="lineno">10 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="k">const</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code>
<code class="lineno">11 </code>  <code class="k">begin</code>
<code class="lineno">12 </code>    <code class="n">ShowMessage</code><code class="p">(</code><code class="s">'Received MSG_SECOND'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>  
<code class="lineno">14 </code><code class="n">task</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
</pre></div>

</figure>

<p>The OmniThreadLibrary allows you to combine both approaches, providing specific message handlers for some messages and generic message handlers for all the rest.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">task</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">MyTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">task</code><code class="o">.</code><code class="n">OnMessage</code><code class="p">(</code><code class="n">MSG_FIRST</code><code class="o">,</code> <code class="n">HandleFirstMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">3 </code><code class="n">task</code><code class="o">.</code><code class="n">OnMessage</code><code class="p">(</code><code class="n">MSG_SECOND</code><code class="o">,</code> <code class="n">HandleSecondMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">4 </code><code class="n">task</code><code class="o">.</code><code class="n">OnMessage</code><code class="p">(</code><code class="n">HandleOtherMessages</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code><code class="n">task</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
</pre></div>

</figure>

<p>A message handler can also be provided through a <code>TOmniMessageExec</code> class, which is defined in the <em>OtlTaskControl</em> unit. This class can wrap any message handler type and is mainly intended for internal use.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">OnMessage</code><code class="p">(</code><code class="n">msgID</code><code class="o">:</code> <code class="kt">word</code><code class="o">;</code> <code class="n">eventHandler</code><code class="o">:</code> <code class="n">TOmniMessageExec</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno">2 </code>  <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<p>The last possibility is to dispatch all messages to an object which implements Delphi’s <code>Dispatch</code> mechanism, for example, to a form. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">OnMessage</code><code class="p">(</code><code class="n">eventDispatcher</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<p>An object should then define message handlers by using the Delphi’s <code>message</code> procedures. Each should accept a <code>var TOmniMessage</code> parameter.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">const</code>
<code class="lineno"> 2 </code>  <code class="n">WM_FIRST_MSG</code> <code class="o">=</code> <code class="n">WM_USER</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">WM_SECOND_MSG</code> <code class="o">=</code> <code class="n">WM_USER</code> <code class="o">+</code> <code class="mi">1</code><code class="o">;</code>
<code class="lineno"> 4 </code>  
<code class="lineno"> 5 </code><code class="k">type</code>
<code class="lineno"> 6 </code>  <code class="n">TForm1</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TForm</code><code class="p">)</code>
<code class="lineno"> 7 </code>  <code class="kp">public</code>
<code class="lineno"> 8 </code>    <code class="n">FTask</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">procedure</code> <code class="nf">StartTask</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">procedure</code> <code class="nf">HandleFirstMessage</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code> <code class="n">message</code> <code class="n">WM_FIRST_MSG</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">procedure</code> <code class="nf">HandleSecondMessage</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code> <code class="n">message</code> <code class="n">WM_SECOND_MSG</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="k">end</code><code class="o">;</code>                  
<code class="lineno">13 </code>  
<code class="lineno">14 </code><code class="k">procedure</code> <code class="nc">TForm1</code><code class="o">.</code><code class="nf">StartTask</code><code class="o">;</code>
<code class="lineno">15 </code><code class="k">begin</code>
<code class="lineno">16 </code>  <code class="n">FTask</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">MyTask</code><code class="p">)</code><code class="o">.</code><code class="n">OnMessage</code><code class="p">(</code><code class="k">Self</code><code class="p">)</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>  
<code class="lineno">17 </code><code class="k">end</code><code class="o">;</code>                                                         
</pre></div>

</figure>

<aside class="tip blurb">
    <p>Messages sent to the main thread should have message ID larger or equal than <code>WM_USER</code>.</p>

</aside>

<h4 id="lowlevel-simpletasks-chainto">
<span class="section-number">4.10.9 </span>ChainTo</h4>

<p>Tasks can be chained together so that next task is started when the previous terminates. This is achieved by the <code>ChainTo</code> method.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">ChainTo</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> 
<code class="lineno">2 </code>  <code class="n">ignoreErrors</code><code class="o">:</code> <code class="kt">boolean</code> <code class="o">=</code> <code class="k">false</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
</pre></div>

</figure>

<p>The code below starts the <code>task1</code> task. When it is finished, OmniThreadLibrary immediately starts <code>task2</code>. Note that in this case you should not start the second task explicitly.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">task2</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">SecondTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">task1</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">FirstTask</code><code class="p">)</code><code class="o">.</code><code class="n">ChainTo</code><code class="p">(</code><code class="n">task2</code><code class="p">)</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
</pre></div>

</figure>

<p>If <code>ignoreErrors</code> is left at default (<code>False</code>), the second task is only started if first task’s <a href="chap07.html#lowlevel-simpletasks-exitcode"><code>ExitCode</code></a> is <code>EXIT_OK</code> (<em>0</em>). If <code>ignoreErrors</code> is set to <code>True</code>, the second task is started even if <code>ExitCode</code> of the first task is not <em>0</em>.</p>

<h4 id="lowlevel-simpletasks-joinleave">
<span class="section-number">4.10.10 </span>Join / Leave</h4>

<p>Calling <code>Join</code> adds the task to a <a href="chap07.html#lowlevel-taskgroup">task group</a>. </p>

<p>Calling <code>Leave</code> removes the task from a group. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">Join</code><code class="p">(</code><code class="k">const</code> <code class="n">group</code><code class="o">:</code> <code class="n">IOmniTaskGroup</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">function</code> <code class="nf">Leave</code><code class="p">(</code><code class="k">const</code> <code class="n">group</code><code class="o">:</code> <code class="n">IOmniTaskGroup</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="lowlevel-simpletasks-monitorwith">
<span class="section-number">4.10.11 </span>MonitorWith / RemoveMonitor</h4>

<p>Calling <code>MonitorWith</code> attaches the task to an <a href="chap07.html#lowlevel-eventmonitor">event monitor</a>. Calling <code>RemoveMonitor</code> removes the task from the monitor.  </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">MonitorWith</code><code class="p">(</code><code class="k">const</code> <code class="n">monitor</code><code class="o">:</code> <code class="n">IOmniTaskControlMonitor</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">function</code> <code class="nf">RemoveMonitor</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
</pre></div>

</figure>

<p>Calling <code>task.MonitorWith(otlMonitor)</code> is equivalent to calling <code>otlMonitor.Monitor(task)</code>. Calling <code>task.RemoveMonitor</code> is equivalent to calling <code>otlMonitor.Detach(task)</code>.</p>

<aside class="information blurb">
    <p>A task is automatically removed from the associated monitor when the task is destroyed.</p>

</aside>

<p>Following three monitor events are useful for monitoring tasks. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniMonitorTaskEvent</code> <code class="o">=</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="p">)</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">TOmniMonitorTaskMessageEvent</code> <code class="o">=</code> <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno"> 4 </code>    <code class="k">const</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code>  <code class="n">TOmniEventMonitor</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TComponent</code><code class="o">,</code> 
<code class="lineno"> 7 </code>                            <code class="n">IOmniTaskControlMonitor</code><code class="o">,</code>
<code class="lineno"> 8 </code>                            <code class="n">IOmniThreadPoolMonitor</code><code class="p">)</code>
<code class="lineno"> 9 </code>  <code class="kp">public</code>
<code class="lineno">10 </code>    <code class="k">property</code> <code class="py">OnTaskMessage</code><code class="o">:</code> <code class="n">TOmniMonitorTaskMessageEvent</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">property</code> <code class="py">OnTaskTerminated</code><code class="o">:</code> <code class="n">TOmniMonitorTaskEvent</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">property</code> <code class="py">OnTaskUndeliveredMessage</code><code class="o">:</code> <code class="n">TOmniMonitorTaskMessageEvent</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<ul>
  <li>
<code>OnTaskMessage</code>
    <p>This event is called whenever a message from the task is received. The <code>msg</code> parameter contains the message.</p>
  </li>
  <li>
<code>OnTaskTerminated</code>
    <p>This event is called when a task terminates.</p>
  </li>
  <li>
<code>OnTaskUndeliveredMessage</code>
    <p>If a task is terminated with unprocessed messages in its input queue, this event is called for each message.</p>
  </li>
</ul>

<aside class="tip blurb">
    <p><code>OnTaskMessage</code> is called for messages sent <em>from</em> the task. <code>OnTaskUndeliveredMessage</code> is called for messages sent <em>to</em> the task.</p>

</aside>

<h4 id="lowlevel-simpletasks-enforced">
<span class="section-number">4.10.12 </span>Enforced</h4>

<p>The <code>Enforced</code> method regulates behaviour in a very specific situation – when a task is terminated before it even starts execution.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">Enforced</code><code class="p">(</code><code class="n">forceExecution</code><code class="o">:</code> <code class="kt">boolean</code> <code class="o">=</code> <code class="k">true</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
</pre></div>

</figure>

<p>In the default scenario, a task is always started when the <code>Run</code> is called, even if it was terminated before that. While the task would typically immediately exit, it can still do some processing. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">ShortLivedTask</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="c1">// this line will be executed</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">5 </code>
<code class="lineno">6 </code><code class="n">task</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">ShortLivedTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">7 </code><code class="n">task</code><code class="o">.</code><code class="n">Terminate</code><code class="o">;</code>
<code class="lineno">8 </code><code class="n">task</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
</pre></div>

</figure>

<p>If <code>Enforced(False)</code> is called, a terminated process won’t be started at all.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">UnstartedTask</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="c1">// this line will never be executed</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">5 </code>
<code class="lineno">6 </code><code class="n">task</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">UnstartedTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">7 </code><code class="n">task</code><code class="o">.</code><code class="n">Enforced</code><code class="p">(</code><code class="k">false</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">8 </code><code class="n">task</code><code class="o">.</code><code class="n">Terminate</code><code class="o">;</code>
<code class="lineno">9 </code><code class="n">task</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
</pre></div>

</figure>

<p>This method also regulates behaviour of tasks that were scheduled to the <a href="chap07.html#lowlevel-threadpool">thread pool</a>.</p>

<h4 id="lowlevel-simpletasks-unobserved">
<span class="section-number">4.10.13 </span>Unobserved</h4>

<p>Calling <code>Unobserved</code> adds an implicit owner to the task so that you don’t have to store returned <code>IOmniTaskController</code> interface in a variable or a field.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">Unobserved</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
</pre></div>

</figure>

<blockquote>
  <p>See the <a href="chap07.html#lowlevel-taskControllerOwner">Task controller needs an owner</a> section for an example.</p>
</blockquote>

<h4 id="lowlevel-simpletasks-cancellationtoken">
<span class="section-number">4.10.14 </span>Cancellation token / CancelWith</h4>

<p>OmniThreadLibrary implements the concept of a <a href="chap08.html#synch-cancellationtoken">cancellation token</a>, which is a synchronisation mechanism that allows multiple tasks to be cancelled with a single command.</p>

<p>Cancellation must be cooperative, i.e. the task must watch its <code>CancellationToken</code> property and exit when it becomes signalled.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">CancelWith</code><code class="p">(</code><code class="k">const</code> <code class="n">token</code><code class="o">:</code> <code class="n">IOmniCancellationToken</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">2 </code>
<code class="lineno">3 </code><code class="k">property</code> <code class="py">CancellationToken</code><code class="o">:</code> <code class="n">IOmniCancellationToken</code> <code class="kp">read</code> <code class="nf">GetCancellationToken</code><code class="o">;</code>
</pre></div>

</figure>

<aside class="tip blurb">
    <p>When using <a href="chap07.html#lowlevel-tomniworker"><code>TOmniWorker</code> tasks</a>, the <a href="chap07.html#lowlevel-tomniworker-terminateWhen"><code>TerminateWhen</code></a> mechanism may be a better solution.</p>

</aside>

<h4 id="lowlevel-simpletasks-tasklock">
<span class="section-number">4.10.15 </span>Lock / WithLock</h4>

<p>Sometimes you have to establish a common synchronisation primitive between the main program and one (or more) background tasks. In such case, the <code>WithLock</code> method can be called to assign a synchronisation primitive (such as a critical section) to the task’s <a href="chap07.html#lowlevel-iomnitask-lock"><code>Lock</code></a> property.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">WithLock</code><code class="p">(</code><code class="k">const</code> <code class="n">lock</code><code class="o">:</code> <code class="n">TSynchroObject</code><code class="o">;</code> 
<code class="lineno">2 </code>  <code class="n">autoDestroyLock</code><code class="o">:</code> <code class="kt">boolean</code> <code class="o">=</code> <code class="k">true</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">3 </code><code class="k">function</code> <code class="nf">WithLock</code><code class="p">(</code><code class="k">const</code> <code class="n">lock</code><code class="o">:</code> <code class="n">IOmniCriticalSection</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">4 </code>
<code class="lineno">5 </code><code class="k">property</code> <code class="py">Lock</code><code class="o">:</code> <code class="n">TSynchroObject</code> <code class="kp">read</code> <code class="nf">GetLock</code><code class="o">;</code>
</pre></div>

</figure>

<p>If you pass in a <code>TSynchroObject</code> descendant, the default behaviour is to automatically destroy this object when the task is destroyed. In case you are passing the same synchronisation object to two or more tasks, this is not a good idea and second <code>WithLock</code> parameter should be set to <code>False</code>. Alternatively, you can use an <a href="chap08.html#synch-criticalsections-iomnicriticalsection"><code>IOmniCriticalSection</code></a> which will destroy itself automatically when it is no longer used.</p>

<p>
  <em>See also <a href="chap12.html#demos">demo</a> <code>12_Lock</code>.</em>
</p>

<h4 id="lowlevel-simpletasks-counter">
<span class="section-number">4.10.16 </span>WithCounter</h4>

<p>Similar to the <code>Lock</code> mechanism, <code>WithCounter</code> connects a task with a thread-safe counter, <a href="chap09.html#misc-tomnicounter"><code>IOmniCounter</code></a>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">WithCounter</code><code class="p">(</code><code class="k">const</code> <code class="n">counter</code><code class="o">:</code> <code class="n">IOmniCounter</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
</pre></div>

</figure>

<p>
  <em>See also <a href="chap12.html#demos">demo</a> <code>14_TerminateWhen</code>.</em>
</p>

<h4 id="lowlevel-simpletasks-setpriority">
<span class="section-number">4.10.17 </span>SetPriority</h4>

<p>By calling <code>SetPriority</code> you can specify the priority of the thread that will execute the task. By default the priority is set to <code>tpNormal</code> which corresponds to Windows priority level <code>THREAD_PRIORITY_NORMAL</code>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">type</code>
<code class="lineno">2 </code>  <code class="n">TOTLThreadPriority</code> <code class="o">=</code> <code class="p">(</code><code class="n">tpIdle</code><code class="o">,</code> <code class="n">tpLowest</code><code class="o">,</code> <code class="n">tpBelowNormal</code><code class="o">,</code> <code class="n">tpNormal</code><code class="o">,</code> 
<code class="lineno">3 </code>    <code class="n">tpAboveNormal</code><code class="o">,</code> <code class="n">tpHighest</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">4 </code>
<code class="lineno">5 </code><code class="k">function</code> <code class="nf">SetPriority</code><code class="p">(</code><code class="n">threadPriority</code><code class="o">:</code> <code class="n">TOTLThreadPriority</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-setqueuesize">
<span class="section-number">4.10.18 </span>SetQueueSize</h4>

<p>The <code>SetQueueSize</code> sets the length for <a href="chap07.html#lowlevel-communication">message queues</a>. By default, message queue length is set to <code>1000</code> messages.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code>  <code class="nf">SetQueueSize</code><code class="p">(</code><code class="n">numMessages</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
</pre></div>

</figure>

<p>This method must be called before the communication channel is used for the first time. The safest way is to call it before the task is run or scheduled.</p>


<div class="page-break"></div>
<h3 id="lowlevel-tomniworker">
<span class="section-number">4.11 </span>TOmniWorker tasks</h3>

<p>In the heart of every sufficiently complicated thread code there lies a complicated loop similar to the one below.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">handles</code><code class="o">:</code> <code class="k">array</code> <code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">3</code><code class="p">]</code> <code class="k">of</code> <code class="kt">THandle</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">waitRes</code><code class="o">:</code> <code class="kt">DWORD</code><code class="o">;</code>
<code class="lineno"> 4 </code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="n">handles</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">:=</code> <code class="n">TerminateEvent</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="n">handles</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">:=</code> <code class="n">FWakeUp</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="n">handles</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="o">:=</code> <code class="n">FResetFilters</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="n">handles</code><code class="p">[</code><code class="mi">3</code><code class="p">]</code> <code class="o">:=</code> <code class="n">FResetFullStream</code><code class="o">;</code>
<code class="lineno">10 </code>  
<code class="lineno">11 </code>  <code class="k">repeat</code>
<code class="lineno">12 </code>    <code class="n">waitRes</code> <code class="o">:=</code> <code class="n">WaitForMultipleObjects</code><code class="p">(</code><code class="n">numHandles</code><code class="o">,</code> <code class="mi">4</code><code class="o">,</code> <code class="n">INFINITE</code><code class="o">,</code> <code class="k">false</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code>    <code class="k">case</code> <code class="n">waitRes</code> <code class="k">of</code><code class="o">:</code>
<code class="lineno">14 </code>      <code class="n">WAIT_OBJECT_0</code><code class="o">:</code> 
<code class="lineno">15 </code>        <code class="k">Exit</code><code class="o">;</code>
<code class="lineno">16 </code>      <code class="n">WAIT_OBJECT_0</code><code class="o">+</code><code class="mi">1</code><code class="o">:</code>  
<code class="lineno">17 </code>        <code class="n">ProcessIncomingData</code><code class="o">;</code>
<code class="lineno">18 </code>      <code class="n">WAIT_OBJECT_0</code><code class="o">+</code><code class="mi">2</code><code class="o">:</code> 
<code class="lineno">19 </code>        <code class="n">ResetFilters</code><code class="o">;</code>
<code class="lineno">20 </code>      <code class="n">WAIT_OBJECT_0</code><code class="o">+</code><code class="mi">3</code><code class="o">:</code> 
<code class="lineno">21 </code>        <code class="n">ResetStream</code><code class="o">;</code>
<code class="lineno">22 </code>      <code class="k">else</code><code class="o">:</code> <code class="k">Exit</code><code class="o">;</code> <code class="c1">//WAIT_TIMEOUT, WAIT_ABANDONED</code>
<code class="lineno">23 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">24 </code>  <code class="k">until</code> <code class="k">false</code><code class="o">;</code>
<code class="lineno">25 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>You can write OmniThreadLibrary-based code in the same manner (see <a href="chap07.html#lowlevel-simpletasks">simple tasks</a>) but the library also offers a much better way. Write the task as a descendant of the <code>TOmniWorker</code> class and OmniThreadLibrary will implement the main loop for you.</p>

<p>Every <code>TOmniWorker</code>-type task executes an internal loop which can be represented by the following pseudo-code. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">if</code> <code class="k">not</code> <code class="nb">Initialize</code> <code class="k">then</code>
<code class="lineno"> 2 </code>  <code class="k">Exit</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="k">repeat</code>
<code class="lineno"> 4 </code>  <code class="n">waitRes</code> <code class="o">:=</code> <code class="n">WaitForEvent</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="k">if</code> <code class="n">waitRes</code> <code class="o">=</code> <code class="n">TerminateEvent</code> <code class="k">then</code>
<code class="lineno"> 6 </code>    <code class="k">break</code>
<code class="lineno"> 7 </code>  <code class="k">else</code>
<code class="lineno"> 8 </code>    <code class="n">DispatchEvent</code><code class="p">(</code><code class="n">waitRes</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 9 </code><code class="k">until</code> <code class="k">false</code><code class="o">;</code>
<code class="lineno">10 </code><code class="n">Cleanup</code><code class="o">;</code> 
</pre></div>

</figure>

<p id="lowlevel-tomniworker-initialization">Firstly, the <code>Initialize</code> function is called. In the <code>TOmniWorker</code> class it does nothing, just returns <code>True</code>. You can override it with your own function which does task-specific initialization. It can optionally return <code>False</code> which signifies that the task should not be executed at all.</p>

<p>For compatibility with future OmniThreadLibrary versions which may return <code>False</code> from the base <code>Initialize</code> under some conditions, it is recommended to write overridden <code>Initialize</code> in the following form:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">Initialize</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="bp">Result</code> <code class="o">:=</code> <code class="k">inherited</code> <code class="nb">Initialize</code><code class="o">;</code>
<code class="lineno">4 </code>  <code class="k">if</code> <code class="k">not</code> <code class="bp">Result</code> <code class="k">then</code>
<code class="lineno">5 </code>    <code class="k">Exit</code><code class="o">;</code>
<code class="lineno">6 </code>  <code class="c1">// do the rest of initialization here</code>
<code class="lineno">7 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>Next, the <em>wait and dispatch</em> loop is run. It will watch for following events:</p>

<ul>
  <li>
<a href="chap07.html#lowlevel-simpletasks-termination"><code>TerminateEvent</code></a>,</li>
  <li>Other termination events (<a href="chap07.html#lowlevel-tomniworker-terminateWhen"><code>TerminateWhen</code></a>),</li>
  <li>
<a href="chap07.html#lowlevel-tomniworker-communication">New messages</a> from the task controller,</li>
  <li>New messages from other tasks (<a href="chap07.html#lowlevel-tomniworker-registercomm"><code>RegisterComm</code></a>),</li>
  <li>Windows synchronization objects (<a href="chap07.html#lowlevel-iomnitask-registerwaitobject"><code>RegisterWaitObject</code></a>),</li>
  <li>Timers (<a href="chap07.html#lowlevel-tomniworker-timers"><code>SetTimer</code></a>),</li>
  <li>Windows messages (<a href="chap07.html#lowlevel-tomniworker-msgwait"><code>MsgWait</code></a>, <a href="chap07.html#lowlevel-tomniworker-msgwait"><code>Alertable</code></a>).</li>
</ul>

<aside class="tip blurb">
    <p>In versions before <sup>[3.04]</sup> you could only register 57 termination events, additional communication channels, external events and timers (all together). This limitation is no longer present in release <sup>[3.04]</sup> and newer.</p>

</aside>

<p>When an event occurs, an appropriate action is executed. For example, messages are dispatched (using the Delphi’s <code>Dispatch</code> mechanism) to the task so you can use <code>message</code> methods for message processing (see <a href="chap07.html#lowlevel-tomniworker-communication">Receiving messages</a> below).</p>

<p>When a <code>TerminateEvent</code> is signalled (which happens when controller’s <a href="chap07.html#lowlevel-simpletasks-termination"><code>Terminate</code></a> method is called) or when one of events passed in the <code>TerminateWhen</code> method is signalled, the task’s main loop exits. The <code>Cleanup</code> method is then called. In the base class, <code>Cleanup</code> is implemented as an empty method; override it to implement the task-specific clean-up.</p>

<aside class="tip blurb">
    <p><code>TOmniWorker</code> tasks are not really suitable for <em>single shot</em> events. Use <a href="chap07.html#lowlevel-simpletasks">simple tasks</a> instead.</p>

</aside>

<h4 id="lowlevel-tomniworker-waitforinit">
<span class="section-number">4.11.1 </span>WaitForInit</h4>

<p>If the owner of the task wants to wait until the <code>Initialize</code> method has completed its work, it can call the <code>WaitForInit</code> method.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">WaitForInit</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="lowlevel-tomniworker-task">
<span class="section-number">4.11.2 </span>Task</h4>

<p>The <code>TOmniWorker</code> class implements a public property <code>Task</code> returning the task’s management interface <a href="chap07.html#lowlevel-iomnitask"><code>IOmniTask</code></a>. You can use it to access any task-specific property, such as the communication interface (<code>Comm</code>).</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">property</code> <code class="py">Task</code><code class="o">:</code> <code class="n">IOmniTask</code> <code class="kp">read</code> <code class="nf">GetTask</code> <code class="kp">write</code> <code class="nf">SetTask</code><code class="o">;</code>
</pre></div>

</figure>

<p>This property is available in the <code>Initialize</code> and <code>Cleanup</code> methods but not in the constructor and destructor.</p>

<h4 id="lowlevel-tomniworker-communication">
<span class="section-number">4.11.3 </span>Receiving messages</h4>

<p>Messages sent from the controller or from <a href="chap07.html#lowlevel-tomniworker-registercomm">other tasks</a> are passed to the Delphi’s <code>Dispatch</code> mechanism. For each message we want to process we must therefore write a <code>message</code> method. </p>

<p>To demonstrate this approach, here is a short example extracted from the <code>5_TwoWayHello_without_loop</code> <a href="chap12.html#demos">demo</a>.</p>

<p>The task is implemented as an instance of the <code>TAsyncHello</code> class which is derived from the <code>TOmniWorker</code>. The task will do some initialization in the <code>Initialize</code> method. It will then handle two messages - <code>MSG_CHANGE_MESSAGE</code> and <code>MSG_SEND_MESSAGE</code>.                         </p>

<p>When the <code>MSG_CHANGE_MESSAGE</code> is received, the worker will change the internal message text which was initially assigned in <code>Initialize</code>. When the <code>MSG_SEND_MESSAGE</code> is received, the worker will send this message back to the owner.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">const</code>
<code class="lineno"> 2 </code>  <code class="n">MSG_CHANGE_MESSAGE</code> <code class="o">=</code> <code class="mi">1</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">MSG_SEND_MESSAGE</code>   <code class="o">=</code> <code class="mi">2</code><code class="o">;</code>
<code class="lineno"> 4 </code>
<code class="lineno"> 5 </code><code class="k">type</code>
<code class="lineno"> 6 </code>  <code class="n">TAsyncHello</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TOmniWorker</code><code class="p">)</code>
<code class="lineno"> 7 </code>  <code class="n">strict</code> <code class="kp">private</code>
<code class="lineno"> 8 </code>    <code class="n">aiMessage</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="kp">public</code>
<code class="lineno">10 </code>    <code class="k">function</code>  <code class="nf">Initialize</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> <code class="kp">override</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">procedure</code> <code class="nf">OMChangeMessage</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code> 
<code class="lineno">12 </code>      <code class="n">message</code> <code class="n">MSG_CHANGE_MESSAGE</code><code class="o">;</code>
<code class="lineno">13 </code>    <code class="k">procedure</code> <code class="nf">OMSendMessage</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code> 
<code class="lineno">14 </code>      <code class="n">message</code> <code class="n">MSG_SEND_MESSAGE</code><code class="o">;</code>
<code class="lineno">15 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>We can write those two message handlers identical to the way we write Windows message handlers. Message IDs can take any value from <em>0</em> to <em>$FFFE</em>. Message ID <em>$FFFF</em> is reserved for internal purposes.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">function</code> <code class="nc">TAsyncHello</code><code class="o">.</code><code class="nf">Initialize</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="n">aiMessage</code> <code class="o">:=</code> <code class="n">Task</code><code class="o">.</code><code class="n">ParamByName</code><code class="p">[</code><code class="s">'Message'</code><code class="p">]</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="bp">Result</code> <code class="o">:=</code> <code class="k">true</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno"> 6 </code>
<code class="lineno"> 7 </code><code class="k">procedure</code> <code class="nc">TAsyncHello</code><code class="o">.</code><code class="nf">OMChangeMessage</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 8 </code><code class="k">begin</code>
<code class="lineno"> 9 </code>  <code class="n">aiMessage</code> <code class="o">:=</code> <code class="n">msg</code><code class="o">.</code><code class="n">MsgData</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">11 </code>
<code class="lineno">12 </code><code class="k">procedure</code> <code class="nc">TAsyncHello</code><code class="o">.</code><code class="nf">OMSendMessage</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code><code class="k">begin</code>
<code class="lineno">14 </code>  <code class="n">Task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="mi">0</code><code class="o">,</code> <code class="n">aiMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">15 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="lowlevel-tomniworker-registercomm">
<span class="section-number">4.11.4 </span>RegisterComm</h4>

<p>You can send and receive messages directly from one task to another. To do that, you should firstly create a <a href="chap09.html#misc-tOmniTwoWayChannel">two-way communication channel</a> and pass each endpoint of this channel to one of the tasks. A task should then call <code>RegisterComm</code> function to start listening on an endpoint. To stop listening, call the <code>UnregisterComm</code> function.</p>

<p>Received messages are dispatched in the same way as messages received from the task controller.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">RegisterComm</code><code class="p">(</code><code class="k">const</code> <code class="n">comm</code><code class="o">:</code> <code class="n">IOmniCommunicationEndpoint</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">procedure</code> <code class="nf">UnregisterComm</code><code class="p">(</code><code class="k">const</code> <code class="n">comm</code><code class="o">:</code> <code class="n">IOmniCommunicationEndpoint</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>The <code>8_RegisterComm</code> <a href="chap12.html#demos">demo</a> demonstrates this.</p>

<p>A two-way channel (<code>FCommChannel</code>) is created with space for <em>1024</em> messages. Each of its endpoints is passed to one instance of the <code>TCommTester</code> class and each instance is started as its own task.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmTestRegisterComm</code><code class="o">.</code><code class="nf">FormCreate</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="n">FCommChannel</code> <code class="o">:=</code> <code class="n">CreateTwoWayChannel</code><code class="p">(</code><code class="mi">1024</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">FClient1</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">TCommTester</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="n">FCommChannel</code><code class="o">.</code><code class="n">Endpoint1</code><code class="p">))</code>
<code class="lineno"> 5 </code>    <code class="o">.</code><code class="n">MonitorWith</code><code class="p">(</code><code class="n">OmniTED</code><code class="p">)</code>
<code class="lineno"> 6 </code>    <code class="o">.</code><code class="n">Run</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="n">FClient2</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">TCommTester</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="n">FCommChannel</code><code class="o">.</code><code class="n">Endpoint2</code><code class="p">))</code>
<code class="lineno"> 8 </code>    <code class="o">.</code><code class="n">MonitorWith</code><code class="p">(</code><code class="n">OmniTED</code><code class="p">)</code>
<code class="lineno"> 9 </code>    <code class="o">.</code><code class="n">Run</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The <code>TCommTester</code> constructor just stores this endpoint in an internal field. It is then used in the overridden <code>Initialize</code> as a parameter to the <code>RegisterComm</code> call. [We cannot call <code>RegisterComm</code> in the constructor as the <code>Task</code> property is not available at that time yet.]</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TCommTester</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TOmniWorker</code><code class="p">)</code>
<code class="lineno"> 3 </code>  <code class="n">strict</code> <code class="kp">private</code>
<code class="lineno"> 4 </code>    <code class="n">ctComm</code><code class="o">:</code> <code class="n">IOmniCommunicationEndpoint</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="kp">public</code>
<code class="lineno"> 6 </code>    <code class="k">constructor</code> <code class="nf">Create</code><code class="p">(</code><code class="n">commEndpoint</code><code class="o">:</code> <code class="n">IOmniCommunicationEndpoint</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">function</code>  <code class="nf">Initialize</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> <code class="kp">override</code><code class="o">;</code>
<code class="lineno"> 8 </code>    <code class="k">procedure</code> <code class="nf">OMForward</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code> <code class="n">message</code> <code class="n">MSG_FORWARD</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">procedure</code> <code class="nf">OMForwarding</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code> <code class="n">message</code> <code class="n">MSG_FORWARDING</code><code class="o">;</code>
<code class="lineno">10 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">11 </code>  
<code class="lineno">12 </code><code class="k">constructor</code> <code class="nc">TCommTester</code><code class="o">.</code><code class="nf">Create</code><code class="p">(</code><code class="n">commEndpoint</code><code class="o">:</code> <code class="n">IOmniCommunicationEndpoint</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code><code class="k">begin</code>
<code class="lineno">14 </code>  <code class="k">inherited</code> <code class="n">Create</code><code class="o">;</code>
<code class="lineno">15 </code>  <code class="n">ctComm</code> <code class="o">:=</code> <code class="n">commEndpoint</code><code class="o">;</code>
<code class="lineno">16 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">17 </code>
<code class="lineno">18 </code><code class="k">function</code> <code class="nc">TCommTester</code><code class="o">.</code><code class="nf">Initialize</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">19 </code><code class="k">begin</code>
<code class="lineno">20 </code>  <code class="bp">Result</code> <code class="o">:=</code> <code class="k">inherited</code> <code class="nb">Initialize</code><code class="o">;</code>
<code class="lineno">21 </code>  <code class="k">if</code> <code class="bp">Result</code> <code class="k">then</code> 
<code class="lineno">22 </code>    <code class="n">Task</code><code class="o">.</code><code class="n">RegisterComm</code><code class="p">(</code><code class="n">ctComm</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">23 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>To send a message to another task, use the <code>Send</code> method of the <code>IOmniCommunicationEndpoint</code>. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TCommTester</code><code class="o">.</code><code class="nf">OMForward</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="n">Task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="n">MSG_NOTIFY_FORWARD</code><code class="o">,</code> <code class="n">msg</code><code class="o">.</code><code class="n">MsgData</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">ctComm</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="n">MSG_FORWARDING</code><code class="o">,</code> <code class="n">msg</code><code class="o">.</code><code class="n">MsgData</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno"> 6 </code>
<code class="lineno"> 7 </code><code class="k">procedure</code> <code class="nc">TCommTester</code><code class="o">.</code><code class="nf">OMForwarding</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 8 </code><code class="k">begin</code>
<code class="lineno"> 9 </code>  <code class="n">Task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="n">MSG_NOTIFY_RECEPTION</code><code class="o">,</code> <code class="n">msg</code><code class="o">.</code><code class="n">MsgData</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="lowlevel-tomniworker-tomniworkerinvoke">
<span class="section-number">4.11.5 </span>Invoke</h4>

<p>Instead of sending messages that are processed in the task you can also instruct the task to execute a specific code. OmniThreadLibrary provides three variations of the same mechanism – <code>Invoke</code>. They allow you to call a method by providing its name, call a method by providing its address or to execute an anonymous method.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">function</code> <code class="nf">Invoke</code><code class="p">(</code><code class="k">const</code> <code class="n">msgName</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">function</code> <code class="nf">Invoke</code><code class="p">(</code><code class="k">const</code> <code class="n">msgName</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code> <code class="n">msgData</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="k">const</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 3 </code>  <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 4 </code><code class="k">function</code> <code class="nf">Invoke</code><code class="p">(</code><code class="k">const</code> <code class="n">msgName</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code> <code class="n">msgData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 5 </code>  <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 6 </code>
<code class="lineno"> 7 </code><code class="k">function</code> <code class="nf">Invoke</code><code class="p">(</code><code class="k">const</code> <code class="n">msgMethod</code><code class="o">:</code> <code class="kt">pointer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 8 </code><code class="k">function</code> <code class="nf">Invoke</code><code class="p">(</code><code class="k">const</code> <code class="n">msgMethod</code><code class="o">:</code> <code class="kt">pointer</code><code class="o">;</code> <code class="n">msgData</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="k">const</code><code class="p">)</code><code class="o">:</code> 
<code class="lineno"> 9 </code>  <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">function</code> <code class="nf">Invoke</code><code class="p">(</code><code class="k">const</code> <code class="n">msgMethod</code><code class="o">:</code> <code class="kt">pointer</code><code class="o">;</code> <code class="n">msgData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">11 </code>
<code class="lineno">12 </code><code class="k">function</code> <code class="nf">Invoke</code><code class="p">(</code><code class="n">remoteFunc</code><code class="o">:</code> <code class="n">TOmniTaskControlInvokeFunction</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">13 </code><code class="k">function</code> <code class="nf">Invoke</code><code class="p">(</code><code class="n">remoteFunc</code><code class="o">:</code> <code class="n">TOmniTaskControlInvokeFunctionEx</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>Invoke</code> uses the communication system to execute the code inside the task. It sends a special internal message (with the reserved ID <em>$FFFF</em>) to the task. Internal <code>TOmniWorker</code> code catches this message and instead of dispatching it to your task object the code referenced from the message is executed. The code is therefore not executed when you call the <code>Invoke</code> but some undeterminable time later. </p>

<p>You can pass data to an invoked method. In <code>Invoke</code> you can add a second parameter which can be a <code>TOmniValue</code> or an array of elements which is <a href="chap05.html#introotl-tomnivalue-array">converted</a> to a <code>TOmniValue</code>. To receive this data, the method on the task side must either accept a <code>const TOmniValue</code> parameter or a <code>var TObject</code> parameter. In the latter case you must, of course, provide an object (of any class) as the second <code>Invoke</code> parameter. </p>

<aside class="tip blurb">
    <p>Invoked methods must be marked <code>public</code> or <code>published</code>.</p>

</aside>

<p>Let’s see a simple example. We have a simple worker with three public methods.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TMyObj</code> <code class="o">=</code> <code class="k">class</code>
<code class="lineno"> 3 </code>    <code class="nb">Val</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 4 </code>    <code class="k">constructor</code> <code class="nf">Create</code><code class="p">(</code><code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno"> 6 </code>
<code class="lineno"> 7 </code>  <code class="n">TMyTask</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TOmniWorker</code><code class="p">)</code>
<code class="lineno"> 8 </code>  <code class="kp">public</code>
<code class="lineno"> 9 </code>    <code class="k">procedure</code> <code class="nf">Test1</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">procedure</code> <code class="nf">Test2</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">procedure</code> <code class="nf">Test3</code><code class="p">(</code><code class="k">var</code> <code class="n">obj</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">13 </code>
<code class="lineno">14 </code><code class="cm">{ TMyObj }</code>
<code class="lineno">15 </code>
<code class="lineno">16 </code><code class="k">constructor</code> <code class="nc">TMyObj</code><code class="o">.</code><code class="nf">Create</code><code class="p">(</code><code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">17 </code><code class="k">begin</code>
<code class="lineno">18 </code>  <code class="nb">Val</code> <code class="o">:=</code> <code class="n">value</code><code class="o">;</code>
<code class="lineno">19 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">20 </code>
<code class="lineno">21 </code><code class="cm">{ TMyTask }</code>
<code class="lineno">22 </code>
<code class="lineno">23 </code><code class="k">procedure</code> <code class="nc">TMyTask</code><code class="o">.</code><code class="nf">Test1</code><code class="o">;</code>
<code class="lineno">24 </code><code class="k">begin</code>
<code class="lineno">25 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">26 </code>
<code class="lineno">27 </code><code class="k">procedure</code> <code class="nc">TMyTask</code><code class="o">.</code><code class="nf">Test2</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">28 </code><code class="k">begin</code>
<code class="lineno">29 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">30 </code>
<code class="lineno">31 </code><code class="k">procedure</code> <code class="nc">TMyTask</code><code class="o">.</code><code class="nf">Test3</code><code class="p">(</code><code class="k">var</code> <code class="n">obj</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">32 </code><code class="k">begin</code>
<code class="lineno">33 </code>  <code class="n">obj</code><code class="o">.</code><code class="n">Free</code><code class="o">;</code>
<code class="lineno">34 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>You can now call these three methods in the following manner.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FTask</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">TMyTask</code><code class="o">.</code><code class="n">Create</code><code class="p">())</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">FTask</code><code class="o">.</code><code class="n">Invoke</code><code class="p">(</code><code class="s">'Test1'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">3 </code><code class="n">FTask</code><code class="o">.</code><code class="n">Invoke</code><code class="p">(</code><code class="s">'Test2'</code><code class="o">,</code> <code class="p">[</code><code class="mi">1</code><code class="o">,</code> <code class="mi">2</code><code class="o">,</code> <code class="mi">3</code><code class="p">])</code><code class="o">;</code>
<code class="lineno">4 </code><code class="n">FTask</code><code class="o">.</code><code class="n">Invoke</code><code class="p">(</code><code class="s">'Test3'</code><code class="o">,</code> <code class="n">TMyObj</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="mi">42</code><code class="p">))</code><code class="o">;</code>
<code class="lineno">5 </code>
<code class="lineno">6 </code><code class="c1">//This would cause a runtime error because method 'Test4' doesn't exist.</code>
<code class="lineno">7 </code><code class="c1">//FTask.Invoke('Test4');</code>
</pre></div>

</figure>

<p>Alternatively, you can provide an address of the method instead of its name which gives you some compile-time checking – if the code tries to call an inexistent method it will not compile.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FTask</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">TMyTask</code><code class="o">.</code><code class="n">Create</code><code class="p">())</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">FTask</code><code class="o">.</code><code class="n">Invoke</code><code class="p">(</code><code class="o">@</code><code class="n">TMyTask</code><code class="o">.</code><code class="n">Test1</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">3 </code><code class="n">FTask</code><code class="o">.</code><code class="n">Invoke</code><code class="p">(</code><code class="o">@</code><code class="n">TMyTask</code><code class="o">.</code><code class="n">Test2</code><code class="o">,</code> <code class="p">[</code><code class="mi">1</code><code class="o">,</code> <code class="mi">2</code><code class="o">,</code> <code class="mi">3</code><code class="p">])</code><code class="o">;</code>
<code class="lineno">4 </code><code class="n">FTask</code><code class="o">.</code><code class="n">Invoke</code><code class="p">(</code><code class="o">@</code><code class="n">TMyTask</code><code class="o">.</code><code class="n">Test3</code><code class="o">,</code> <code class="n">TMyObj</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="mi">42</code><code class="p">))</code><code class="o">;</code>
<code class="lineno">5 </code>
<code class="lineno">6 </code><code class="c1">//This would not compile because method 'Test4' doesn't exist.</code>
<code class="lineno">7 </code><code class="c1">//FTask.Invoke(@TMyTask.Test4);</code>
</pre></div>

</figure>

<p>The last two versions of <code>Invoke</code> allow you to execute an anonymous method in the background task. One will run a parameter-less method while another executes a method accepting an <code>IOmniTask</code> parameter which you can use to control the task.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">FTask</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">TMyTask</code><code class="o">.</code><code class="n">Create</code><code class="p">())</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="n">FTask</code><code class="o">.</code><code class="n">Invoke</code><code class="p">(</code>
<code class="lineno"> 3 </code>  <code class="k">procedure</code>
<code class="lineno"> 4 </code>  <code class="k">begin</code>
<code class="lineno"> 5 </code>    <code class="c1">// some code</code>
<code class="lineno"> 6 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code><code class="n">FTask</code><code class="o">.</code><code class="n">Invoke</code><code class="p">(</code>
<code class="lineno"> 8 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code>
<code class="lineno"> 9 </code>  <code class="k">begin</code>
<code class="lineno">10 </code>    <code class="c1">// some code</code>
<code class="lineno">11 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>See also <a href="chap12.html#demos">demo</a> <code>43_InvokeAnonymous</code>.</p>

<h4 id="lowlevel-tomniworker-msgwait">
<span class="section-number">4.11.6 </span>Windows message &amp; APC processing</h4>

<p>The internal main loop in the <code>TOmniWorker</code> can optionally process and dispatch Windows messages. This is especially important if your task creates components that use Windows messages for normal operation.</p>

<p>To force Windows message processing, you must call the <code>MsgWait</code> method of the task controller. You can optionally provide a wake mask.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">MsgWait</code><code class="p">(</code><code class="n">wakeMask</code><code class="o">:</code> <code class="kt">DWORD</code> <code class="o">=</code> <code class="n">QS_ALLEVENTS</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
</pre></div>

</figure>

<p>If your background code uses asynchronous procedure calls (for example if it is reading from a file asynchronously), you should call the <code>Alertable</code> method which will enable the <code>MWMO_ALERTABLE</code> flag.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">Alertable</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
</pre></div>

</figure>

<p>More information about the wake mask and about the alertable flag can be found in the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684245(v=vs.85).aspx">MSDN</a>.</p>

<h4 id="lowlevel-tomniworker-timers">
<span class="section-number">4.11.7 </span>Timers</h4>

<p>The <code>TOmniWorker</code> model greatly simplifies executing repeated tasks inside the task worker. You can set up multiple timers and associate them with the code in few different ways.  </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">ClearTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">function</code> <code class="nf">SetTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">interval_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> 
<code class="lineno">3 </code>  <code class="k">const</code> <code class="n">timerMessage</code><code class="o">:</code> <code class="n">TOmniMessageID</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">procedure</code> <code class="nf">SetTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">interval_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> 
<code class="lineno">5 </code>  <code class="k">const</code> <code class="n">timerMessage</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">6 </code><code class="k">procedure</code> <code class="nf">SetTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">interval_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> 
<code class="lineno">7 </code>  <code class="k">const</code> <code class="n">timerMessage</code><code class="o">:</code> <code class="n">TProc</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<p>To set up a timer, call the <code>SetTimer</code> function. It accepts three parameters – timer ID, interval (in milliseconds) and a <em>timer message</em>. The latter is a parameter specifying the code to be executed every <code>interval_ms</code> milliseconds and can be specified in three different ways which are discussed below.</p>

<p>Two other <code>SetTimer</code> overloads, introduced in version <sup>[3.07.3]</sup> allow you to execute an anonymous function as a timer event. The latter will pass timer ID to the anonymous function’s <code>integer</code> parameter.</p>

<p>To clear a timer (so that the associated code is not called anymore) call the <code>ClearTimer</code> function.</p>

<aside class="tip blurb">
    <p>Don’t expect that timers will be called with a millisecond precision. Windows OS doesn’t support that.</p>

</aside>

<p>Two additional <code>SetTimer</code> overloads (not shown in the book) are provided only for backward compatibility with very old code and should not be used in new programs.</p>

<p>The code below shows four ways in which a timer method can be specified.</p>

<ul>
  <li>A name of the timer method (<code>Timer1</code>). The method must have at least <code>public</code> visibility. The method can optionally accept one parameter of type <code>TOmniValue</code> which will contain the timer ID.</li>
  <li>An address of the timer method (<code>@TMyTask.Timer2</code>). The method can optionally accept one parameter of type <code>TOmniValue</code> which will contain the timer ID.</li>
  <li>A message ID (<code>MSG_TIMER3</code>). This message ID must not conflict with other <a href="chap07.html#lowlevel-tomniworker-communication">messages</a> processed in the background worker. The message handler (<code>Timer3</code> in the example above) must accept a <code>TOmniMessage</code> parameter. Its <code>MsgID</code> field will contain the message ID (<code>MSG_TIMER3</code>) and its <code>MsgData</code> field will contain the timer ID (<code>3</code>).</li>
  <li>An anonymous method. <sup>[3.07.3]</sup> It can have zero parameters or one integer parameter, which will receive the timer ID.   </li>
</ul>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">const</code>
<code class="lineno"> 2 </code>  <code class="n">MSG_TIMER3</code> <code class="o">=</code> <code class="mi">1</code><code class="o">;</code>
<code class="lineno"> 3 </code>
<code class="lineno"> 4 </code><code class="k">type</code>
<code class="lineno"> 5 </code>  <code class="n">TMyTask</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TOmniWorker</code><code class="p">)</code>
<code class="lineno"> 6 </code>  <code class="kp">public</code>
<code class="lineno"> 7 </code>    <code class="k">procedure</code> <code class="nf">Timer1</code><code class="o">;</code>
<code class="lineno"> 8 </code>    <code class="k">procedure</code> <code class="nf">Timer2</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">procedure</code> <code class="nf">Timer3</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code> <code class="n">message</code> <code class="n">MSG_TIMER3</code><code class="o">;</code>
<code class="lineno">10 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">11 </code>
<code class="lineno">12 </code><code class="cm">{ TMyTask }</code>
<code class="lineno">13 </code>
<code class="lineno">14 </code><code class="k">procedure</code> <code class="nc">TMyTask</code><code class="o">.</code><code class="nf">Timer1</code><code class="o">;</code>
<code class="lineno">15 </code><code class="k">begin</code>
<code class="lineno">16 </code>  <code class="c1">// called every 150 ms</code>
<code class="lineno">17 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">18 </code>
<code class="lineno">19 </code><code class="k">procedure</code> <code class="nc">TMyTask</code><code class="o">.</code><code class="nf">Timer2</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">20 </code><code class="k">begin</code>
<code class="lineno">21 </code>  <code class="c1">// called every 200 ms</code>
<code class="lineno">22 </code>  <code class="c1">// value contains the timer ID</code>
<code class="lineno">23 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">24 </code>
<code class="lineno">25 </code><code class="k">procedure</code> <code class="nc">TMyTask</code><code class="o">.</code><code class="nf">Timer3</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">26 </code><code class="k">begin</code>
<code class="lineno">27 </code>  <code class="c1">// called every 250 ms</code>
<code class="lineno">28 </code>  <code class="c1">// msg.MsgData contains the timer ID</code>
<code class="lineno">29 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">30 </code>
<code class="lineno">31 </code><code class="n">FTask</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">TMyTask</code><code class="o">.</code><code class="n">Create</code><code class="p">())</code><code class="o">.</code><code class="n">Run</code><code class="o">;</code>
<code class="lineno">32 </code><code class="n">FTask</code><code class="o">.</code><code class="n">SetTimer</code><code class="p">(</code><code class="mi">1</code><code class="o">,</code> <code class="mi">150</code><code class="o">,</code> <code class="s">'Timer1'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">33 </code><code class="n">FTask</code><code class="o">.</code><code class="n">SetTimer</code><code class="p">(</code><code class="mi">2</code><code class="o">,</code> <code class="mi">200</code><code class="o">,</code> <code class="o">@</code><code class="n">TMyTask</code><code class="o">.</code><code class="n">Timer2</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">34 </code><code class="n">FTask</code><code class="o">.</code><code class="n">SetTimer</code><code class="p">(</code><code class="mi">3</code><code class="o">,</code> <code class="mi">250</code><code class="o">,</code> <code class="n">MSG_TIMER3</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">35 </code><code class="n">FTask</code><code class="o">.</code><code class="n">SetTimer</code><code class="p">(</code><code class="mi">4</code><code class="o">,</code> <code class="mi">333</code><code class="o">,</code> 
<code class="lineno">36 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code>
<code class="lineno">37 </code>  <code class="k">begin</code>
<code class="lineno">38 </code>    <code class="c1">// called every 333 seconds</code>
<code class="lineno">39 </code>    <code class="c1">// timerID contains the timer ID</code>
<code class="lineno">40 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<blockquote>
  <p>Timers can also be set and cleared from <a href="chap07.html#lowlevel-iomnitask-timers">inside the task</a>.</p>
</blockquote>

<h4 id="lowlevel-tomniworker-terminateWhen">
<span class="section-number">4.11.8 </span>TerminateWhen</h4>

<p>By using the <code>TerminateWhen</code> function you can set up a termination trigger – a signal that will stop the background task execution. This can be either a Windows synchronization primitive (such as an event) or a <a href="chap08.html#synch-cancellationtoken">cancellation token</a>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">TerminateWhen</code><code class="p">(</code><code class="n">event</code><code class="o">:</code> <code class="kt">THandle</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">function</code> <code class="nf">TerminateWhen</code><code class="p">(</code><code class="n">token</code><code class="o">:</code> <code class="n">IOmniCancellationToken</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<p>The use of the <code>TerminateWhen</code> function is demonstrated in the <code>14_TerminateWhen</code> <a href="chap12.html#demos">demo</a>. </p>

<h4 id="leanpub-auto-userdata">
<span class="section-number">4.11.9 </span>UserData</h4>

<p>Sometimes you would want to associate data with the task controller. The <code>UserData</code> property can be used for this purpose. This data is never accessed from the OmniThreadLibrary code; it is only managed by the library for your convenience. <code>UserData</code> is available via the <code>IOmniTaskController</code> interface and cannot be used in the background task. </p>

<aside class="tip blurb">
    <p>This functionality may for example be used to set some data when the task is created and then access this data in the termination handler.  </p>

</aside>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nf">SetUserData</code><code class="p">(</code><code class="k">const</code> <code class="n">idxData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code> 
<code class="lineno">2 </code>  <code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno">3 </code><code class="k">property</code> <code class="py">UserData</code><code class="p">[</code><code class="k">const</code> <code class="n">idxData</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">]</code><code class="o">:</code> <code class="n">TOmniValue</code> 
<code class="lineno">4 </code>  <code class="kp">read</code> <code class="nf">GetUserDataVal</code> <code class="kp">write</code> <code class="nf">SetUserDataVal</code><code class="o">;</code>
</pre></div>

</figure>

<p>Data can be accessed through an integer index or through a name. Both lines below are valid.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">taskController</code><code class="o">.</code><code class="n">UserData</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">:=</code> <code class="n">myTaskList</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">taskController</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">taskController</code><code class="o">.</code><code class="n">UserData</code><code class="p">[</code><code class="s">'token'</code><code class="p">]</code> <code class="o">:=</code> <code class="s">'something'</code><code class="o">;</code>
</pre></div>

</figure>


<div class="page-break"></div>
<h3 id="lowlevel-taskgroup">
<span class="section-number">4.12 </span>Task groups</h3>

<p><em>Task group</em> is a mechanism that allows you to treat a number of tasks as one. You can start all tasks, send a message to all tasks in a group, terminate all tasks at once and wait for all to terminate.</p>

<p>
  <em>See also <a href="chap12.html#demos">demo</a> <code>15_TaskGroup</code>.</em>
</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">IOmniTaskGroup</code> <code class="o">=</code> <code class="k">interface</code> 
<code class="lineno"> 3 </code>    <code class="p">[</code><code class="s">'{B36C08B4-0F71-422C-8613-63C4D04676B7}'</code><code class="p">]</code>
<code class="lineno"> 4 </code>    <code class="k">function</code>  <code class="nf">GetTasks</code><code class="o">:</code> <code class="n">IOmniTaskControlList</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="c1">//</code>
<code class="lineno"> 6 </code>    <code class="k">function</code>  <code class="nf">Add</code><code class="p">(</code><code class="k">const</code> <code class="n">taskControl</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskGroup</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">function</code>  <code class="nf">GetEnumerator</code><code class="o">:</code> <code class="n">IOmniTaskControlListEnumerator</code><code class="o">;</code>
<code class="lineno"> 8 </code>    <code class="k">function</code>  <code class="nf">RegisterAllCommWith</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskGroup</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">function</code>  <code class="nf">Remove</code><code class="p">(</code><code class="k">const</code> <code class="n">taskControl</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskGroup</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">function</code>  <code class="nf">RunAll</code><code class="o">:</code> <code class="n">IOmniTaskGroup</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">procedure</code> <code class="nf">SendToAll</code><code class="p">(</code><code class="k">const</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">function</code>  <code class="nf">TerminateAll</code><code class="p">(</code><code class="n">maxWait_ms</code><code class="o">:</code> <code class="kt">cardinal</code> <code class="o">=</code> <code class="n">INFINITE</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">13 </code>    <code class="k">function</code>  <code class="nf">UnregisterAllCommFrom</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskGroup</code><code class="o">;</code>
<code class="lineno">14 </code>    <code class="k">function</code>  <code class="nf">WaitForAll</code><code class="p">(</code><code class="n">maxWait_ms</code><code class="o">:</code> <code class="kt">cardinal</code> <code class="o">=</code> <code class="n">INFINITE</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">15 </code>    <code class="k">property</code>  <code class="py">Tasks</code><code class="o">:</code> <code class="n">IOmniTaskControlList</code> <code class="kp">read</code> <code class="nf">GetTasks</code><code class="o">;</code>
<code class="lineno">16 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">17 </code>  
<code class="lineno">18 </code>  <code class="n">TOmniTaskGroup</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TInterfacedObject</code><code class="o">,</code> <code class="n">IOmniTaskGroup</code><code class="p">)</code>
<code class="lineno">19 </code>  <code class="kp">public</code>
<code class="lineno">20 </code>    <code class="k">constructor</code> <code class="nf">Create</code><code class="o">;</code>
<code class="lineno">21 </code>    <code class="k">destructor</code>  <code class="nf">Destroy</code><code class="o">;</code> <code class="kp">override</code><code class="o">;</code>
<code class="lineno">22 </code>    <code class="k">function</code>  <code class="nf">Add</code><code class="p">(</code><code class="k">const</code> <code class="n">taskControl</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskGroup</code><code class="o">;</code>
<code class="lineno">23 </code>    <code class="k">function</code>  <code class="nf">GetEnumerator</code><code class="o">:</code> <code class="n">IOmniTaskControlListEnumerator</code><code class="o">;</code>
<code class="lineno">24 </code>    <code class="k">function</code>  <code class="nf">RegisterAllCommWith</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskGroup</code><code class="o">;</code>
<code class="lineno">25 </code>    <code class="k">function</code>  <code class="nf">Remove</code><code class="p">(</code><code class="k">const</code> <code class="n">taskControl</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskGroup</code><code class="o">;</code>
<code class="lineno">26 </code>    <code class="k">function</code>  <code class="nf">RunAll</code><code class="o">:</code> <code class="n">IOmniTaskGroup</code><code class="o">;</code>
<code class="lineno">27 </code>    <code class="k">procedure</code> <code class="nf">SendToAll</code><code class="p">(</code><code class="k">const</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">28 </code>    <code class="k">function</code>  <code class="nf">TerminateAll</code><code class="p">(</code><code class="n">maxWait_ms</code><code class="o">:</code> <code class="kt">cardinal</code> <code class="o">=</code> <code class="n">INFINITE</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">29 </code>    <code class="k">function</code>  <code class="nf">UnregisterAllCommFrom</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniTaskGroup</code><code class="o">;</code>
<code class="lineno">30 </code>    <code class="k">function</code>  <code class="nf">WaitForAll</code><code class="p">(</code><code class="n">maxWait_ms</code><code class="o">:</code> <code class="kt">cardinal</code> <code class="o">=</code> <code class="n">INFINITE</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">31 </code>    <code class="k">property</code> <code class="py">Tasks</code><code class="o">:</code> <code class="n">IOmniTaskControlList</code> <code class="kp">read</code> <code class="nf">GetTasks</code><code class="o">;</code>
<code class="lineno">32 </code>  <code class="k">end</code><code class="o">;</code>  
<code class="lineno">33 </code>
<code class="lineno">34 </code><code class="k">function</code> <code class="nf">CreateTaskGroup</code><code class="o">:</code> <code class="n">IOmniTaskGroup</code><code class="o">;</code>  
</pre></div>

</figure>

<ul>
  <li>
<code>Add</code>
    <p>Adds a task to the group. See also <a href="chap07.html#lowlevel-simpletasks-joinleave"><code>Join</code></a>.</p>
  </li>
  <li>
<code>GetEnumerator</code>
    <p>Allows you to use the task group in a <code>for..in</code> statement returning all tasks in the group.</p>
  </li>
  <li>
<code>RegisterAllCommWith</code>
    <p>Registers <a href="chap07.html#lowlevel-tomniworker-registercomm">communication channel</a> of all tasks in the group with another task (the parameter to the <code>RegisterAllCommWith</code> function) so they can all send messages to that task.</p>
  </li>
  <li>
<code>Remove</code>
    <p>Removes a task from the group. See also <a href="chap07.html#lowlevel-simpletasks-joinleave"><code>Leave</code></a>.</p>
  </li>
  <li>
<code>RunAll</code>
    <p>Starts all tasks in the group.</p>
  </li>
  <li>
<code>SendToAll</code>
    <p>Sends the message to every task in the group.</p>
  </li>
  <li>
<code>TerminateAll</code>
    <p>Terminates all tasks, waiting up to <code>maxWait_ms</code> milliseconds for all of them to complete. The function returns <code>True</code> if all tasks are terminated when the function returns.</p>
  </li>
  <li>
<code>UnregisterAllCommFrom</code>
    <p>Unregisters additional communication channel from all tasks in the group.</p>
  </li>
  <li>
<code>WaitForAll</code>
    <p>Waits up to <code>maxWait_ms</code> milliseconds for all tasks to complete. The function returns <code>True</code> if all tasks are terminated when the function returns.</p>
  </li>
  <li>
<code>Tasks</code>
    <p>Provides access to the list containing all tasks in the group.</p>
  </li>
</ul>

<aside class="warning blurb">
    <p>Starting with <sup>[3.04]</sup>, task groups are not limited in size. In previous releases, a task group could contain at most 60 tasks.</p>

</aside>


<div class="page-break"></div>
<h3 id="lowlevel-iomnitask">
<span class="section-number">4.13 </span>IOmniTask interface</h3>

<p>The background worker can use the <code>IOmniTask</code> interface (defined in the <em>OtlTask</em> unit) to communicate with the task controller and to control the task’s execution. The worker can access the interface in two different ways. For the <a href="chap07.html#lowlevel-simpletasks">simple tasks</a> the interface is passed as a parameter to the task worker method. <a href="chap07.html#lowlevel-tomniworker"><code>TOmniWorker</code></a> tasks can access it through the <a href="chap07.html#lowlevel-tomniworker-task"><code>Task</code></a> property.</p>

<p>The <code>IOmniTask</code> interface exposes following methods.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOmniTaskInvokeFunction</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="o">;</code>
<code class="lineno"> 3 </code>
<code class="lineno"> 4 </code>  <code class="nf">IOmniTask</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 5 </code>    <code class="k">procedure</code> <code class="nf">ClearTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 6 </code>    <code class="k">procedure</code> <code class="nf">Enforced</code><code class="p">(</code><code class="n">forceExecution</code><code class="o">:</code> <code class="kt">boolean</code> <code class="o">=</code> <code class="k">true</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">procedure</code> <code class="nf">Invoke</code><code class="p">(</code><code class="n">remoteFunc</code><code class="o">:</code> <code class="n">TOmniTaskInvokeFunction</code><code class="p">)</code><code class="o">;</code> 
<code class="lineno"> 8 </code>    <code class="k">procedure</code> <code class="nf">InvokeOnSelf</code><code class="p">(</code><code class="n">remoteFunc</code><code class="o">:</code> <code class="n">TOmniTaskInvokeFunction</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">procedure</code> <code class="nf">RegisterComm</code><code class="p">(</code><code class="k">const</code> <code class="n">comm</code><code class="o">:</code> <code class="n">IOmniCommunicationEndpoint</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">procedure</code> <code class="nf">RegisterWaitObject</code><code class="p">(</code><code class="n">waitObject</code><code class="o">:</code> <code class="kt">THandle</code><code class="o">;</code> 
<code class="lineno">11 </code>      <code class="n">responseHandler</code><code class="o">:</code> <code class="n">TOmniWaitObjectMethod</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">procedure</code> <code class="nf">SetException</code><code class="p">(</code><code class="n">exceptionObject</code><code class="o">:</code> <code class="kt">pointer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code>    <code class="k">procedure</code> <code class="nf">SetExitStatus</code><code class="p">(</code><code class="n">exitCode</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="k">const</code> <code class="n">exitMessage</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">14 </code>    <code class="k">procedure</code> <code class="nf">SetProcessorGroup</code><code class="p">(</code><code class="n">procGroupNumber</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">15 </code>    <code class="k">procedure</code> <code class="nf">SetNUMANode</code><code class="p">(</code><code class="n">numaNodeNumber</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">16 </code>    <code class="k">procedure</code> <code class="nf">SetTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">interval_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> 
<code class="lineno">17 </code>      <code class="k">const</code> <code class="n">timerMessage</code><code class="o">:</code> <code class="n">TOmniMessageID</code><code class="p">)</code><code class="o">;</code> 
<code class="lineno">18 </code>    <code class="k">procedure</code> <code class="nf">SetTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">interval_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> 
<code class="lineno">19 </code>      <code class="k">const</code> <code class="n">timerMessage</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">20 </code>    <code class="k">procedure</code> <code class="nf">SetTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">interval_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> 
<code class="lineno">21 </code>      <code class="k">const</code> <code class="n">timerMessage</code><code class="o">:</code> <code class="n">TProc</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">22 </code>    <code class="k">procedure</code> <code class="nf">StopTimer</code><code class="o">;</code>
<code class="lineno">23 </code>    <code class="k">procedure</code> <code class="nf">Terminate</code><code class="o">;</code>
<code class="lineno">24 </code>    <code class="k">function</code>  <code class="nf">Terminated</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">25 </code>    <code class="k">function</code>  <code class="nf">Stopped</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">26 </code>    <code class="k">procedure</code> <code class="nf">UnregisterComm</code><code class="p">(</code><code class="k">const</code> <code class="n">comm</code><code class="o">:</code> <code class="n">IOmniCommunicationEndpoint</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">27 </code>    <code class="k">procedure</code> <code class="nf">UnregisterWaitObject</code><code class="p">(</code><code class="n">waitObject</code><code class="o">:</code> <code class="kt">THandle</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">28 </code>    <code class="k">property</code> <code class="py">CancellationToken</code><code class="o">:</code> <code class="n">IOmniCancellationToken</code> <code class="kp">read</code> <code class="nf">GetCancellationToken</code><code class="o">;</code>
<code class="lineno">29 </code>    <code class="k">property</code> <code class="py">Comm</code><code class="o">:</code> <code class="n">IOmniCommunicationEndpoint</code> <code class="kp">read</code> <code class="nf">GetComm</code><code class="o">;</code>
<code class="lineno">30 </code>    <code class="k">property</code> <code class="py">Counter</code><code class="o">:</code> <code class="n">IOmniCounter</code> <code class="kp">read</code> <code class="nf">GetCounter</code><code class="o">;</code>
<code class="lineno">31 </code>    <code class="k">property</code> <code class="py">Implementor</code><code class="o">:</code> <code class="kt">TObject</code> <code class="kp">read</code> <code class="nf">GetImplementor</code><code class="o">;</code>
<code class="lineno">32 </code>    <code class="k">property</code> <code class="py">Lock</code><code class="o">:</code> <code class="n">TSynchroObject</code> <code class="kp">read</code> <code class="nf">GetLock</code><code class="o">;</code>
<code class="lineno">33 </code>    <code class="k">property</code> <code class="py">Name</code><code class="o">:</code> <code class="k">string</code> <code class="kp">read</code> <code class="nf">GetName</code><code class="o">;</code>
<code class="lineno">34 </code>    <code class="k">property</code> <code class="py">Param</code><code class="o">:</code> <code class="n">TOmniValueContainer</code> <code class="kp">read</code> <code class="nf">GetParam</code><code class="o">;</code>
<code class="lineno">35 </code>    <code class="k">property</code> <code class="py">TerminateEvent</code><code class="o">:</code> <code class="kt">THandle</code> <code class="kp">read</code> <code class="nf">GetTerminateEvent</code><code class="o">;</code> 
<code class="lineno">36 </code>    <code class="k">property</code> <code class="py">ThreadData</code><code class="o">:</code> <code class="n">IInterface</code> <code class="kp">read</code> <code class="nf">GetThreadData</code><code class="o">;</code>
<code class="lineno">37 </code>    <code class="k">property</code> <code class="py">UniqueID</code><code class="o">:</code> <code class="kt">int64</code> <code class="kp">read</code> <code class="nf">GetUniqueID</code><code class="o">;</code>
<code class="lineno">38 </code>  <code class="k">end</code><code class="o">;</code> <code class="cm">{ IOmniTask }</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-name-and-id">
<span class="section-number">4.13.1 </span>Name and ID</h4>

<p>The worker can access its <a href="chap07.html#lowlevel-simpletasks-name">name</a> and <a href="chap07.html#lowlevel-simpletasks-uniqueid">unique ID</a> through the <code>Name</code> and <code>UniqueID</code> properties.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">property</code> <code class="py">Name</code><code class="o">:</code> <code class="k">string</code> <code class="kp">read</code> <code class="nf">GetName</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">property</code> <code class="py">UniqueID</code><code class="o">:</code> <code class="kt">int64</code> <code class="kp">read</code> <code class="nf">GetUniqueID</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-parameters">
<span class="section-number">4.13.2 </span>Parameters</h4>

<p>To access the parameters provided by the task owner, the worker can use the <code>Param</code> property. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">property</code> <code class="py">Param</code><code class="o">:</code> <code class="n">TOmniValueContainer</code> <code class="kp">read</code> <code class="nf">GetParam</code><code class="o">;</code>
</pre></div>

</figure>

<p>More information is provided in the <a href="chap07.html#lowlevel-simpletasks-parameters">Simple Tasks/Parameters</a> section.</p>

<h4 id="lowlevel-iomnitask-termination">
<span class="section-number">4.13.3 </span>Termination</h4>

<p>To terminate itself, a <a href="chap07.html#lowlevel-simpletasks">simple task</a> should just exit from the worker method. A <a href="chap07.html#lowlevel-tomniworker"><code>TOmniWorker</code></a> task, on the other hand, should call the <code>Terminate</code> method of the <code>IOmniTask</code> interface.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">Terminate</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">function</code>  <code class="nf">Terminated</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">3 </code><code class="k">function</code>  <code class="nf">Stopped</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">property</code> <code class="py">TerminateEvent</code><code class="o">:</code> <code class="kt">THandle</code> <code class="kp">read</code> <code class="nf">GetTerminateEvent</code><code class="o">;</code>
</pre></div>

</figure>

<p>Other termination-related methods and properties are.</p>

<ul>
  <li><code>Terminated</code></li>
</ul>

<p>Returns <code>True</code> when a worker was requested to stop, either by itself or by the task controller.</p>

<ul>
  <li><code>Stopped</code></li>
</ul>

<p>Returns <code>True</code> when a worker has fully stopped. There’s no use in calling this method from the worker itself as it will always return <code>False</code> while the worker is still active.</p>

<ul>
  <li>
<code>TerminateEvent</code> </li>
</ul>

<p>Returns the event that is signalled when a task controller requires the worker to stop. The worker can wait on this event but should never signal it. <code>Terminate</code> should be called instead to terminate the worker.</p>

<h4 id="lowlevel-iomnitask-exitstatus">
<span class="section-number">4.13.4 </span>Exit status</h4>

<p>A task can send a result to the controller by calling the <code>SetExitStatus</code> procedure.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">SetExitStatus</code><code class="p">(</code><code class="n">exitCode</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="k">const</code> <code class="n">exitMessage</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>The program can access this program through the <a href="chap07.html#lowlevel-simpletasks-exitcode">task controller</a> interface.</p>

<h4 id="leanpub-auto-exceptions-1">
<span class="section-number">4.13.5 </span>Exceptions</h4>

<p>While exceptions in a background worker code are automatically caught, a task can also set an associated exception manually, by calling <code>SetException</code>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">SetException</code><code class="p">(</code><code class="n">exceptionObject</code><code class="o">:</code> <code class="kt">pointer</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>This exception is available to the main program through the <a href="chap07.html#lowlevel-simpletasks-taskexceptions"><code>FatalException</code></a> property.</p>

<h4 id="lowlevel-iomnitask-communication">
<span class="section-number">4.13.6 </span>Communication</h4>

<p>To send a message to the task controller (and through it to the main program), a background task can use the <code>Comm</code> property.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">property</code> <code class="py">Comm</code><code class="o">:</code> <code class="n">IOmniCommunicationEndpoint</code> <code class="kp">read</code> <code class="nf">GetComm</code><code class="o">;</code>
</pre></div>

</figure>

<p>Any data can be packed in a <a href="chap05.html#introotl-tomnivalue"><code>TOmniValue</code></a> record and passed to the <code>Comm.Send</code> method. The mechanism is the same as <a href="chap07.html#lowlevel-simpletasks-communication">sending the data from the main program</a> to the background worker.</p>

<p>Messages can be received in different ways, depending on the worker type. See the appropriate sections of this manual for <a href="chap07.html#lowlevel-simpletasks-receiving">simple tasks</a> and for <a href="chap07.html#lowlevel-tomniworker-communication"><code>TOmniWorker</code> tasks</a>. </p>

<p>A simple trick can be used to send a message from a task back to itself – instead of sending it on the <code>Comm</code> channel, you send it on the <code>Comm.OtherEndpoint</code> channel.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">Task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">OtherEndpoint</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="n">MSG_FROM_TASK</code><code class="o">,</code> <code class="s">'Sent to Self'</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>A background task can use the communication channel to request asynchronous execution of code in the context of its owner (the thread which created the task). </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">type</code>
<code class="lineno">2 </code>  <code class="n">TOmniTaskInvokeFunction</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="o">;</code>
<code class="lineno">3 </code>
<code class="lineno">4 </code><code class="k">procedure</code> <code class="nf">Invoke</code><code class="p">(</code><code class="n">remoteFunc</code><code class="o">:</code> <code class="n">TOmniTaskInvokeFunction</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>This mechanism works by posting a special message containing the function to be executed from the task back to the task controller. OmniThreadLibrary catches that special message and instead of dispatching it to the normal message processing code, it will execute the attached function.</p>

<aside class="tip blurb">
    <p>For this to work, somebody has to process received messages. This happens automatically with <a href="chap06.html#highlevel">high-level abstractions</a> and with <a href="chap07.html#lowlevel">low-level</a> code that uses the <code>OnMessage</code> message dispatch. </p>

  <p>If you write a simple low-level task that doesn’t include a call to <code>OnMessage</code>, then the function will only be executed when the task is destroyed. To fix this problem, execute <code>OnMessage(Self)</code> on the task controller interface.</p>

  <p>Example: <code>FTask := CreateTask(TMyTask.Create(), 'worker').OnMessage(Self).Run;</code>  </p>

</aside>

<p id="lowlevel-iomnitask-invokeonself">Since version <sup>[3.07.3]</sup>, <code>IOmniTask</code> interface implements method <code>InvokeOnSelf</code>, which works the same as <code>Invoke</code>, except that it posts a message back to the task itself. In other words, <code>InvokeOnSelf</code> puts an anonymous method into the <em>task’s</em> message queue while <code>Invoke</code> puts it into the <em>task controller’s</em> message queue. <code>InvokeOnSelf</code> will only work correctly when the task is implemented as a <a href="chap07.html#lowlevel-tomniworker"><code>TOmniWorker</code></a> task. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">type</code>
<code class="lineno">2 </code>  <code class="n">TOmniTaskInvokeFunction</code> <code class="o">=</code> <code class="n">reference</code> <code class="k">to</code> <code class="k">procedure</code><code class="o">;</code>
<code class="lineno">3 </code>
<code class="lineno">4 </code><code class="k">procedure</code> <code class="nf">InvokeOnSelf</code><code class="p">(</code><code class="n">remoteFunc</code><code class="o">:</code> <code class="n">TOmniTaskInvokeFunction</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>A <code>TOmniWorker</code> task can register additional communication channels to enable automatic processing of messages sent across those channels. This mechanism is described in the <a href="chap07.html#lowlevel-tomniworker-registercomm"><code>TOmniWorker</code> tasks</a> section.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">RegisterComm</code><code class="p">(</code><code class="k">const</code> <code class="n">comm</code><code class="o">:</code> <code class="n">IOmniCommunicationEndpoint</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">procedure</code> <code class="nf">UnregisterComm</code><code class="p">(</code><code class="k">const</code> <code class="n">comm</code><code class="o">:</code> <code class="n">IOmniCommunicationEndpoint</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="lowlevel-iomnitask-timers">
<span class="section-number">4.13.7 </span>Timers</h4>

<p>A <code>TOmniWorker</code> task can use timers to automate repeating tasks. This functionality is explained in the <a href="chap07.html#lowlevel-tomniworker-timers"><code>TOmniWorker</code> tasks</a> section.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">ClearTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">procedure</code> <code class="nf">SetTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">interval_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> 
<code class="lineno">3 </code>  <code class="k">const</code> <code class="n">timerMessage</code><code class="o">:</code> <code class="n">TOmniMessageID</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">procedure</code> <code class="nf">SetTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">interval_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> 
<code class="lineno">5 </code>  <code class="k">const</code> <code class="n">timerMessage</code><code class="o">:</code> <code class="n">TProc</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">6 </code><code class="k">procedure</code> <code class="nf">SetTimer</code><code class="p">(</code><code class="n">timerID</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">interval_ms</code><code class="o">:</code> <code class="kt">cardinal</code><code class="o">;</code> 
<code class="lineno">7 </code>  <code class="k">const</code> <code class="n">timerMessage</code><code class="o">:</code> <code class="n">TProc</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="lowlevel-iomnitask-registerwaitobject">
<span class="section-number">4.13.8 </span>RegisterWaitObject</h4>

<p>A <code>TOmniWorker</code> task can register external synchronization object (typically an event) to be included in the <a href="chap07.html#lowlevel-tomniworker">main loop</a>. An associated method will be called when a synchronization object becomes signalled. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">type</code>
<code class="lineno">2 </code>  <code class="n">TOmniWaitObjectMethod</code> <code class="o">=</code> <code class="k">procedure</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>
<code class="lineno">3 </code>  
<code class="lineno">4 </code><code class="k">procedure</code> <code class="nf">RegisterWaitObject</code><code class="p">(</code><code class="n">waitObject</code><code class="o">:</code> <code class="kt">THandle</code><code class="o">;</code> 
<code class="lineno">5 </code>  <code class="n">responseHandler</code><code class="o">:</code> <code class="n">TOmniWaitObjectMethod</code><code class="p">)</code><code class="o">;</code> 
<code class="lineno">6 </code><code class="k">procedure</code> <code class="nf">UnregisterWaitObject</code><code class="p">(</code><code class="n">waitObject</code><code class="o">:</code> <code class="kt">THandle</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>Use <code>RegisterWaitObject</code> to register external synchronization object with the main loop and <code>UnregisterWaitObject</code> to remove the synchronization object from the main loop.</p>

<h4 id="leanpub-auto-cancellationtoken">
<span class="section-number">4.13.9 </span>CancellationToken</h4>

<p>If a cancellation token is <a href="chap07.html#lowlevel-simpletasks-cancellationtoken">associated with the background task</a>, it can be accessed through the <code>CancellationToken</code> property.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">property</code> <code class="py">CancellationToken</code><code class="o">:</code> <code class="n">IOmniCancellationToken</code> <code class="kp">read</code> <code class="nf">GetCancellationToken</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="lowlevel-iomnitask-lock">
<span class="section-number">4.13.10 </span>Lock</h4>

<p>If a lock is <a href="chap07.html#lowlevel-simpletasks-tasklock">associated with the background task</a>, it can be accessed through the <code>Lock</code> property.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">property</code> <code class="py">Lock</code><code class="o">:</code> <code class="n">TSynchroObject</code> <code class="kp">read</code> <code class="nf">GetLock</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-counter">
<span class="section-number">4.13.11 </span>Counter</h4>

<p>If a thread-safe counter is <a href="chap07.html#lowlevel-simpletasks-counter">associated with the background task</a>, it can be accessed through the <code>Counter</code> property.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">property</code> <code class="py">Counter</code><code class="o">:</code> <code class="n">IOmniCounter</code> <code class="kp">read</code> <code class="nf">GetCounter</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-processor-groups-and-numa-nodes-2">
<span class="section-number">4.13.12 </span>Processor groups and NUMA nodes</h4>

<p>On a system with multiple processor groups you can use <code>SetProcessorGroup</code> <sup>[3.06]</sup> function to specify a processor group this task should run on. </p>

<p>On a system with multiple NUMA nodes you can use <code>SetNUMANode</code> <sup>[3.06]</sup> function to specify a NUMA node this task should run on.</p>

<p>An information about existing processor groups and NUMA nodes can be accessed through the <a href="chap09.html#misc-environment"><code>Environment</code></a> object.</p>

<p>This information should be in most cases managed via <a href="chap07.html#lowlevel-iomnitaskcontrol"><code>IOmniTaskControl.ProcessorGroup</code></a>, <a href="chap07.html#lowlevel-iomnitaskcontrol"><code>IOmniTaskControl.NUMANode</code></a>, <a href="chap07.html#lowlevel-threadpool"><code>IOmniThreadPool.ProcessorGroups</code></a>, and <a href="chap07.html#lowlevel-threadpool"><code>IOmniThreadPool.NUMANodes</code></a>.   </p>

<h4 id="leanpub-auto-internal-and-obsolete-functions">
<span class="section-number">4.13.13 </span>Internal and obsolete functions</h4>

<p>The <code>Enforced</code> method works the same as the <a href="chap07.html#lowlevel-simpletasks-enforced"><code>IOmniTaskControl</code> equivalent</a>. As it must be called before the task starts execution, it cannot be used from the background task itself. OmniThreadLibrary uses this function in the <a href="chap07.html#lowlevel-threadpool">thread pool</a> implementation.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">Enforced</code><code class="p">(</code><code class="n">forceExecution</code><code class="o">:</code> <code class="kt">boolean</code> <code class="o">=</code> <code class="k">true</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>The <code>Implementor</code> object returns an object implementing the <code>IOmniTask</code> interface.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">property</code> <code class="py">Implementor</code><code class="o">:</code> <code class="kt">TObject</code> <code class="kp">read</code> <code class="nf">GetImplementor</code><code class="o">;</code>
</pre></div>

</figure>

<p>The <code>ThreadData</code> property is used to access the internal interface used in the <a href="chap07.html#lowlevel-threadpool">thread pool’s</a> <code>SetThreadDataFactory</code> mechanism.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">property</code> <code class="py">ThreadData</code><code class="o">:</code> <code class="n">IInterface</code> <code class="kp">read</code> <code class="nf">GetThreadData</code><code class="o">;</code>
</pre></div>

</figure>

<p>The <a href="chap10.html#howto-connectionPool">Building a connection pool</a> example contains more information on this topic.    </p>

<p>The <code>StopTimer</code> method is obsolete and should not be used anymore. Use the <a href="chap07.html#lowlevel-iomnitask-timers"><code>ClearTimer</code></a> instead.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">StopTimer</code><code class="o">;</code>
</pre></div>

</figure>



</div>
</body>

<!-- Mirrored from www.omnithreadlibrary.com/book/chap07.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 19 Oct 2025 22:29:00 GMT -->
</html>
