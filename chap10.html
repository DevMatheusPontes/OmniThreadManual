<!DOCTYPE html>
<html lang="en">

<!-- Mirrored from www.omnithreadlibrary.com/book/chap10.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 19 Oct 2025 22:29:01 GMT -->
<head>
  <meta charset="utf-8">
  <title>7. How-to</title>
  <link href="stylesheet.css" rel="stylesheet" />
</head>
<body dir="ltr" class="kramdown">
<div id="leanpub-toc">
<h2></h2>
<ol class="toc">
<ul class='toc no-parts'>
  <li>
    <a href='chap00.html#intro-advert'>About me</a>
  </li>
  <li>
    <a href='chap01.html#credits'>Credits</a>
  </li>
  <li>
    <a href='chap02.html#introduction'>Introduction</a>
    <ul>
      <li>
        <a href='chap02.html#leanpub-auto-formatting-conventions'>Formatting conventions</a>
      </li>
      <li>
        <a href='chap02.html#leanpub-auto-learn-more'>Learn more</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap03.html#leanpub-auto-release-notes'>Release notes</a>
  </li>
  <li>
    <a href='chap04.html#intro-mt'><span class="section-number">1. </span>Introduction to multi-threading</a>
    <ul>
      <li>
        <a href='chap04.html#leanpub-auto-multi-threading-as-a-source-of-problems'><span class="section-number">1.1 </span>Multi-threading as a source of problems</a>
        <ul>
          <li>
            <a href='chap04.html#leanpub-auto-reading-and-writing-shared-data'><span class="section-number">1.1.1 </span>Reading and writing shared data</a>
          </li>
          <li>
            <a href='chap04.html#leanpub-auto-modifying-shared-data'><span class="section-number">1.1.2 </span>Modifying shared data</a>
          </li>
          <li>
            <a href='chap04.html#leanpub-auto-writes-masquerading-as-reads'><span class="section-number">1.1.3 </span>Writes masquerading as reads</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap05.html#intro-otl'><span class="section-number">2. </span>Introduction to OmniThreadLibrary</a>
    <ul>
      <li>
        <a href='chap05.html#leanpub-auto-requirements'><span class="section-number">2.1 </span>Requirements</a>
      </li>
      <li>
        <a href='chap05.html#leanpub-auto-license'><span class="section-number">2.2 </span>License</a>
      </li>
      <li>
        <a href='chap05.html#installation'><span class="section-number">2.3 </span>Installation</a>
        <ul>
          <li>
            <a href='chap05.html#appendix-installing-getit'><span class="section-number">2.3.1 </span>Installing with GetIt</a>
          </li>
          <li>
            <a href='chap05.html#appendix-installing-delphinus'><span class="section-number">2.3.2 </span>Installing with Delphinus</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-installing-design-package'><span class="section-number">2.3.3 </span>Installing design package</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap05.html#leanpub-auto-why-use-omnithreadlibrary'><span class="section-number">2.4 </span>Why use OmniThreadLibrary?</a>
      </li>
      <li>
        <a href='chap05.html#introotl-tasksvsthreads'><span class="section-number">2.5 </span>Tasks vs. threads</a>
      </li>
      <li>
        <a href='chap05.html#introotl-lockingvsmessaging'><span class="section-number">2.6 </span>Locking vs. messaging</a>
      </li>
      <li>
        <a href='chap05.html#introotl-messagelooprequired'><span class="section-number">2.7 </span>Message loop required</a>
        <ul>
          <li>
            <a href='chap05.html#introotl-messagelooprequired-console'><span class="section-number">2.7.1 </span>OmniThreadLibrary and console</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-omnithreadlibrary-task-started-from-another-task'><span class="section-number">2.7.2 </span>OmniThreadLibrary task started from another task</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-omnithreadlibrary-task-started-from-a-tthread'><span class="section-number">2.7.3 </span>OmniThreadLibrary task started from a TThread</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap05.html#introotl-tomnivalue'><span class="section-number">2.8 </span>TOmniValue</a>
        <ul>
          <li>
            <a href='chap05.html#leanpub-auto-data-access'><span class="section-number">2.8.1 </span>Data access</a>
          </li>
          <li>
            <a href='chap05.html#introotl-tomnivalue-typetesting'><span class="section-number">2.8.2 </span>Type testing</a>
          </li>
          <li>
            <a href='chap05.html#introotl-tomnivalue-clearing'><span class="section-number">2.8.3 </span>Clearing the content</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-operators'><span class="section-number">2.8.4 </span>Operators</a>
          </li>
          <li>
            <a href='chap05.html#introotl-tomnivalue-generictypes'><span class="section-number">2.8.5 </span>Using with generic types</a>
          </li>
          <li>
            <a href='chap05.html#introotl-tomnivalue-array'><span class="section-number">2.8.6 </span>Array access</a>
          </li>
          <li>
            <a href='chap05.html#introotl-tomnivalue-records'><span class="section-number">2.8.7 </span>Handling records</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-object-ownership'><span class="section-number">2.8.8 </span>Object ownership</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-working-with-tvalue'><span class="section-number">2.8.9 </span>Working with TValue</a>
          </li>
          <li>
            <a href='chap05.html#leanpub-auto-low-level-methods'><span class="section-number">2.8.10 </span>Low-level methods</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap05.html#leanpub-auto-tomnivalueobj'><span class="section-number">2.9 </span>TOmniValueObj</a>
      </li>
      <li>
        <a href='chap05.html#introotl-fluentinterfaces'><span class="section-number">2.10 </span>Fluent interfaces</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap06.html#highlevel'><span class="section-number">3. </span>High-level multi-threading</a>
    <ul>
      <li>
        <a href='chap06.html#highlevel-introduction'><span class="section-number">3.1 </span>Introduction</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-a-life-cycle-of-an-abstraction'><span class="section-number">3.1.1 </span>A life cycle of an abstraction</a>
          </li>
          <li>
            <a href='chap06.html#highLevel-intro-AnonymousEtAl'><span class="section-number">3.1.2 </span>Anonymous methods, procedures, and methods</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-introduction-pooling'><span class="section-number">3.1.3 </span>Pooling</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-blocking-collection'><span class="section-number">3.2 </span>Blocking collection</a>
        <ul>
          <li>
            <a href='chap06.html#highlevel-blocking-collection-iomniblockingcollection'><span class="section-number">3.2.1 </span>IOmniBlockingCollection</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-blocking-collection-bulk-impexp'><span class="section-number">3.2.2 </span>Bulk import and export</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-blocking-collection-throttling'><span class="section-number">3.2.3 </span>Throttling</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-taskconfig'><span class="section-number">3.3 </span>Task configuration</a>
      </li>
      <li>
        <a href='chap06.html#highlevel-async'><span class="section-number">3.4 </span>Async</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-handling-exceptions'><span class="section-number">3.4.1 </span>Handling exceptions</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-asyncawait'><span class="section-number">3.5 </span>Async/Await</a>
      </li>
      <li>
        <a href='chap06.html#highlevel-future'><span class="section-number">3.6 </span>Future</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-iomnifuturet-interface'><span class="section-number">3.6.1 </span>IOmniFuture&lt;T&gt; interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-completion-detection'><span class="section-number">3.6.2 </span>Completion detection</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-cancellation'><span class="section-number">3.6.3 </span>Cancellation</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-handling-exceptions-1'><span class="section-number">3.6.4 </span>Handling exceptions</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples'><span class="section-number">3.6.5 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-join'><span class="section-number">3.7 </span>Join</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-iomniparalleljoin-interface'><span class="section-number">3.7.1 </span>IOmniParallelJoin interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomnijoinstate-interface'><span class="section-number">3.7.2 </span>IOmniJoinState interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-cancellation-1'><span class="section-number">3.7.3 </span>Cancellation</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-join-exceptions'><span class="section-number">3.7.4 </span>Handling exceptions</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-paralleltask'><span class="section-number">3.8 </span>Parallel task</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-iomniparalleltask-interface'><span class="section-number">3.8.1 </span>IOmniParallelTask interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-example'><span class="section-number">3.8.2 </span>Example</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-handling-exceptions-2'><span class="section-number">3.8.3 </span>Handling exceptions</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-1'><span class="section-number">3.8.4 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-backgroundworker'><span class="section-number">3.9 </span>Background worker</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-basics'><span class="section-number">3.9.1 </span>Basics</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomnibackgroundworker-interface'><span class="section-number">3.9.2 </span>IOmniBackgroundWorker interface</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-backgroundworker-initialization'><span class="section-number">3.9.3 </span>Task initialization</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-work-item-configuration'><span class="section-number">3.9.4 </span>Work item configuration</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-backgroundworker-iomniworkitem'><span class="section-number">3.9.5 </span>Work item interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-2'><span class="section-number">3.9.6 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-pipeline'><span class="section-number">3.10 </span>Pipeline</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-background'><span class="section-number">3.10.1 </span>Background</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-basics-1'><span class="section-number">3.10.2 </span>Basics</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomnipipeline-interface'><span class="section-number">3.10.3 </span>IOmniPipeline interface</a>
            <ul>
              <li>
                <a href='chap06.html#leanpub-auto-example-1'><span class="section-number">3.10.3.1 </span>Example</a>
              </li>
            </ul>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-generators-mutators-and-aggregators'><span class="section-number">3.10.4 </span>Generators, mutators, and aggregators</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-pipeline-throttling'><span class="section-number">3.10.5 </span>Throttling</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-pipeline-parallel'><span class="section-number">3.10.6 </span>Parallel stages</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-pipeline-exceptions'><span class="section-number">3.10.7 </span>Exceptions</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-3'><span class="section-number">3.10.8 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-for'><span class="section-number">3.11 </span>Parallel for</a>
        <ul>
          <li>
            <a href='chap06.html#highlevel-for-iomniparallelsimpleloop'><span class="section-number">3.11.1 </span>IOmniParallelSimpleLoop interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iterating-over-an-array'><span class="section-number">3.11.2 </span>Iterating over an array</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-4'><span class="section-number">3.11.3 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-foreach'><span class="section-number">3.12 </span>ForEach</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-cooperation'><span class="section-number">3.12.1 </span>Cooperation</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iterating-over-'><span class="section-number">3.12.2 </span>Iterating over …</a>
            <ul>
              <li>
                <a href='chap06.html#leanpub-auto-number-ranges'><span class="section-number">3.12.2.1 </span>… Number ranges</a>
              </li>
              <li>
                <a href='chap06.html#leanpub-auto-enumerable-collections'><span class="section-number">3.12.2.2 </span>… Enumerable collections</a>
              </li>
              <li>
                <a href='chap06.html#leanpub-auto-thread-safe-enumerable-collections'><span class="section-number">3.12.2.3 </span>… Thread-safe enumerable collections</a>
              </li>
              <li>
                <a href='chap06.html#leanpub-auto-blocking-collections'><span class="section-number">3.12.2.4 </span>… Blocking collections</a>
              </li>
              <li>
                <a href='chap06.html#leanpub-auto-anything'><span class="section-number">3.12.2.5 </span>… Anything</a>
              </li>
            </ul>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-providing-external-input'><span class="section-number">3.12.3 </span>Providing external input</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomniparallelloop-interface'><span class="section-number">3.12.4 </span>IOmniParallelLoop interface</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-foreach-preserveorder'><span class="section-number">3.12.5 </span>Preserving output order</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-foreach-aggregation'><span class="section-number">3.12.6 </span>Aggregation</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-foreach-cancellation'><span class="section-number">3.12.7 </span>Cancellation</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-foreach-taskinit'><span class="section-number">3.12.8 </span>Task initialization and finalization</a>
          </li>
          <li>
            <a href='chap06.html#highlevel-foreach-exceptions'><span class="section-number">3.12.9 </span>Handling exceptions</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-5'><span class="section-number">3.12.10 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-forkjoin'><span class="section-number">3.13 </span>Fork/Join</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-iomniforkjoin-interface'><span class="section-number">3.13.1 </span>IOmniForkJoin interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomnicompute-interface'><span class="section-number">3.13.2 </span>IOmniCompute interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-iomnicomputet-interface'><span class="section-number">3.13.3 </span>IOmniCompute&lt;T&gt; interface</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-exceptions'><span class="section-number">3.13.4 </span>Exceptions</a>
          </li>
          <li>
            <a href='chap06.html#leanpub-auto-examples-6'><span class="section-number">3.13.5 </span>Examples</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-map'><span class="section-number">3.14 </span>Map</a>
        <ul>
          <li>
            <a href='chap06.html#leanpub-auto-iomniparallelmappert1t2-interface'><span class="section-number">3.14.1 </span>IOmniParallelMapper&lt;T1,T2&gt; interface</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap06.html#highlevel-timedtask'><span class="section-number">3.15 </span>Timed task</a>
        <ul>
          <li>
            <a href='chap06.html#highlevel-timedtask-iomnitimedtask'><span class="section-number">3.15.1 </span>IOmniTimedTask interface</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap07.html#lowlevel'><span class="section-number">4. </span>Low-level multi-threading</a>
    <ul>
      <li>
        <a href='chap07.html#leanpub-auto-low-level-for-the-impatient'><span class="section-number">4.1 </span>Low-level for the impatient</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-fourways'><span class="section-number">4.2 </span>Four ways to create a task</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-iomnitaskcontrol'><span class="section-number">4.3 </span>IOmniTaskControl and IOmniTask interfaces</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-taskControllerOwner'><span class="section-number">4.4 </span>Task controller needs an owner</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-communication'><span class="section-number">4.5 </span>Communication subsystem</a>
      </li>
      <li>
        <a href='chap07.html#leanpub-auto-processor-groups-and-numa-nodes'><span class="section-number">4.6 </span>Processor groups and NUMA nodes</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-threadpool'><span class="section-number">4.7 </span>Thread pooling</a>
        <ul>
          <li>
            <a href='chap07.html#leanpub-auto-execution-flow'><span class="section-number">4.7.1 </span>Execution flow</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-threadpool-interface'><span class="section-number">4.7.2 </span>IOmniThreadPool interface</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-threadpool-exitcode'><span class="section-number">4.7.3 </span>Task exit code</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-threadpool-monitoring'><span class="section-number">4.7.4 </span>Monitoring thread pool operations</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-processor-groups-and-numa-nodes-1'><span class="section-number">4.7.5 </span>Processor groups and NUMA nodes</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap07.html#lowlevel-lockfree'><span class="section-number">4.8 </span>Lock-free collections</a>
        <ul>
          <li>
            <a href='chap07.html#lowlevel-lockfree-boundedstack'><span class="section-number">4.8.1 </span>Bounded Stack</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-lockfree-boundedqueue'><span class="section-number">4.8.2 </span>Bounded queue</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-lockfree-messagequeue'><span class="section-number">4.8.3 </span>Message queue</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-lockfree-dynamicqueue'><span class="section-number">4.8.4 </span>Dynamic queue</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-lockfree-observing'><span class="section-number">4.8.5 </span>Observing lock-free collections</a>
            <ul>
              <li>
                <a href='chap07.html#leanpub-auto-examples-7'><span class="section-number">4.8.5.1 </span>Examples</a>
              </li>
            </ul>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-benchmarks'><span class="section-number">4.8.6 </span>Benchmarks</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap07.html#lowlevel-eventmonitor'><span class="section-number">4.9 </span>Event monitor</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-simpletasks'><span class="section-number">4.10 </span>Simple tasks</a>
        <ul>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-name'><span class="section-number">4.10.1 </span>Name</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-uniqueid'><span class="section-number">4.10.2 </span>UniqueID</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-parameters'><span class="section-number">4.10.3 </span>Parameters</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-termination'><span class="section-number">4.10.4 </span>Termination</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-exitcode'><span class="section-number">4.10.5 </span>ExitCode</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-taskexceptions'><span class="section-number">4.10.6 </span>Exceptions</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-communication'><span class="section-number">4.10.7 </span>Sending messages to a task</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-receiving'><span class="section-number">4.10.8 </span>Receiving messages from a task</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-chainto'><span class="section-number">4.10.9 </span>ChainTo</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-joinleave'><span class="section-number">4.10.10 </span>Join / Leave</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-monitorwith'><span class="section-number">4.10.11 </span>MonitorWith / RemoveMonitor</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-enforced'><span class="section-number">4.10.12 </span>Enforced</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-unobserved'><span class="section-number">4.10.13 </span>Unobserved</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-cancellationtoken'><span class="section-number">4.10.14 </span>Cancellation token / CancelWith</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-tasklock'><span class="section-number">4.10.15 </span>Lock / WithLock</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-counter'><span class="section-number">4.10.16 </span>WithCounter</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-simpletasks-setpriority'><span class="section-number">4.10.17 </span>SetPriority</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-setqueuesize'><span class="section-number">4.10.18 </span>SetQueueSize</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap07.html#lowlevel-tomniworker'><span class="section-number">4.11 </span>TOmniWorker tasks</a>
        <ul>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-waitforinit'><span class="section-number">4.11.1 </span>WaitForInit</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-task'><span class="section-number">4.11.2 </span>Task</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-communication'><span class="section-number">4.11.3 </span>Receiving messages</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-registercomm'><span class="section-number">4.11.4 </span>RegisterComm</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-tomniworkerinvoke'><span class="section-number">4.11.5 </span>Invoke</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-msgwait'><span class="section-number">4.11.6 </span>Windows message &amp; APC processing</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-timers'><span class="section-number">4.11.7 </span>Timers</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-tomniworker-terminateWhen'><span class="section-number">4.11.8 </span>TerminateWhen</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-userdata'><span class="section-number">4.11.9 </span>UserData</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap07.html#lowlevel-taskgroup'><span class="section-number">4.12 </span>Task groups</a>
      </li>
      <li>
        <a href='chap07.html#lowlevel-iomnitask'><span class="section-number">4.13 </span>IOmniTask interface</a>
        <ul>
          <li>
            <a href='chap07.html#leanpub-auto-name-and-id'><span class="section-number">4.13.1 </span>Name and ID</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-parameters'><span class="section-number">4.13.2 </span>Parameters</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-termination'><span class="section-number">4.13.3 </span>Termination</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-exitstatus'><span class="section-number">4.13.4 </span>Exit status</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-exceptions-1'><span class="section-number">4.13.5 </span>Exceptions</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-communication'><span class="section-number">4.13.6 </span>Communication</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-timers'><span class="section-number">4.13.7 </span>Timers</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-registerwaitobject'><span class="section-number">4.13.8 </span>RegisterWaitObject</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-cancellationtoken'><span class="section-number">4.13.9 </span>CancellationToken</a>
          </li>
          <li>
            <a href='chap07.html#lowlevel-iomnitask-lock'><span class="section-number">4.13.10 </span>Lock</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-counter'><span class="section-number">4.13.11 </span>Counter</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-processor-groups-and-numa-nodes-2'><span class="section-number">4.13.12 </span>Processor groups and NUMA nodes</a>
          </li>
          <li>
            <a href='chap07.html#leanpub-auto-internal-and-obsolete-functions'><span class="section-number">4.13.13 </span>Internal and obsolete functions</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap08.html#synch'><span class="section-number">5. </span>Synchronization</a>
    <ul>
      <li>
        <a href='chap08.html#synch-criticalsections'><span class="section-number">5.1 </span>Critical sections</a>
        <ul>
          <li>
            <a href='chap08.html#synch-criticalsections-iomnicriticalsection'><span class="section-number">5.1.1 </span>IOmniCriticalSection</a>
          </li>
          <li>
            <a href='chap08.html#synch-criticalsections-tomnics'><span class="section-number">5.1.2 </span>TOmniCS</a>
          </li>
          <li>
            <a href='chap08.html#synch-criticalsections-lockedt'><span class="section-number">5.1.3 </span>Locked&lt;T&gt;</a>
            <ul>
              <li>
                <a href='chap08.html#leanpub-auto-why-not-use-tmonitor'><span class="section-number">5.1.3.1 </span>Why not use TMonitor?</a>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap08.html#synch-tomnimrew'><span class="section-number">5.2 </span>TOmniMREW</a>
      </li>
      <li>
        <a href='chap08.html#synch-cancellationtoken'><span class="section-number">5.3 </span>Cancellation token</a>
      </li>
      <li>
        <a href='chap08.html#synch-waitablevalue'><span class="section-number">5.4 </span>Waitable value</a>
      </li>
      <li>
        <a href='chap08.html#synch-inversesemaphore'><span class="section-number">5.5 </span>Inverse semaphore</a>
      </li>
      <li>
        <a href='chap08.html#synch-initialization'><span class="section-number">5.6 </span>Initialization</a>
        <ul>
          <li>
            <a href='chap08.html#synch-initialization-pessimistic'><span class="section-number">5.6.1 </span>Pessimistic initialization</a>
          </li>
          <li>
            <a href='chap08.html#synch-initialization-optimistic'><span class="section-number">5.6.2 </span>Optimistic initialization</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap08.html#synch-twaitfor'><span class="section-number">5.7 </span>TWaitFor</a>
      </li>
      <li>
        <a href='chap08.html#synch-tomnilockmanager'><span class="section-number">5.8 </span>TOmniLockManager&lt;K&gt;</a>
      </li>
      <li>
        <a href='chap08.html#synch-tomnisinglethreadusechecker'><span class="section-number">5.9 </span>TOmniSingleThreadUseChecker</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap09.html#misc'><span class="section-number">6. </span>Miscellaneous</a>
    <ul>
      <li>
        <a href='chap09.html#misc-tOmniTwoWayChannel'><span class="section-number">6.1 </span>TOmniTwoWayChannel</a>
      </li>
      <li>
        <a href='chap09.html#misc-tomnivaluecontainer'><span class="section-number">6.2 </span>TOmniValueContainer</a>
      </li>
      <li>
        <a href='chap09.html#misc-tomnicounter'><span class="section-number">6.3 </span>TOmniCounter</a>
      </li>
      <li>
        <a href='chap09.html#misc-TOmniAlignedInt32'><span class="section-number">6.4 </span>TOmniAlignedInt32 and TOmniAlignedInt64</a>
      </li>
      <li>
        <a href='chap09.html#misc-tomnirecordwrapper'><span class="section-number">6.5 </span>TOmniRecordWrapper</a>
      </li>
      <li>
        <a href='chap09.html#misc-tomnirecord'><span class="section-number">6.6 </span>TOmniRecord</a>
      </li>
      <li>
        <a href='chap09.html#misc-iomniautodestroyobject'><span class="section-number">6.7 </span>IOmniAutoDestroyObject</a>
      </li>
      <li>
        <a href='chap09.html#misc-iomniintegerset'><span class="section-number">6.8 </span>IOmniIntegerSet</a>
      </li>
      <li>
        <a href='chap09.html#misc-environment'><span class="section-number">6.9 </span>Environment</a>
        <ul>
          <li>
            <a href='chap09.html#leanpub-auto-iomniaffinity'><span class="section-number">6.9.1 </span>IOmniAffinity</a>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap10.html#howto'><span class="section-number">7. </span>How-to</a>
    <ul>
      <li>
        <a href='chap10.html#howto-backgroundFileScanning'><span class="section-number">7.1 </span>Background file scanning</a>
      </li>
      <li>
        <a href='chap10.html#howto-webDownload'><span class="section-number">7.2 </span>Web download and database storage</a>
      </li>
      <li>
        <a href='chap10.html#howto-parallelForSyncOut'><span class="section-number">7.3 </span>Parallel for with synchronized output</a>
      </li>
      <li>
        <a href='chap10.html#howto-parallelForTaskInit'><span class="section-number">7.4 </span>Using taskIndex and task initializer in parallel for</a>
      </li>
      <li>
        <a href='chap10.html#howto-listPartitioning'><span class="section-number">7.5 </span>Background worker and list partitioning</a>
      </li>
      <li>
        <a href='chap10.html#howto-parallelDataProduction'><span class="section-number">7.6 </span>Parallel data production</a>
      </li>
      <li>
        <a href='chap10.html#howto-connectionPool'><span class="section-number">7.7 </span>Building a connection pool</a>
        <ul>
          <li>
            <a href='chap10.html#leanpub-auto-from-theory-to-practice'><span class="section-number">7.7.1 </span>From theory to practice</a>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-running-the-demo'><span class="section-number">7.7.2 </span>Running the demo</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap10.html#howto-quickSortParallelMax'><span class="section-number">7.8 </span>QuickSort and parallel max</a>
        <ul>
          <li>
            <a href='chap10.html#leanpub-auto-quicksort'><span class="section-number">7.8.1 </span>QuickSort</a>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-parallel-max'><span class="section-number">7.8.2 </span>Parallel max</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap10.html#howto-parallelSearch'><span class="section-number">7.9 </span>Parallel search in a tree</a>
      </li>
      <li>
        <a href='chap10.html#howto-multiFrame'><span class="section-number">7.10 </span>Multiple workers with multiple frames</a>
        <ul>
          <li>
            <a href='chap10.html#leanpub-auto-the-worker'><span class="section-number">7.10.1 </span>The worker</a>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-the-frame'><span class="section-number">7.10.2 </span>The frame</a>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-the-form'><span class="section-number">7.10.3 </span>The form</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap10.html#howto-databases'><span class="section-number">7.11 </span>OmniThreadLibrary and databases</a>
        <ul>
          <li>
            <a href='chap10.html#leanpub-auto-database-model'><span class="section-number">7.11.1 </span>Database model</a>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-frame-and-worker'><span class="section-number">7.11.2 </span>Frame and worker</a>
            <ul>
              <li>
                <a href='chap10.html#leanpub-auto-connecting-to-the-database'><span class="section-number">7.11.2.1 </span>Connecting to the database</a>
              </li>
              <li>
                <a href='chap10.html#leanpub-auto-retrieving-the-data'><span class="section-number">7.11.2.2 </span>Retrieving the data</a>
              </li>
            </ul>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-main-program'><span class="section-number">7.11.3 </span>Main program</a>
          </li>
        </ul>
      </li>
      <li>
        <a href='chap10.html#howto-com'><span class="section-number">7.12 </span>OmniThreadLibrary and COM/OLE</a>
      </li>
      <li>
        <a href='chap10.html#howto-mqtthread'><span class="section-number">7.13 </span>Using a message queue with a TThread worker</a>
        <ul>
          <li>
            <a href='chap10.html#leanpub-auto-sending-data-from-multiple-producers-to-a-single-worker'><span class="section-number">7.13.1 </span>Sending data from multiple producers to a single worker</a>
            <ul>
              <li>
                <a href='chap10.html#leanpub-auto-initialization-and-cleanup'><span class="section-number">7.13.1.1 </span>Initialization and cleanup</a>
              </li>
              <li>
                <a href='chap10.html#leanpub-auto-sending-data-to-the-worker'><span class="section-number">7.13.1.2 </span>Sending data to the worker</a>
              </li>
              <li>
                <a href='chap10.html#leanpub-auto-receiving-the-data'><span class="section-number">7.13.1.3 </span>Receiving the data</a>
              </li>
            </ul>
          </li>
          <li>
            <a href='chap10.html#leanpub-auto-sending-data-from-a-worker-to-a-form'><span class="section-number">7.13.2 </span>Sending data from a worker to a form</a>
            <ul>
              <li>
                <a href='chap10.html#leanpub-auto-initialization-and-cleanup-1'><span class="section-number">7.13.2.1 </span>Initialization and cleanup</a>
              </li>
              <li>
                <a href='chap10.html#leanpub-auto-sending-data-to-the-form'><span class="section-number">7.13.2.2 </span>Sending data to the form</a>
              </li>
              <li>
                <a href='chap10.html#leanpub-auto-receiving-the-data-1'><span class="section-number">7.13.2.3 </span>Receiving the data</a>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap11.html#appendix-units'>A. Units</a>
  </li>
  <li>
    <a href='chap12.html#demos'>B. Demo applications</a>
  </li>
  <li>
    <a href='chap13.html#examples'>C. Examples</a>
  </li>
  <li>
    <a href='chap14.html#appendix-hooking'>D. Hooking into OmniThreadLibrary</a>
    <ul>
      <li>
        <a href='chap14.html#leanpub-auto-exception-notifications'>Exception notifications</a>
      </li>
      <li>
        <a href='chap14.html#leanpub-auto-thread-notifications'>Thread notifications</a>
      </li>
      <li>
        <a href='chap14.html#leanpub-auto-pool-notifications'>Pool notifications</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap15.html#highlevel-foreach-internals'>E. ForEach internals</a>
    <ul>
      <li>
        <a href='chap15.html#leanpub-auto-source-provider'>Source provider</a>
      </li>
      <li>
        <a href='chap15.html#leanpub-auto-data-manager'>Data manager</a>
      </li>
      <li>
        <a href='chap15.html#leanpub-auto-local-queue'>Local queue</a>
      </li>
      <li>
        <a href='chap15.html#leanpub-auto-output-ordering'>Output ordering</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap16.html#leanpub-auto-f-hyperlinks'>F. Hyperlinks</a>
  </li>
  <li>
    <a href='chap17.html#leanpub-endnotes'>Notes</a>
  </li>
</ul>

</ol>
</div>
<div id="leanpub-main" class="kramdown">
<h2 id="howto">
<span class="section-number">7. </span>How-to</h2>

<p>This part of the book contains practical examples of OmniThreadLibrary usage. Each of them starts with a question that introduces the problem and continues with the discussion of the solution.</p>

<p>Following topics are covered:</p>

<ul>
  <li><a href="chap10.html#howto-backgroundFileScanning"><em>Background file scanning</em></a></li>
</ul>

<p>Scanning folders and files in a background thread.</p>

<ul>
  <li><a href="chap10.html#howto-webDownload"><em>Web download and database storage</em></a></li>
</ul>

<p>Multiple workers downloading data and storing it in a single database.</p>

<ul>
  <li><a href="chap10.html#howto-parallelForSyncOut"><em>Parallel for with synchronized output</em></a></li>
</ul>

<p>Redirecting output from a parallel for loop into a structure that doesn’t support multi-threaded access.</p>

<ul>
  <li><a href="chap10.html#howto-parallelForTaskInit"><em>Using taskIndex and task initializer in parallel for</em></a></li>
</ul>

<p>Using <code>taskIndex</code> property and task initializer delegate to provide a per-task data storage in <a href="chap06.html#highlevel-for"><em>Parallel for</em></a>.</p>

<ul>
  <li><a href="chap10.html#howto-listPartitioning"><em>Background worker and list partitioning</em></a></li>
</ul>

<p>Writing server-like background processing.</p>

<ul>
  <li><a href="chap10.html#howto-parallelDataProduction"><em>Parallel data production</em></a></li>
</ul>

<p>Multiple workers generating data and writing it into a single file.</p>

<ul>
  <li><a href="chap10.html#howto-connectionPool"><em>Building a connection pool</em></a></li>
</ul>

<p>Using OmniThreadLibrary to create a pool of database connections.</p>

<ul>
  <li><a href="chap10.html#howto-quickSortParallelMax"><em>QuickSort and parallel max</em></a></li>
</ul>

<p>How to sort an array and how to process an array using multiple threads.</p>

<ul>
  <li><a href="chap10.html#howto-parallelSearch"><em>Parallel search in a tree</em></a></li>
</ul>

<p>Finding data in a tree.</p>

<ul>
  <li><a href="chap10.html#howto-multiFrame"><em>Multiple workers with multiple frames</em></a></li>
</ul>

<p>Graphical user interface containing multiple frames where each frame is working as a front end for a background task.</p>

<ul>
  <li><a href="chap10.html#howto-databases"><em>OmniThreadLibrary and databases</em></a></li>
</ul>

<p>Using databases from OmniThreadLibrary.</p>

<ul>
  <li><a href="chap10.html#howto-com"><em>OmniThreadLibrary and COM/OLE</em></a></li>
</ul>

<p>Using COM/OLE from OmniThreadLibrary.</p>

<ul>
  <li><a href="chap10.html#howto-mqtthread"><em>Using a message queue with a TThread worker</em></a></li>
</ul>

<p>Using OmniThreadLibrary’s <code>TOmniMessageQueue</code> to communicate with a TThread worker.</p>


<div class="page-break"></div>
<h3 id="howto-backgroundFileScanning">
<span class="section-number">7.1 </span>Background file scanning</h3>

<aside>
  <p><em>I’m looking into a way to do a longer operation (e.g. searching files on a drive) inside a thread to keep the main application responsive. With Delphi’s <code>TThread</code> I would override the <code>Execute</code> method. But that’s not good enough as the normal user would like to see a progress bar. It would also be great if the user could abort the search.</em></p>

</aside>

<p>This solution uses low-level part of the OmniThreadLibrary to implement a file scanner application. It is also available as a <a href="chap12.html#demos">demo</a> application <code>23_BackgroundFilesearch</code>.</p>

<p>The user interface is intentionally simple.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 60%;">
    <img src="images/backgroundFileSearch.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<p>User enters a path and file mask in the edit field and clicks <em>Scan</em>. The application starts a background task which scans the file system and reports found files back to the application where they are displayed in the listbox.</p>

<p>During the scanning, main thread stays responsive. You can move the program around, resize it, minimize, maximize and so on.</p>

<p>Besides the components visible at runtime, the form contains two components – a <a href="chap07.html#lowlevel-simpletasks-monitorwith"><code>TOmniEventMonitor</code></a> named <code>OTLMonitor</code> and a <code>TTimer</code> called <code>tmrDisplayStatus</code>.</p>

<p>When the user clicks the <em>Scan</em> button, a background task is created.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmBackgroundFileSearchDemo</code><code class="o">.</code><code class="nf">btnScanClick</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="n">FFileList</code> <code class="o">:=</code> <code class="n">TStringList</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">btnScan</code><code class="o">.</code><code class="n">Enabled</code> <code class="o">:=</code> <code class="k">false</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="n">tmrDisplayStatus</code><code class="o">.</code><code class="n">Enabled</code> <code class="o">:=</code> <code class="k">true</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="n">FScanTask</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">ScanFolders</code><code class="o">,</code> <code class="s">'ScanFolders'</code><code class="p">)</code>
<code class="lineno"> 7 </code>    <code class="o">.</code><code class="n">MonitorWith</code><code class="p">(</code><code class="n">OTLMonitor</code><code class="p">)</code>
<code class="lineno"> 8 </code>    <code class="o">.</code><code class="n">SetParameter</code><code class="p">(</code><code class="s">'FolderMask'</code><code class="o">,</code> <code class="n">inpFolderMask</code><code class="o">.</code><code class="n">Text</code><code class="p">)</code>
<code class="lineno"> 9 </code>    <code class="o">.</code><code class="n">Run</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>ScanFolders</code> is the method that will do the scanning (in a background thread). Task will be monitored with the <code>OTLMonitor</code> component which will receive task messages. <code>OTLMonitor</code> will also tell us when the task has terminated. Input folder and mask are sent to the task as a parameter <code>FolderMask</code> and task is started.</p>

<p>The <code>FFileList</code> field is a <code>TStringList</code> that will contain a list of all found files.</p>

<p>Let’s ignore the scanner details for the moment and skip to the end of the scanning process. When the task has completed its job, <code>OTLMonitor.OnTaskTerminated</code> is called.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmBackgroundFileSearchDemo</code><code class="o">.</code><code class="nf">OTLMonitorTaskTerminated</code><code class="p">(</code>
<code class="lineno"> 2 </code>  <code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="k">begin</code>
<code class="lineno"> 4 </code>  <code class="n">tmrDisplayStatus</code><code class="o">.</code><code class="n">Enabled</code> <code class="o">:=</code> <code class="k">false</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="n">outScanning</code><code class="o">.</code><code class="n">Text</code> <code class="o">:=</code> <code class="s">''</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="n">outFiles</code><code class="o">.</code><code class="n">Text</code> <code class="o">:=</code> <code class="nb">IntToStr</code><code class="p">(</code><code class="n">FFileList</code><code class="o">.</code><code class="n">Count</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="n">lbFiles</code><code class="o">.</code><code class="n">Clear</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="n">lbFiles</code><code class="o">.</code><code class="n">Items</code><code class="o">.</code><code class="n">AddStrings</code><code class="p">(</code><code class="n">FFileList</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">FFileList</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">10 </code>  <code class="n">FScanTask</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="n">btnScan</code><code class="o">.</code><code class="n">Enabled</code> <code class="o">:=</code> <code class="k">true</code><code class="o">;</code>
<code class="lineno">12 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>At that point, the number of found files is copied to the <em>outFiles</em> edit field and the complete list is assigned to the listbox. Task reference <code>FScanTask</code> is then cleared, which causes the task object to be destroyed and Scan button is re-enabled (it was disabled during the scanning process).</p>

<p>We should also handle the possibility of user closing the program by clicking the ‘X’ button while the background scanner is active. We must catch the <code>OnFormCloseQuery</code> event and tell the task to terminate.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmBackgroundFileSearchDemo</code><code class="o">.</code><code class="nf">FormCloseQuery</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="o">;</code>
<code class="lineno">2 </code>  <code class="k">var</code> <code class="n">CanClose</code><code class="o">:</code> <code class="kt">boolean</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">3 </code><code class="k">begin</code>
<code class="lineno">4 </code>  <code class="k">if</code> <code class="nb">assigned</code><code class="p">(</code><code class="n">FScanTask</code><code class="p">)</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno">5 </code>    <code class="n">FScanTask</code><code class="o">.</code><code class="n">Terminate</code><code class="o">;</code>
<code class="lineno">6 </code>    <code class="n">FScanTask</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
<code class="lineno">7 </code>    <code class="n">CanClose</code> <code class="o">:=</code> <code class="k">true</code><code class="o">;</code>
<code class="lineno">8 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">9 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The <code>Terminate</code> method will do two things – tell the task to terminate and then wait for its termination. After that, we simply have to clear the task reference and allow the program to terminate.</p>

<p>Let’s move to the scanning part now. The <code>ScanFolders</code> method (which is the main task method, the one we passed to the <code>CreateTask</code>) splits the value of the <code>FolderMask</code> parameter into the folder and mask parts and passes them to the main worker method <code>ScanFolder</code>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">ScanFolders</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">folder</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">mask</code>  <code class="o">:</code> <code class="k">string</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="n">mask</code> <code class="o">:=</code> <code class="n">task</code><code class="o">.</code><code class="n">ParamByName</code><code class="p">[</code><code class="s">'FolderMask'</code><code class="p">]</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="n">folder</code> <code class="o">:=</code> <code class="nb">ExtractFilePath</code><code class="p">(</code><code class="n">mask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="nb">Delete</code><code class="p">(</code><code class="n">mask</code><code class="o">,</code> <code class="mi">1</code><code class="o">,</code> <code class="nb">Length</code><code class="p">(</code><code class="n">folder</code><code class="p">))</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="k">if</code> <code class="n">folder</code> <code class="o">&lt;&gt;</code> <code class="s">''</code> <code class="k">then</code>
<code class="lineno">10 </code>    <code class="n">folder</code> <code class="o">:=</code> <code class="nb">IncludeTrailingPathDelimiter</code><code class="p">(</code><code class="n">folder</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="n">ScanFolder</code><code class="p">(</code><code class="n">task</code><code class="o">,</code> <code class="n">folder</code><code class="o">,</code> <code class="n">mask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>ScanFolder</code> first finds all subfolders of the selected folder and calls itself recursively for each subfolder. Because of that, we’ll first process deepest folders and then proceed to the top of the folder tree.</p>

<p>Then it sends a message <code>MSG_SCAN_FOLDER</code> to the main thread. As a parameter of this message it sends the name of the folder being processed. There’s nothing magical about this message – it is just an arbitrary numeric constant from range <em>0..65534</em> (number <em>65535</em> is reserved for internal OmniThreadLibrary use).</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">const</code>
<code class="lineno"> 2 </code>  <code class="n">MSG_SCAN_FOLDER</code>  <code class="o">=</code> <code class="mi">1</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">MSG_FOLDER_FILES</code> <code class="o">=</code> <code class="mi">2</code><code class="o">;</code>
<code class="lineno"> 4 </code>
<code class="lineno"> 5 </code><code class="k">procedure</code> <code class="nf">ScanFolder</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="o">;</code> <code class="k">const</code> <code class="n">folder</code><code class="o">,</code> <code class="n">mask</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 6 </code><code class="k">var</code>
<code class="lineno"> 7 </code>  <code class="n">err</code>        <code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="n">folderFiles</code><code class="o">:</code> <code class="n">TStringList</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="n">S</code>          <code class="o">:</code> <code class="n">TSearchRec</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">begin</code>
<code class="lineno">11 </code>  <code class="n">err</code> <code class="o">:=</code> <code class="nb">FindFirst</code><code class="p">(</code><code class="n">folder</code> <code class="o">+</code> <code class="s">'*.*'</code><code class="o">,</code> <code class="n">faDirectory</code><code class="o">,</code> <code class="n">S</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="k">if</code> <code class="n">err</code> <code class="o">=</code> <code class="mi">0</code> <code class="k">then</code> <code class="k">try</code>
<code class="lineno">13 </code>    <code class="k">repeat</code>
<code class="lineno">14 </code>      <code class="k">if</code> <code class="p">((</code><code class="n">S</code><code class="o">.</code><code class="n">Attr</code> <code class="k">and</code> <code class="n">faDirectory</code><code class="p">)</code> <code class="o">&lt;&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="k">and</code> <code class="p">(</code><code class="n">S</code><code class="o">.</code><code class="n">Name</code> <code class="o">&lt;&gt;</code> <code class="s">'.'</code><code class="p">)</code> <code class="k">and</code> 
<code class="lineno">15 </code>         <code class="p">(</code><code class="n">S</code><code class="o">.</code><code class="n">Name</code> <code class="o">&lt;&gt;</code> <code class="s">'..'</code><code class="p">)</code> 
<code class="lineno">16 </code>      <code class="k">then</code>
<code class="lineno">17 </code>        <code class="n">ScanFolder</code><code class="p">(</code><code class="n">task</code><code class="o">,</code> <code class="n">folder</code> <code class="o">+</code> <code class="n">S</code><code class="o">.</code><code class="n">Name</code> <code class="o">+</code> <code class="s">'\'</code><code class="o">,</code> <code class="n">mask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">18 </code>      <code class="n">err</code> <code class="o">:=</code> <code class="nb">FindNext</code><code class="p">(</code><code class="n">S</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">19 </code>    <code class="k">until</code> <code class="n">task</code><code class="o">.</code><code class="n">Terminated</code> <code class="k">or</code> <code class="p">(</code><code class="n">err</code> <code class="o">&lt;&gt;</code> <code class="mi">0</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">20 </code>  <code class="k">finally</code> <code class="nb">FindClose</code><code class="p">(</code><code class="n">S</code><code class="p">)</code><code class="o">;</code> <code class="k">end</code><code class="o">;</code>
<code class="lineno">21 </code>  <code class="n">task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="n">MSG_SCAN_FOLDER</code><code class="o">,</code> <code class="n">folder</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">22 </code>  <code class="n">folderFiles</code> <code class="o">:=</code> <code class="n">TStringList</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">23 </code>  <code class="k">try</code>
<code class="lineno">24 </code>    <code class="n">err</code> <code class="o">:=</code> <code class="nb">FindFirst</code><code class="p">(</code><code class="n">folder</code> <code class="o">+</code> <code class="n">mask</code><code class="o">,</code> <code class="mi">0</code><code class="o">,</code> <code class="n">S</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">25 </code>    <code class="k">if</code> <code class="n">err</code> <code class="o">=</code> <code class="mi">0</code> <code class="k">then</code> <code class="k">try</code>
<code class="lineno">26 </code>      <code class="k">repeat</code>
<code class="lineno">27 </code>        <code class="n">folderFiles</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">folder</code> <code class="o">+</code> <code class="n">S</code><code class="o">.</code><code class="n">Name</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">28 </code>        <code class="n">err</code> <code class="o">:=</code> <code class="nb">FindNext</code><code class="p">(</code><code class="n">S</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">29 </code>      <code class="k">until</code> <code class="n">task</code><code class="o">.</code><code class="n">Terminated</code> <code class="k">or</code> <code class="p">(</code><code class="n">err</code> <code class="o">&lt;&gt;</code> <code class="mi">0</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">30 </code>    <code class="k">finally</code> <code class="nb">FindClose</code><code class="p">(</code><code class="n">S</code><code class="p">)</code><code class="o">;</code> <code class="k">end</code><code class="o">;</code>
<code class="lineno">31 </code>  <code class="k">finally</code> <code class="n">task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="n">MSG_FOLDER_FILES</code><code class="o">,</code> <code class="n">folderFiles</code><code class="p">)</code><code class="o">;</code> <code class="k">end</code><code class="o">;</code>
<code class="lineno">32 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>ScanFolder</code> then runs the <code>FindFirst</code>/<code>FindNext</code>/<code>FindClose</code> loop for the second time to search for files in the folder. [BTW, if you want to first scan folders nearer to the root, just exchange the two loops and scan for files first and for folders second.] Each file is added to an internal <code>TStringList</code> object which was created just a moment before. When a folder scan is completed, this object is sent to the main thread as a parameter of the <code>MSG_FOLDER_FILES</code> message.</p>

<p>This approach – sending data for one folder – is a compromise between returning the complete set (full scanned tree), which would not provide a good feedback, and returning each file as we detect it, which would unnecessarily put a high load on the system.</p>

<p>Both <code>Find</code> loops test the state of the <code>task.Terminated</code> function and exit immediately if it is <code>True</code>. That allows us to terminate the background task when the user closes the application and the <code>OnFormCloseQuery</code> is called.</p>

<p>That’s all that has to be done in the background task but we still have to process the messages in the main thread. For that, we have to implement the <code>OTLMonitor</code>’s <code>OnTaskMessage</code> event.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmBackgroundFileSearchDemo</code><code class="o">.</code><code class="nf">OTLMonitorTaskMessage</code><code class="p">(</code>
<code class="lineno"> 2 </code>  <code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="k">var</code>
<code class="lineno"> 4 </code>  <code class="n">folderFiles</code><code class="o">:</code> <code class="n">TStringList</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="n">msg</code>        <code class="o">:</code> <code class="n">TOmniMessage</code><code class="o">;</code>
<code class="lineno"> 6 </code><code class="k">begin</code>
<code class="lineno"> 7 </code>  <code class="n">task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Receive</code><code class="p">(</code><code class="n">msg</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="k">if</code> <code class="n">msg</code><code class="o">.</code><code class="n">MsgID</code> <code class="o">=</code> <code class="n">MSG_SCAN_FOLDER</code> <code class="k">then</code>
<code class="lineno"> 9 </code>    <code class="n">FWaitingMessage</code> <code class="o">:=</code> <code class="n">msg</code><code class="o">.</code><code class="n">MsgData</code>
<code class="lineno">10 </code>  <code class="k">else</code> <code class="k">if</code> <code class="n">msg</code><code class="o">.</code><code class="n">MsgID</code> <code class="o">=</code> <code class="n">MSG_FOLDER_FILES</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno">11 </code>    <code class="n">folderFiles</code> <code class="o">:=</code> <code class="n">TStringList</code><code class="p">(</code><code class="n">msg</code><code class="o">.</code><code class="n">MsgData</code><code class="o">.</code><code class="n">AsObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="n">FFileList</code><code class="o">.</code><code class="n">AddStrings</code><code class="p">(</code><code class="n">folderFiles</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code>    <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">folderFiles</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">14 </code>    <code class="n">FWaitingCount</code> <code class="o">:=</code> <code class="nb">IntToStr</code><code class="p">(</code><code class="n">FFileList</code><code class="o">.</code><code class="n">Count</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">15 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">16 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>If the message is <code>MSG_SCAN_FOLDER</code> we just copy folder name to a local field. If the message is <code>MSG_FOLDER_FILES</code>, we copy file names from the parameter (which is a <code>TStringList</code>) to the global <code>FFileList</code> list and destroy the parameter. We also update a local field holding the number of currently found files.</p>

<p>Why don’t we directly update two edit fields on the form (one containing the current folder and another the number of found files)? The background task can send many messages in one second (when processing folders with a few files) and there’s no point in displaying them all – the user will never see what was displayed, anyway. It would also slow down the GUI because Windows controls would be updated hundreds of times per second, which is never a good idea. </p>

<p>Instead of that we store the strings to be displayed in two form fields and display them from a timer which is triggered three times per second. That will not show all scanned folders and all intermediate file count results, but will still provide the user with the sufficient feedback. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmBackgroundFileSearchDemo</code><code class="o">.</code><code class="nf">tmrDisplayStatusTimer</code><code class="p">(</code>
<code class="lineno"> 2 </code>  <code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="k">begin</code>
<code class="lineno"> 4 </code>  <code class="k">if</code> <code class="n">FWaitingMessage</code> <code class="o">&lt;&gt;</code> <code class="s">''</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno"> 5 </code>    <code class="n">outScanning</code><code class="o">.</code><code class="n">Text</code> <code class="o">:=</code> <code class="n">FWaitingMessage</code><code class="o">;</code>
<code class="lineno"> 6 </code>    <code class="n">FWaitingMessage</code> <code class="o">:=</code> <code class="s">''</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="k">if</code> <code class="n">FWaitingCount</code> <code class="o">&lt;&gt;</code> <code class="s">''</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno"> 9 </code>    <code class="n">outFiles</code><code class="o">.</code><code class="n">Text</code> <code class="o">:=</code> <code class="n">FWaitingCount</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="n">FWaitingCount</code> <code class="o">:=</code> <code class="s">''</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">12 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>


<div class="page-break"></div>
<h3 id="howto-webDownload">
<span class="section-number">7.2 </span>Web download and database storage</h3>

<aside>
  <p><em>I need to download a list of web pages, extract data from them and then store this data in a SQLite database. The downloading/extracting part will happen in multiple threads (I’m using Synapse), but querying the database needs to be done asynchronously as I can only have one concurrent access to it.</em></p>

</aside>

<p>The simplest approach is to create a <a href="chap06.html#highlevel-pipeline"><em>Pipeline</em></a> with two stages – multiple http retrievers in the first stage and one database writer in the second stage. The number of concurrent http retrievers would have to be determined with some testing. It will depend on the throughput of the internet connection and on the quantity of the post-processing done on the retrieved pages.</p>

<p>First pipeline stage, <code>Retriever</code>, fetches contents of one page. If the page is fetched correctly, a page description object (not shown in this demo) is created and sent to the output pipeline. Internally (not shown in this demo), <code>TPage.Create</code> could parse the page and extract the data. </p>

<p>As there can be at most one output generated for each input, this stage is implemented as a <em>simple stage</em> meaning that the <em>Pipeline</em> itself will loop over the input data and call the <code>Retriever</code> for each input.</p>

<p>Second stage, <code>Inserter</code>, is implemented as a normal stage (so it has to loop internally over all input data). First it establishes a connection to the database, then it loops over all input values (over data from all successfully retrieved pages) and inserts each result into the database. At the end (when there is no more data to process) it closes the database connection.</p>

<p>Main method (<code>ParallelWebRetriever</code>) first sets up and starts the pipeline. Next it feeds URLs to be retrieved into the input pipeline and marks the input pipeline as <em>completed</em>. At the end it waits for the pipeline to complete.</p>

<p>The program will execute as follows:</p>

<ul>
  <li>
<code>ParallelWebRetriever</code> starts the pipeline.</li>
  <li>OmniThreadLibrary sets up tasks for the pipeline; there will be twice as many first-stage tasks as there are cores accessible from the process (this value was determined by guessing and would probably have to be adjusted in the real application) and only one task running the second stage. </li>
  <li>
<code>ParallelWebRetriever</code> starts inserting URLs into the pipeline’s input queue.</li>
  <li>First-stage tasks immediately start processing these URLs and retrieving data from the web.</li>
  <li>At some moment, <code>ParallelWebRetriever</code> will run out of URLs and mark pipeline’s input as <em>completed</em>.</li>
  <li>One by one, first-stage tasks will finish processing the data. Each will send the data to the second stage over the pipeline and fetch new URL from the input queue.</li>
  <li>Second stage will read processed data item by item and write each item into the database. If it runs out of data to store (maybe the internet is slow today) it will wait for the next data item to appear in the pipeline.</li>
  <li>When a first-stage task finishes a job and there’s no more data in the pipeline’s input queue, it will immediately exit because the pipeline’s input is marked <em>completed</em>.</li>
  <li>After all first-stage tasks exit (because of lack of the input data), <em>Pipeline</em> will detect this and mark the queue leading to the second stage as <em>completed</em>.</li>
  <li>After that, second stage will process all remaining items in its input queue and then exit.</li>
  <li>This will shut down the pipeline and <code>WaitFor</code> call will exit.</li>
</ul>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">uses</code>
<code class="lineno"> 2 </code>  <code class="n">OtlCommon</code><code class="o">,</code>
<code class="lineno"> 3 </code>  <code class="n">OtlCollections</code><code class="o">,</code>
<code class="lineno"> 4 </code>  <code class="n">OtlParallel</code><code class="o">;</code>
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code><code class="k">function</code> <code class="nf">HttpGet</code><code class="p">(</code><code class="n">url</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code> <code class="k">var</code> <code class="n">page</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno"> 7 </code><code class="k">begin</code>
<code class="lineno"> 8 </code>  <code class="c1">// retrieve page contents from the url; return False if page is not accessible</code>
<code class="lineno"> 9 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">10 </code>
<code class="lineno">11 </code><code class="k">procedure</code> <code class="nf">Retriever</code><code class="p">(</code><code class="k">const</code> <code class="n">input</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code> <code class="k">var</code> <code class="n">output</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code><code class="k">var</code>
<code class="lineno">13 </code>  <code class="n">pageContents</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code>
<code class="lineno">14 </code><code class="k">begin</code>
<code class="lineno">15 </code>  <code class="k">if</code> <code class="n">HttpGet</code><code class="p">(</code><code class="n">input</code><code class="o">.</code><code class="n">AsString</code><code class="o">,</code> <code class="n">pageContents</code><code class="p">)</code> <code class="k">then</code>
<code class="lineno">16 </code>    <code class="n">output</code> <code class="o">:=</code> <code class="n">TPage</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="n">input</code><code class="o">.</code><code class="n">AsString</code><code class="o">,</code> <code class="n">pageContents</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">17 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">18 </code>
<code class="lineno">19 </code><code class="k">procedure</code> <code class="nf">Inserter</code><code class="p">(</code><code class="k">const</code> <code class="n">input</code><code class="o">,</code> <code class="n">output</code><code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">20 </code><code class="k">var</code>
<code class="lineno">21 </code>  <code class="n">page</code>   <code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno">22 </code>  <code class="n">pageObj</code><code class="o">:</code> <code class="n">TPage</code><code class="o">;</code>
<code class="lineno">23 </code><code class="k">begin</code>
<code class="lineno">24 </code>  <code class="c1">// connect to database</code>
<code class="lineno">25 </code>  <code class="k">for</code> <code class="n">page</code> <code class="k">in</code> <code class="n">input</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">26 </code>    <code class="n">pageObj</code> <code class="o">:=</code> <code class="n">TPage</code><code class="p">(</code><code class="n">page</code><code class="o">.</code><code class="n">AsObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">27 </code>    <code class="c1">// insert pageObj into database</code>
<code class="lineno">28 </code>    <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">pageObj</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">29 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">30 </code>  <code class="c1">// close database connection</code>
<code class="lineno">31 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">32 </code>
<code class="lineno">33 </code><code class="k">procedure</code> <code class="nf">ParallelWebRetriever</code><code class="o">;</code>
<code class="lineno">34 </code><code class="k">var</code>
<code class="lineno">35 </code>  <code class="n">pipeline</code><code class="o">:</code> <code class="n">IOmniPipeline</code><code class="o">;</code>
<code class="lineno">36 </code>  <code class="n">s</code>       <code class="o">:</code> <code class="k">string</code><code class="o">;</code>
<code class="lineno">37 </code>  <code class="n">urlList</code> <code class="o">:</code> <code class="n">TStringList</code><code class="o">;</code>
<code class="lineno">38 </code><code class="k">begin</code>
<code class="lineno">39 </code>  <code class="c1">// set up pipeline</code>
<code class="lineno">40 </code>  <code class="n">pipeline</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">Pipeline</code>
<code class="lineno">41 </code>    <code class="o">.</code><code class="n">Stage</code><code class="p">(</code><code class="n">Retriever</code><code class="p">)</code><code class="o">.</code><code class="n">NumTasks</code><code class="p">(</code><code class="n">Environment</code><code class="o">.</code><code class="n">Process</code><code class="o">.</code><code class="n">Affinity</code><code class="o">.</code><code class="n">Count</code> <code class="o">*</code> <code class="mi">2</code><code class="p">)</code>
<code class="lineno">42 </code>    <code class="o">.</code><code class="n">Stage</code><code class="p">(</code><code class="n">Inserter</code><code class="p">)</code>
<code class="lineno">43 </code>    <code class="o">.</code><code class="n">Run</code><code class="o">;</code>
<code class="lineno">44 </code>  <code class="c1">// insert URLs to be retrieved</code>
<code class="lineno">45 </code>  <code class="k">for</code> <code class="n">s</code> <code class="k">in</code> <code class="n">urlList</code> <code class="k">do</code>
<code class="lineno">46 </code>    <code class="n">pipeline</code><code class="o">.</code><code class="n">Input</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">s</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">47 </code>  <code class="n">pipeline</code><code class="o">.</code><code class="n">Input</code><code class="o">.</code><code class="n">CompleteAdding</code><code class="o">;</code>
<code class="lineno">48 </code>  <code class="c1">// wait for pipeline to complete</code>
<code class="lineno">49 </code>  <code class="n">pipeline</code><code class="o">.</code><code class="n">WaitFor</code><code class="p">(</code><code class="n">INFINITE</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">50 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>


<div class="page-break"></div>
<h3 id="howto-parallelForSyncOut">
<span class="section-number">7.3 </span>Parallel for with synchronized output</h3>

<aside>
  <p><em>I’m using the <code>Parallel.ForEach</code> method for parsing a file. The items in the file are bank statements with corresponding transactions.</em></p>

  <p><em>I want to parse all the bank statements and add the resulting data to a general <code>TList&lt;T&gt;</code> containing all the parsed data.</em></p>

  <p><em>I know that adding a <code>T</code> to a <code>TList&lt;T&gt;</code> is the problem but I have no idea how to solve it.</em></p>

</aside>

<p>The best way is to use built-in capabilities of the <a href="chap06.html#highlevel-foreach"><em>For Each</em></a> abstraction which allows you to write data to a shared <a href="chap06.html#highlevel-blocking-collection">blocking collection</a>. Your program could then read data from this blocking collection and repack it to a <code>TList&lt;T&gt;</code>.</p>

<aside class="information blurb">
    <p><em>A solution to this problem is included with the OmniThreadLibrary distribution in the <code>examples/forEach output</code> folder.</em></p>

</aside>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">ProcessTransactions</code><code class="p">(</code><code class="n">input</code><code class="o">:</code> <code class="n">TStringList</code><code class="o">;</code> <code class="n">output</code><code class="o">:</code> <code class="n">TList</code><code class="o">&lt;</code><code class="n">TTransaction</code><code class="o">&gt;</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">outQueue</code>   <code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">transaction</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="n">outQueue</code> <code class="o">:=</code> <code class="n">TOmniBlockingCollection</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="p">(</code><code class="mi">0</code><code class="o">,</code> <code class="n">input</code><code class="o">.</code><code class="n">Count</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code>
<code class="lineno"> 8 </code>    <code class="o">.</code><code class="n">NoWait</code>
<code class="lineno"> 9 </code>    <code class="o">.</code><code class="n">PreserveOrder</code>
<code class="lineno">10 </code>    <code class="o">.</code><code class="n">Into</code><code class="p">(</code><code class="n">outQueue</code><code class="p">)</code>
<code class="lineno">11 </code>    <code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">12 </code>      <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="k">var</code> <code class="bp">result</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno">13 </code>      <code class="k">begin</code>
<code class="lineno">14 </code>        <code class="bp">result</code> <code class="o">:=</code> <code class="n">TTransaction</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="n">input</code><code class="p">[</code><code class="n">value</code><code class="p">])</code><code class="o">;</code>
<code class="lineno">15 </code>      <code class="k">end</code>
<code class="lineno">16 </code>    <code class="p">)</code><code class="o">;</code>
<code class="lineno">17 </code>  <code class="k">for</code> <code class="n">transaction</code> <code class="k">in</code> <code class="n">outQueue</code> <code class="k">do</code>
<code class="lineno">18 </code>    <code class="n">output</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">transaction</code><code class="o">.</code><code class="n">AsObject</code> <code class="k">as</code> <code class="n">TTransaction</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">19 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The code first creates a blocking collection that will ‘pipe out’ data from the <em>For Each</em> abstraction. </p>

<p>Next it starts a parallel for loop. It will iterate over all elements in the <code>input</code> list (<code>ForEach</code>), will preserve the order of the original items (<code>PreserveOrder</code>) and will write output into the blocking collection (<code>Into</code>). It will also run in background without waiting for all input to be processed (<code>NoWait</code>) so that the code in the main thread (<code>for transaction in</code>) can continue executing in parallel with the <code>ForEach</code>.</p>

<p>The parallel for worker code just creates a <code>TTransaction</code> object from the input line and stores it in the <code>result</code> variable. <code>ForEach</code> code will take this <code>result</code> and store it in the <code>outQueue</code>. If you don’t want to produce a result for the given input value, just don’t set the <code>result</code> variable.</p>

<p>This code also solves the stopping problem. The <code>for transaction in</code> loop will run until all the input is processed. Only when the <code>ForEach</code> is truly finished, the <code>for transaction in</code> will exit, <code>ProcessTransaction</code> will also exit and the object running the parallel for loop will be automatically destroyed.</p>

<p>Below is the full code for a test program, implemented in a single form with a single component – <em>ListBox1</em>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">unit</code> <code class="n">ForEachOutput1</code><code class="o">;</code>
<code class="lineno"> 2 </code>
<code class="lineno"> 3 </code><code class="k">interface</code>
<code class="lineno"> 4 </code>
<code class="lineno"> 5 </code><code class="k">uses</code>
<code class="lineno"> 6 </code>  <code class="n">Winapi</code><code class="o">.</code><code class="n">Windows</code><code class="o">,</code> <code class="n">Winapi</code><code class="o">.</code><code class="n">Messages</code><code class="o">,</code> <code class="n">System</code><code class="o">.</code><code class="n">SysUtils</code><code class="o">,</code> <code class="n">System</code><code class="o">.</code><code class="n">Variants</code><code class="o">,</code> 
<code class="lineno"> 7 </code>  <code class="n">System</code><code class="o">.</code><code class="n">Classes</code><code class="o">,</code> <code class="n">Vcl</code><code class="o">.</code><code class="n">Graphics</code><code class="o">,</code> <code class="n">Vcl</code><code class="o">.</code><code class="n">Controls</code><code class="o">,</code> <code class="n">Vcl</code><code class="o">.</code><code class="n">Forms</code><code class="o">,</code> <code class="n">Vcl</code><code class="o">.</code><code class="n">Dialogs</code><code class="o">,</code> 
<code class="lineno"> 8 </code>  <code class="n">Vcl</code><code class="o">.</code><code class="n">StdCtrls</code><code class="o">,</code> <code class="n">Generics</code><code class="o">.</code><code class="n">Collections</code><code class="o">,</code>
<code class="lineno"> 9 </code>  <code class="n">OtlCommon</code><code class="o">,</code>
<code class="lineno">10 </code>  <code class="n">OtlCollections</code><code class="o">,</code>
<code class="lineno">11 </code>  <code class="n">OtlParallel</code><code class="o">;</code>
<code class="lineno">12 </code>
<code class="lineno">13 </code><code class="k">type</code>
<code class="lineno">14 </code>  <code class="n">TTransaction</code> <code class="o">=</code> <code class="k">class</code>
<code class="lineno">15 </code>    <code class="n">Transaction</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code>
<code class="lineno">16 </code>    <code class="k">constructor</code> <code class="nf">Create</code><code class="p">(</code><code class="k">const</code> <code class="n">transact</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">17 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">18 </code>
<code class="lineno">19 </code>  <code class="n">TfrmForEachOutput</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TForm</code><code class="p">)</code>
<code class="lineno">20 </code>    <code class="n">ListBox1</code><code class="o">:</code> <code class="n">TListBox</code><code class="o">;</code>
<code class="lineno">21 </code>    <code class="k">procedure</code> <code class="nf">FormCreate</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">22 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">23 </code>
<code class="lineno">24 </code><code class="k">var</code>
<code class="lineno">25 </code>  <code class="n">frmForEachOutput</code><code class="o">:</code> <code class="n">TfrmForEachOutput</code><code class="o">;</code>
<code class="lineno">26 </code>
<code class="lineno">27 </code><code class="k">implementation</code>
<code class="lineno">28 </code>
<code class="lineno">29 </code><code class="cm">{$R *.dfm}</code>
<code class="lineno">30 </code>
<code class="lineno">31 </code><code class="k">procedure</code> <code class="nf">ProcessTransactions</code><code class="p">(</code><code class="n">input</code><code class="o">:</code> <code class="n">TStringList</code><code class="o">;</code> 
<code class="lineno">32 </code>  <code class="n">output</code><code class="o">:</code> <code class="n">TList</code><code class="o">&lt;</code><code class="n">TTransaction</code><code class="o">&gt;</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">33 </code><code class="k">var</code>
<code class="lineno">34 </code>  <code class="n">outQueue</code>   <code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="o">;</code>
<code class="lineno">35 </code>  <code class="n">transaction</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno">36 </code><code class="k">begin</code>
<code class="lineno">37 </code>  <code class="n">outQueue</code> <code class="o">:=</code> <code class="n">TOmniBlockingCollection</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">38 </code>  <code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="p">(</code><code class="mi">0</code><code class="o">,</code> <code class="n">input</code><code class="o">.</code><code class="n">Count</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code>
<code class="lineno">39 </code>    <code class="o">.</code><code class="n">NoWait</code>
<code class="lineno">40 </code>    <code class="o">.</code><code class="n">PreserveOrder</code>
<code class="lineno">41 </code>    <code class="o">.</code><code class="n">Into</code><code class="p">(</code><code class="n">outQueue</code><code class="p">)</code>
<code class="lineno">42 </code>    <code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">43 </code>      <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="k">var</code> <code class="bp">result</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno">44 </code>      <code class="k">begin</code>
<code class="lineno">45 </code>        <code class="bp">result</code> <code class="o">:=</code> <code class="n">TTransaction</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="n">input</code><code class="p">[</code><code class="n">value</code><code class="p">])</code><code class="o">;</code>
<code class="lineno">46 </code>      <code class="k">end</code>
<code class="lineno">47 </code>    <code class="p">)</code><code class="o">;</code>
<code class="lineno">48 </code>  <code class="k">for</code> <code class="n">transaction</code> <code class="k">in</code> <code class="n">outQueue</code> <code class="k">do</code>
<code class="lineno">49 </code>    <code class="n">output</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">transaction</code><code class="o">.</code><code class="n">AsObject</code> <code class="k">as</code> <code class="n">TTransaction</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">50 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">51 </code>
<code class="lineno">52 </code><code class="k">procedure</code> <code class="nc">TfrmForEachOutput</code><code class="o">.</code><code class="nf">FormCreate</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">53 </code><code class="k">var</code>
<code class="lineno">54 </code>  <code class="n">bankStatements</code><code class="o">:</code> <code class="n">TStringList</code><code class="o">;</code>
<code class="lineno">55 </code>  <code class="n">ch</code>            <code class="o">:</code> <code class="kt">char</code><code class="o">;</code>
<code class="lineno">56 </code>  <code class="n">transaction</code>   <code class="o">:</code> <code class="n">TTransaction</code><code class="o">;</code>
<code class="lineno">57 </code>  <code class="n">transactions</code>  <code class="o">:</code> <code class="n">TList</code><code class="o">&lt;</code><code class="n">TTransaction</code><code class="o">&gt;;</code>
<code class="lineno">58 </code><code class="k">begin</code>
<code class="lineno">59 </code>  <code class="n">bankStatements</code> <code class="o">:=</code> <code class="n">TStringList</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">60 </code>  <code class="k">try</code>
<code class="lineno">61 </code>    <code class="k">for</code> <code class="n">ch</code> <code class="o">:=</code> <code class="s">'1'</code> <code class="k">to</code> <code class="s">'9'</code> <code class="k">do</code> <code class="n">bankStatements</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">ch</code><code class="p">)</code><code class="o">;</code> <code class="c1">//for testing</code>
<code class="lineno">62 </code>    <code class="n">transactions</code> <code class="o">:=</code> <code class="n">TList</code><code class="o">&lt;</code><code class="n">TTransaction</code><code class="o">&gt;.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">63 </code>    <code class="k">try</code>
<code class="lineno">64 </code>      <code class="n">ProcessTransactions</code><code class="p">(</code><code class="n">bankStatements</code><code class="o">,</code> <code class="n">transactions</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">65 </code>      <code class="k">for</code> <code class="n">transaction</code> <code class="k">in</code> <code class="n">transactions</code> <code class="k">do</code>
<code class="lineno">66 </code>        <code class="n">ListBox1</code><code class="o">.</code><code class="n">Items</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">transaction</code><code class="o">.</code><code class="n">Transaction</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">67 </code>    <code class="k">finally</code> <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">transactions</code><code class="p">)</code><code class="o">;</code> <code class="k">end</code><code class="o">;</code>
<code class="lineno">68 </code>  <code class="k">finally</code> <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">bankStatements</code><code class="p">)</code><code class="o">;</code> <code class="k">end</code><code class="o">;</code>
<code class="lineno">69 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">70 </code>
<code class="lineno">71 </code><code class="cm">{ TTransaction }</code>
<code class="lineno">72 </code>
<code class="lineno">73 </code><code class="k">constructor</code> <code class="nc">TTransaction</code><code class="o">.</code><code class="nf">Create</code><code class="p">(</code><code class="k">const</code> <code class="n">transact</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">74 </code><code class="k">begin</code>
<code class="lineno">75 </code>  <code class="n">Transaction</code> <code class="o">:=</code> <code class="n">transact</code><code class="o">;</code>
<code class="lineno">76 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">77 </code>
<code class="lineno">78 </code><code class="k">end</code><code class="o">.</code>
</pre></div>

</figure>

<p>If you don’t need the output order to be preserved, you can also run the parallel for loop enumerating directly over the <code>input</code> container as in the following example:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">ProcessTransactions</code><code class="p">(</code><code class="n">input</code><code class="o">:</code> <code class="n">TStringList</code><code class="o">;</code> 
<code class="lineno"> 2 </code>  <code class="n">output</code><code class="o">:</code> <code class="n">TList</code><code class="o">&lt;</code><code class="n">TTransaction</code><code class="o">&gt;</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="k">var</code>
<code class="lineno"> 4 </code>  <code class="n">outQueue</code>   <code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="n">transaction</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno"> 6 </code><code class="k">begin</code>
<code class="lineno"> 7 </code>  <code class="n">outQueue</code> <code class="o">:=</code> <code class="n">TOmniBlockingCollection</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="o">&lt;</code><code class="k">string</code><code class="o">&gt;</code><code class="p">(</code><code class="n">input</code><code class="p">)</code><code class="o">.</code><code class="n">NoWait</code><code class="o">.</code><code class="n">Into</code><code class="p">(</code><code class="n">outQueue</code><code class="p">)</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno"> 9 </code>    <code class="k">procedure</code><code class="p">(</code><code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code> <code class="k">var</code> <code class="bp">result</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno">10 </code>    <code class="k">begin</code>
<code class="lineno">11 </code>      <code class="bp">result</code> <code class="o">:=</code> <code class="n">TTransaction</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="n">value</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">end</code>
<code class="lineno">13 </code>  <code class="p">)</code><code class="o">;</code>
<code class="lineno">14 </code>  <code class="k">for</code> <code class="n">transaction</code> <code class="k">in</code> <code class="n">outQueue</code> <code class="k">do</code>
<code class="lineno">15 </code>    <code class="n">output</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">transaction</code><code class="o">.</code><code class="n">AsObject</code> <code class="k">as</code> <code class="n">TTransaction</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">16 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>


<div class="page-break"></div>
<h3 id="howto-parallelForTaskInit">
<span class="section-number">7.4 </span>Using taskIndex and task initializer in parallel for</h3>

<aside>
  <p><em>I want to process some data in an array and generate aggregation result. For performance reasons I would like intermediate results for each worker to be stored in a separate part of memory and I want to merge those partial results at the end.</em></p>

  <p><em>Can this be achieved by using <code>Parallel.For</code>?</em></p>

</aside>

<p>This can be done by using the <a href="chap06.html#highlevel-for"><em>Parallel for</em></a> <code>taskIndex</code> parameter. The example below also demonstrates the use of a <em>task initializer</em> which is strictly speaking not necessary in this case.</p>

<blockquote>
  <p><em>A solution to this problem is included with the OmniThreadLibrary distribution in the <code>examples/stringlist parser</code> folder.</em></p>
</blockquote>

<p>The code below counts how many numbers in a big array of randomly generated data end in <em>0, 1, … 9</em> and reports this result at the end. Each worker generates a partial result for a part of input array and results are merged at the end. </p>

<blockquote>
  <p><em>This example is included with the OmniThreadLibrary distribution in <a href="chap12.html#demos">demo</a> <code>57_For</code>.</em></p>
</blockquote>

<p>Let’s assume we have a big array of test data (<code>testData: array of integer</code>). We can easily generate this data with a call to <code>Parallel.For</code>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">Parallel</code><code class="o">.</code><code class="k">For</code><code class="p">(</code><code class="nb">Low</code><code class="p">(</code><code class="n">testData</code><code class="p">)</code><code class="o">,</code> <code class="nb">High</code><code class="p">(</code><code class="n">testData</code><code class="p">))</code><code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">2 </code>  <code class="k">procedure</code> <code class="p">(</code><code class="n">idx</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code>
<code class="lineno">3 </code>  <code class="k">begin</code>
<code class="lineno">4 </code>    <code class="n">testData</code><code class="p">[</code><code class="n">idx</code><code class="p">]</code> <code class="o">:=</code> <code class="nb">Random</code><code class="p">(</code><code class="n">MaxInt</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<aside class="tip blurb">
    <p>This data is not very random (but is still random enough for the purpose of this demo). The <a href="chap10.html#howto-parallelDataProduction">Parallel data production</a> example shows a better way to generate random numbers in multiple worker threads.</p>

</aside>

<p>As we have to prepare data storage for each worker thread, we have to know how many worker threads will be running. Therefore, we have to set the number of workers by calling <code>NumTasks</code>. A good default for a CPU intensive operation we’ll be executing is to create one worker task for each available core.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">type</code>
<code class="lineno">2 </code>  <code class="n">TBucket</code> <code class="o">=</code> <code class="k">array</code> <code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">9</code><code class="p">]</code> <code class="k">of</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">3 </code>
<code class="lineno">4 </code><code class="k">var</code>
<code class="lineno">5 </code>  <code class="n">buckets</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">TBucket</code><code class="o">;</code>
<code class="lineno">6 </code>
<code class="lineno">7 </code>  <code class="n">numTasks</code> <code class="o">:=</code> <code class="n">Environment</code><code class="o">.</code><code class="n">Process</code><code class="o">.</code><code class="n">Affinity</code><code class="o">.</code><code class="n">Count</code><code class="o">;</code>
<code class="lineno">8 </code>  <code class="nb">SetLength</code><code class="p">(</code><code class="n">buckets</code><code class="o">,</code> <code class="n">numTasks</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>Each <code>buckets</code> element will store data for one worker thread.</p>

<p>The <em>for</em> loop is next started with <code>numTasks</code> tasks. For each task an <em>initializer</em> (a parameter provided to the <code>.Initialize</code> call) is called with the appropriate <code>taskIndex</code> (from <em>0</em> to <code>numTasks - 1</code>). Initializer just sets the bucket that is associated with the task to zero. [This could easily be done in a main thread for all tasks at once, but I wanted to show how initializer can be used.]</p>

<p>Next, the <code>.Execute</code> is called and provided with a delegate which accepts two parameters – the task index <code>taskIndex</code> and the current value of the for loop  <code>idx</code>. The code determines the last digit of the <code>testData[idx]</code> and increments the appropriate slot in the bucket that belongs to the current task. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="n">Parallel</code><code class="o">.</code><code class="k">For</code><code class="p">(</code><code class="nb">Low</code><code class="p">(</code><code class="n">testData</code><code class="p">)</code><code class="o">,</code> <code class="nb">High</code><code class="p">(</code><code class="n">testData</code><code class="p">))</code>
<code class="lineno"> 2 </code>  <code class="o">.</code><code class="n">NumTasks</code><code class="p">(</code><code class="n">numTasks</code><code class="p">)</code>
<code class="lineno"> 3 </code>  <code class="o">.</code><code class="n">Initialize</code><code class="p">(</code>
<code class="lineno"> 4 </code>    <code class="k">procedure</code> <code class="p">(</code><code class="n">taskIndex</code><code class="o">,</code> <code class="n">fromIndex</code><code class="o">,</code> <code class="n">toIndex</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code>
<code class="lineno"> 5 </code>    <code class="k">begin</code>
<code class="lineno"> 6 </code>      <code class="nb">FillChar</code><code class="p">(</code><code class="n">buckets</code><code class="p">[</code><code class="n">taskIndex</code><code class="p">]</code><code class="o">,</code> <code class="nb">SizeOf</code><code class="p">(</code><code class="n">TBucket</code><code class="p">)</code><code class="o">,</code> <code class="mi">0</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">end</code><code class="p">)</code>
<code class="lineno"> 8 </code>  <code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno"> 9 </code>    <code class="k">procedure</code> <code class="p">(</code><code class="n">taskIndex</code><code class="o">,</code> <code class="n">idx</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code>
<code class="lineno">10 </code>    <code class="k">var</code>
<code class="lineno">11 </code>      <code class="n">lastDigit</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">begin</code>
<code class="lineno">13 </code>      <code class="n">lastDigit</code> <code class="o">:=</code> <code class="n">testData</code><code class="p">[</code><code class="n">idx</code><code class="p">]</code> <code class="k">mod</code> <code class="mi">10</code><code class="o">;</code>
<code class="lineno">14 </code>      <code class="n">buckets</code><code class="p">[</code><code class="n">taskIndex</code><code class="p">][</code><code class="n">lastDigit</code><code class="p">]</code> <code class="o">:=</code> <code class="n">buckets</code><code class="p">[</code><code class="n">taskIndex</code><code class="p">][</code><code class="n">lastDigit</code><code class="p">]</code> <code class="o">+</code> <code class="mi">1</code><code class="o">;</code>
<code class="lineno">15 </code>    <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>At the end, partial data is aggregated in the main thread. Result is stored in <code>buckets[0]</code>.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">for</code> <code class="n">j</code> <code class="o">:=</code> <code class="mi">0</code> <code class="k">to</code> <code class="mi">9</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">2 </code>  <code class="k">for</code> <code class="n">i</code> <code class="o">:=</code> <code class="mi">1</code> <code class="k">to</code> <code class="n">numTasks</code> <code class="o">-</code> <code class="mi">1</code> <code class="k">do</code>
<code class="lineno">3 </code>    <code class="n">buckets</code><code class="p">[</code><code class="mi">0</code><code class="p">][</code><code class="n">j</code><code class="p">]</code> <code class="o">:=</code> <code class="n">buckets</code><code class="p">[</code><code class="mi">0</code><code class="p">][</code><code class="n">j</code><code class="p">]</code> <code class="o">+</code> <code class="n">buckets</code><code class="p">[</code><code class="n">i</code><code class="p">][</code><code class="n">j</code><code class="p">]</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>


<div class="page-break"></div>
<h3 id="howto-listPartitioning">
<span class="section-number">7.5 </span>Background worker and list partitioning</h3>

<aside>
  <p><em>This is a simplification of my real-world task:</em></p>

  <ul>
    <li><em>Input is a string.</em></li>
    <li><em>Output is a <code>TStringList</code> containing characters (on per TStringList item) of the input string.</em></li>
  </ul>

  <p><em>A background thread (</em>master<em>) grabs the input string and splits it into several pieces. For each piece it creates a new thread (</em>child<em>). Child thread receives its piece, splits it into characters and returns the result to the</em> master <em>thread.</em></p>

  <p><em>Main thread is sending workloads (strings) to the</em> master <em>thread. At any time the</em> master <em>thread could be signalled to terminate all child threads and itself.</em></p>

  <p><em>When everything is done, the application’s main thread processes the string list. Preferably the order of the characters should be the same as their original order.</em></p>

  <p><em>Example:</em></p>

  <ul>
    <li><em>Input is string <code>'delphi'</code>.</em></li>
    <li>Master <em>thread splits it into two parts - <code>'del'</code> and <code>'phi'</code>.</em>
</li>
    <li>Master <em>thread starts two</em> child <em>threads. First receives input <code>'del'</code> and second input <code>'phi'</code>.</em>
</li>
    <li>
<em>First</em> child <em>thread splits <code>'del'</code> into three strings - <code>'d'</code>, <code>'e'</code>, <code>'l'</code> - and returns them to the</em> master <em>thread.</em>
</li>
    <li>
<em>Second</em> child <em>thread splits <code>'phi'</code> into three strings - <code>'p'</code>, <code>'h'</code>, <code>'i'</code> - and returns them to the</em> master <em>thread.</em>
</li>
    <li>Master <em>thread returns a <code>TStringList</code> containing strings <code>'d'</code>, <code>'e'</code>, <code>'l'</code>, <code>'p'</code>, <code>'h'</code> and <code>'i'</code> to the main thread.</em>
</li>
  </ul>

</aside>

<blockquote>
  <p><em>You should keep in mind that this is really just a simplified example because there is no sense in splitting short strings into characters in multiple threads. A solution to this problem is included with the OmniThreadLibrary distribution in the <code>examples/stringlist parser</code> folder.</em> </p>
</blockquote>

<p>The solution below implements the <em>master</em> task (although the question mentioned <em>threads</em> I will describe the answer in the context of <em>tasks</em>) as a <a href="chap06.html#highlevel-backgroundworker"><em>Background worker</em></a> abstraction because it solves two problems automatically:</p>

<ul>
  <li>Background worker accepts multiple work requests and pairs results with requests. The original question didn’t specify whether the <em>master</em> should accept more than one request at the same time but I decided to stay on the safe side and allow this.</li>
  <li>Background worker supports work request cancellation.</li>
</ul>

<p>The <em>child</em> tasks are implemented as a <a href="chap06.html#highlevel-paralleltask"><em>Paralel task</em></a> abstraction. It allows us to run a code in multiple parallel tasks at the same time.</p>

<p>To set up a background worker, call <code>Parallel.BackgroundWorker</code> and provide it with a code that will process work items (<code>BreakStringHL</code>) and a code that will process results of the work item processor (<code>ShowResultHL</code>). It is important to keep in mind that the former (<code>BreakStringHL</code>) executes in the background thread while the latter (<code>ShowResultHL</code>) executes in the main thread. [Actually, it executes in the thread which calls <code>Parallel.BackgroundWorker</code> but in most cases that will be the main thread.]</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code>  <code class="n">FBackgroundWorker</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">BackgroundWorker</code>
<code class="lineno">2 </code>    <code class="o">.</code><code class="n">Execute</code><code class="p">(</code><code class="n">BreakStringHL</code><code class="p">)</code>
<code class="lineno">3 </code>    <code class="o">.</code><code class="n">OnRequestDone</code><code class="p">(</code><code class="n">ShowResultHL</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>Tearing it down is also simple.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code>  <code class="n">FBackgroundWorker</code><code class="o">.</code><code class="n">CancelAll</code><code class="o">;</code>
<code class="lineno">2 </code>  <code class="n">FBackgroundWorker</code><code class="o">.</code><code class="n">Terminate</code><code class="p">(</code><code class="n">INFINITE</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">3 </code>  <code class="n">FBackgroundWorker</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>CancellAll</code> is called to cancel any pending work requests, <code>Terminate</code> stops the worker (and waits for it to complete execution) and assignment clears the interface variable and destroys last pieces of the worker.</p>

<p>The <code>BreakStringHL</code> method takes a work item (which will contain the input string), sets up a <em>parallel task</em> abstraction, splits the input string into multiple strings and sends each one to the parallel task.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmStringListParser</code><code class="o">.</code><code class="nf">BreakStringHL</code><code class="p">(</code>
<code class="lineno"> 2 </code>  <code class="k">const</code> <code class="n">workItem</code><code class="o">:</code> <code class="n">IOmniWorkItem</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="k">var</code>
<code class="lineno"> 4 </code>  <code class="n">charsPerTask</code> <code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="n">input</code>        <code class="o">:</code> <code class="k">string</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="n">iTask</code>        <code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="n">numTasks</code>     <code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="n">output</code>       <code class="o">:</code> <code class="n">TStringList</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="n">partialQueue</code> <code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="o">;</code>
<code class="lineno">10 </code>  <code class="n">s</code>            <code class="o">:</code> <code class="k">string</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="n">stringBreaker</code><code class="o">:</code> <code class="n">IOmniParallelTask</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="n">taskResults</code>  <code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">TStringList</code><code class="o">;</code>
<code class="lineno">13 </code><code class="k">begin</code>
<code class="lineno">14 </code>  <code class="n">partialQueue</code> <code class="o">:=</code> <code class="n">TOmniBlockingCollection</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">15 </code>  <code class="n">numTasks</code> <code class="o">:=</code> <code class="n">Environment</code><code class="o">.</code><code class="n">Process</code><code class="o">.</code><code class="n">Affinity</code><code class="o">.</code><code class="n">Count</code> <code class="o">-</code> <code class="mi">1</code><code class="o">;</code>
<code class="lineno">16 </code>
<code class="lineno">17 </code>  <code class="c1">// create multiple TStringLists, one per child task</code>
<code class="lineno">18 </code>  <code class="nb">SetLength</code><code class="p">(</code><code class="n">taskResults</code><code class="o">,</code> <code class="n">numTasks</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">19 </code>  <code class="k">for</code> <code class="n">iTask</code> <code class="o">:=</code> <code class="nb">Low</code><code class="p">(</code><code class="n">taskResults</code><code class="p">)</code> <code class="k">to</code> <code class="nb">High</code><code class="p">(</code><code class="n">taskResults</code><code class="p">)</code> <code class="k">do</code>
<code class="lineno">20 </code>    <code class="n">taskResults</code><code class="p">[</code><code class="n">iTask</code><code class="p">]</code> <code class="o">:=</code> <code class="n">TStringList</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">21 </code>
<code class="lineno">22 </code>  <code class="c1">// start child tasks</code>
<code class="lineno">23 </code>  <code class="n">stringBreaker</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">ParallelTask</code><code class="o">.</code><code class="n">NumTasks</code><code class="p">(</code><code class="n">numTasks</code><code class="p">)</code><code class="o">.</code><code class="n">NoWait</code>
<code class="lineno">24 </code>    <code class="o">.</code><code class="n">TaskConfig</code><code class="p">(</code>
<code class="lineno">25 </code>      <code class="n">Parallel</code><code class="o">.</code><code class="n">TaskConfig</code><code class="o">.</code><code class="n">CancelWith</code><code class="p">(</code><code class="n">workItem</code><code class="o">.</code><code class="n">CancellationToken</code><code class="p">))</code>
<code class="lineno">26 </code>    <code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">27 </code>      <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code>
<code class="lineno">28 </code>      <code class="k">var</code>
<code class="lineno">29 </code>        <code class="n">workItem</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno">30 </code>      <code class="k">begin</code>
<code class="lineno">31 </code>        <code class="n">workItem</code> <code class="o">:=</code> <code class="n">partialQueue</code><code class="o">.</code><code class="n">Next</code><code class="o">;</code>
<code class="lineno">32 </code>        <code class="n">SplitPartialList</code><code class="p">(</code><code class="n">workItem</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="o">.</code><code class="n">AsString</code><code class="o">,</code>
<code class="lineno">33 </code>          <code class="n">taskResults</code><code class="p">[</code><code class="n">workItem</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">AsInteger</code><code class="p">]</code><code class="o">,</code> <code class="n">task</code><code class="o">.</code><code class="n">CancellationToken</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">34 </code>      <code class="k">end</code>
<code class="lineno">35 </code>    <code class="p">)</code><code class="o">;</code>
<code class="lineno">36 </code>
<code class="lineno">37 </code>  <code class="c1">// provide input to child tasks</code>
<code class="lineno">38 </code>  <code class="n">input</code> <code class="o">:=</code> <code class="n">workItem</code><code class="o">.</code><code class="n">Data</code><code class="o">;</code>
<code class="lineno">39 </code>  <code class="k">for</code> <code class="n">iTask</code> <code class="o">:=</code> <code class="mi">1</code> <code class="k">to</code> <code class="n">numTasks</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">40 </code>    <code class="c1">// divide the remaining part in as-equal-as-possible segments</code>
<code class="lineno">41 </code>    <code class="n">charsPerTask</code> <code class="o">:=</code> <code class="nb">Round</code><code class="p">(</code><code class="nb">Length</code><code class="p">(</code><code class="n">input</code><code class="p">)</code> <code class="o">/</code> <code class="p">(</code><code class="n">numTasks</code> <code class="o">-</code> <code class="n">iTask</code> <code class="o">+</code> <code class="mi">1</code><code class="p">))</code><code class="o">;</code>
<code class="lineno">42 </code>    <code class="n">partialQueue</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">TOmniValue</code><code class="o">.</code><code class="n">Create</code><code class="p">([</code><code class="n">iTask</code><code class="o">-</code><code class="mi">1</code><code class="o">,</code> 
<code class="lineno">43 </code>      <code class="nb">Copy</code><code class="p">(</code><code class="n">input</code><code class="o">,</code> <code class="mi">1</code><code class="o">,</code> <code class="n">charsPerTask</code><code class="p">)]))</code><code class="o">;</code>
<code class="lineno">44 </code>    <code class="nb">Delete</code><code class="p">(</code><code class="n">input</code><code class="o">,</code> <code class="mi">1</code><code class="o">,</code> <code class="n">charsPerTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">45 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">46 </code>
<code class="lineno">47 </code>  <code class="c1">// process output</code>
<code class="lineno">48 </code>  <code class="n">stringBreaker</code><code class="o">.</code><code class="n">WaitFor</code><code class="p">(</code><code class="n">INFINITE</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">49 </code>  <code class="k">if</code> <code class="k">not</code> <code class="n">workItem</code><code class="o">.</code><code class="n">CancellationToken</code><code class="o">.</code><code class="n">IsSignalled</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno">50 </code>    <code class="n">output</code> <code class="o">:=</code> <code class="n">TStringList</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">51 </code>    <code class="k">for</code> <code class="n">iTask</code> <code class="o">:=</code> <code class="nb">Low</code><code class="p">(</code><code class="n">taskResults</code><code class="p">)</code> <code class="k">to</code> <code class="nb">High</code><code class="p">(</code><code class="n">taskResults</code><code class="p">)</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">52 </code>      <code class="k">for</code> <code class="n">s</code> <code class="k">in</code> <code class="n">taskResults</code><code class="p">[</code><code class="n">iTask</code><code class="p">]</code> <code class="k">do</code>
<code class="lineno">53 </code>        <code class="n">output</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">s</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">54 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">55 </code>    <code class="n">workItem</code><code class="o">.</code><code class="bp">Result</code> <code class="o">:=</code> <code class="n">output</code><code class="o">;</code>
<code class="lineno">56 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">57 </code>  <code class="k">for</code> <code class="n">iTask</code> <code class="o">:=</code> <code class="nb">Low</code><code class="p">(</code><code class="n">taskResults</code><code class="p">)</code> <code class="k">to</code> <code class="nb">High</code><code class="p">(</code><code class="n">taskResults</code><code class="p">)</code> <code class="k">do</code>
<code class="lineno">58 </code>  <code class="n">taskResults</code><code class="p">[</code><code class="n">iTask</code><code class="p">]</code><code class="o">.</code><code class="n">Free</code><code class="o">;</code>
<code class="lineno">59 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>BreakStringHL</code> is called for each input string that arrives over the communication channel. It firstly decides how many threads to use (number of cores minus one; the assumption here is that one core is used to run the main thread). One string list is then created for each <em>child</em> subtask. It will contain the results generated from that task.</p>

<p>A <em>Parallel task</em> abstraction is then started, running (number of cores minus one) tasks. Each will accept a work unit on an internally created queue, process it and shut down.</p>

<p>Next, the code sends work units to <em>child</em> tasks. Each work unit contains the index of the task (so the code knows where to store the data) and the string to be processed. All <em>child</em> tasks also get the same <a href="chap07.html#lowlevel-simpletasks-cancellationtoken"><em>cancellation token</em></a> so that they can be cancelled in one go. <em>Child</em> tasks are executed in a thread pool to minimize thread creation overhead.</p>

<p>When all <em>child</em> tasks are completed, partial results are collected into one <code>TStringList</code> object which is returned as a result of the <em>background worker</em> work item.</p>

<p>Actual string breaking is implemented as a standalone procedure. It checks each input character and signals the cancelation token if the character is an exclamation mark. (This is implemented just as a cancelation testing mechanism.) It exits if the cancelation token is signalled. At the end, <code>Sleep(100)</code> simulates heavy processing and allows the user to click the <em>Cancel</em> button in the GUI before the operation is completed.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">SplitPartialList</code><code class="p">(</code><code class="k">const</code> <code class="n">input</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code> <code class="n">output</code><code class="o">:</code> <code class="n">TStringList</code><code class="o">;</code>
<code class="lineno"> 2 </code>  <code class="k">const</code> <code class="n">cancel</code><code class="o">:</code> <code class="n">IOmniCancellationToken</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="k">var</code>
<code class="lineno"> 4 </code>  <code class="n">ch</code><code class="o">:</code> <code class="kt">char</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="k">for</code> <code class="n">ch</code> <code class="k">in</code> <code class="n">input</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno"> 7 </code>    <code class="k">if</code> <code class="n">ch</code> <code class="o">=</code> <code class="s">'!'</code> <code class="k">then</code> <code class="c1">// for testing</code>
<code class="lineno"> 8 </code>      <code class="n">cancel</code><code class="o">.</code><code class="n">Signal</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">if</code> <code class="n">cancel</code><code class="o">.</code><code class="n">IsSignalled</code> <code class="k">then</code>
<code class="lineno">10 </code>      <code class="k">break</code><code class="o">;</code> <code class="c1">//for ch</code>
<code class="lineno">11 </code>    <code class="n">output</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">ch</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="nb">Sleep</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code><code class="o">;</code> <code class="c1">// simulate workload</code>
<code class="lineno">13 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">14 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The example program uses simple <code>OnClick</code> handler to send string to processing.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmStringListParser</code><code class="o">.</code><code class="nf">btnProcessHLClick</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="n">FBackgroundWorker</code><code class="o">.</code><code class="n">Schedule</code><code class="p">(</code>
<code class="lineno">4 </code>    <code class="n">FBackgroundWorker</code><code class="o">.</code><code class="n">CreateWorkItem</code><code class="p">(</code><code class="n">inpString</code><code class="o">.</code><code class="n">Text</code><code class="p">))</code><code class="o">;</code>
<code class="lineno">5 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>Results are returned to the <code>ShowResultHL</code> method (as it was passed as a parameter to the <code>OnRequestDone</code> call when creating the background worker).</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmStringListParser</code><code class="o">.</code><code class="nf">ShowResultHL</code><code class="p">(</code>
<code class="lineno">2 </code>  <code class="k">const</code> <code class="n">Sender</code><code class="o">:</code> <code class="n">IOmniBackgroundWorker</code><code class="o">;</code>
<code class="lineno">3 </code>  <code class="k">const</code> <code class="n">workItem</code><code class="o">:</code> <code class="n">IOmniWorkItem</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">begin</code>
<code class="lineno">5 </code>  <code class="k">if</code> <code class="n">workItem</code><code class="o">.</code><code class="n">CancellationToken</code><code class="o">.</code><code class="n">IsSignalled</code> <code class="k">then</code>
<code class="lineno">6 </code>    <code class="n">lbLog</code><code class="o">.</code><code class="n">Items</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="s">'Canceled'</code><code class="p">)</code>
<code class="lineno">7 </code>  <code class="k">else</code>
<code class="lineno">8 </code>    <code class="n">ShowResult</code><code class="p">(</code><code class="n">workItem</code><code class="o">.</code><code class="bp">Result</code><code class="o">.</code><code class="n">AsObject</code> <code class="k">as</code> <code class="n">TStringList</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">9 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>It receives an <code>IOmniBackgroundWorker</code> interface (useful if you are sharing one method between several background workers) and the work item that was processed (or cancelled). The code simply checks if the work item was cancelled and displays the result (by using the <code>ShowResult</code> from the original code) otherwise.</p>

<p>The demonstration program also implements a <em>Cancel</em> button which cancels all pending operations. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmStringListParser</code><code class="o">.</code><code class="nf">btnCancelHLClick</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="n">FBackgroundWorker</code><code class="o">.</code><code class="n">CancelAll</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>All not-yet-executing operations will be cancelled automatically. For the string that is currently being processed, a cancellation token will be signalled. <code>SplitPartialList</code> will notice this token being signalled and will stop processing.</p>


<div class="page-break"></div>
<h3 id="howto-parallelDataProduction">
<span class="section-number">7.6 </span>Parallel data production</h3>

<blockquote>
  <p><em>This question comes from <a href="http://stackoverflow.com/q/7292741/4997">StackOverflow</a>. It is reproduced here in a slightly shortened form.</em></p>
</blockquote>

<aside>
  <p><em>I am looking into generating a file (750 MB) full of random bytes. The problem is that it takes ages until the process completes. Any ideas for a faster approach?</em></p>

</aside>

<p>This solution uses <a href="chap06.html#highlevel-paralleltask"><em>Parallel Task</em></a> abstraction.</p>

<p>The algorithm works as follows:</p>

<ul>
  <li>do in parallel:
    <ul>
      <li>repeat
        <ul>
          <li>find out how many bytes to process in this iteration
            <ul>
              <li>if there’s no more work to do, exit the loop</li>
            </ul>
          </li>
          <li>prepare the buffer</li>
          <li>send it to the output queue</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>The tricky part is implementing the third item – ‘find out how many bytes to process in this iteration’ – in a lock-free fashion. What we need is a thread-safe equivalent of the following (completely thread-unsafe) fragment.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">if</code> <code class="nb">fileSize</code> <code class="o">&gt;</code> <code class="n">CBlockSize</code> <code class="k">then</code>
<code class="lineno">2 </code>  <code class="n">numBytes</code> <code class="o">:=</code> <code class="n">CBlockSize</code>
<code class="lineno">3 </code><code class="k">else</code>
<code class="lineno">4 </code>  <code class="n">numBytes</code> <code class="o">:=</code> <code class="nb">fileSize</code><code class="o">;</code>
<code class="lineno">5 </code><code class="nb">fileSize</code> <code class="o">:=</code> <code class="nb">fileSize</code> <code class="o">-</code> <code class="n">numBytes</code><code class="o">;</code>
</pre></div>

</figure>

<p>OmniThreadLibrary implements a thread-safe version of this pattern in <a href="chap09.html#misc-tomnicounter"><code>TOmniCounter.Take</code></a>. If you have <code>TOmniCounter</code> initialized with some value (say, <code>fileSize</code>) and you call <code>TOmniCounter.Take(numBytes)</code>, the code will behave exactly the same as the fragment above except that it will work correctly if <code>Take</code> is called from multiple threads at the same time. In addition to that, the new value of the <code>fileSize</code> will be stored in the <code>TOmniCounter</code>’s counter and returned as a function result.</p>

<p>There’s another version of <code>Take</code> which returns the result in a <code>var</code> parameter and sets its result to <code>True</code> if value returned is larger than zero.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nc">TOmniCounterImpl</code><code class="o">.</code><code class="nf">Take</code><code class="p">(</code><code class="n">count</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> 
<code class="lineno">2 </code>  <code class="k">var</code> <code class="n">taken</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">3 </code><code class="k">begin</code>
<code class="lineno">4 </code>  <code class="n">taken</code> <code class="o">:=</code> <code class="n">Take</code><code class="p">(</code><code class="n">count</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code>  <code class="bp">Result</code> <code class="o">:=</code> <code class="p">(</code><code class="n">taken</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">6 </code><code class="k">end</code><code class="o">;</code> <code class="cm">{ TOmniCounterImpl.Take }</code>
</pre></div>

</figure>

<p>This version of Take allows you to write elegant iteration code which also works when multiple tasks are accessing the same counter instance.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">counter</code> <code class="o">:=</code> <code class="n">CreateCounter</code><code class="p">(</code><code class="n">numBytes</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">while</code> <code class="n">counter</code><code class="o">.</code><code class="n">Take</code><code class="p">(</code><code class="n">blockSize</code><code class="o">,</code> <code class="n">blockBytes</code><code class="p">)</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">3 </code>  <code class="c1">// process blockBytes bytes</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The solution creates a counter which holds the number of bytes to be generated (<code>unwritten</code>) and a <a href="chap06.html#highlevel-blocking-collection">queue</a> (<code>outQueue</code>) that will hold generated data buffers until they are written to a file. Then it starts a <a href="chap06.html#highlevel-paralleltask"><code>ParallelTask</code></a> abstraction on all available cores. While the abstraction is running in the background (because <code>NoWait</code> is used), the main thread continues with the <code>CreateRandomFile</code> execution, reads the data from the <code>outQueue</code> and writes blocks to the file.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nf">CreateRandomFile</code><code class="p">(</code><code class="nb">fileSize</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code> <code class="n">output</code><code class="o">:</code> <code class="n">TStream</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">const</code>
<code class="lineno"> 3 </code>  <code class="n">CBlockSize</code> <code class="o">=</code> <code class="mi">1</code> <code class="o">*</code> <code class="mi">1024</code> <code class="o">*</code> <code class="mi">1024</code> <code class="cm">{1 MB}</code><code class="o">;</code>
<code class="lineno"> 4 </code><code class="k">var</code>
<code class="lineno"> 5 </code>  <code class="n">buffer</code>   <code class="o">:</code> <code class="n">TOmniValue</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="n">memStr</code>   <code class="o">:</code> <code class="n">TMemoryStream</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="n">outQueue</code> <code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="n">unwritten</code><code class="o">:</code> <code class="n">IOmniCounter</code><code class="o">;</code>
<code class="lineno"> 9 </code><code class="k">begin</code>
<code class="lineno">10 </code>  <code class="n">outQueue</code> <code class="o">:=</code> <code class="n">TOmniBlockingCollection</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="n">unwritten</code> <code class="o">:=</code> <code class="n">CreateCounter</code><code class="p">(</code><code class="nb">fileSize</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="n">Parallel</code><code class="o">.</code><code class="n">ParallelTask</code><code class="o">.</code><code class="n">NoWait</code>
<code class="lineno">13 </code>    <code class="o">.</code><code class="n">NumTasks</code><code class="p">(</code><code class="n">Environment</code><code class="o">.</code><code class="n">Process</code><code class="o">.</code><code class="n">Affinity</code><code class="o">.</code><code class="n">Count</code><code class="p">)</code>
<code class="lineno">14 </code>    <code class="o">.</code><code class="n">OnStop</code><code class="p">(</code><code class="n">Parallel</code><code class="o">.</code><code class="n">CompleteQueue</code><code class="p">(</code><code class="n">outQueue</code><code class="p">))</code>
<code class="lineno">15 </code>    <code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">16 </code>      <code class="k">procedure</code>
<code class="lineno">17 </code>      <code class="k">var</code>
<code class="lineno">18 </code>        <code class="nf">buffer</code>      <code class="o">:</code> <code class="n">TMemoryStream</code><code class="o">;</code>
<code class="lineno">19 </code>        <code class="n">bytesToWrite</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">20 </code>        <code class="n">randomGen</code>   <code class="o">:</code> <code class="n">TGpRandom</code><code class="o">;</code>
<code class="lineno">21 </code>      <code class="k">begin</code>
<code class="lineno">22 </code>        <code class="n">randomGen</code> <code class="o">:=</code> <code class="n">TGpRandom</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">23 </code>        <code class="k">try</code>
<code class="lineno">24 </code>          <code class="k">while</code> <code class="n">unwritten</code><code class="o">.</code><code class="n">Take</code><code class="p">(</code><code class="n">CBlockSize</code><code class="o">,</code> <code class="n">bytesToWrite</code><code class="p">)</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">25 </code>            <code class="n">buffer</code> <code class="o">:=</code> <code class="n">TMemoryStream</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">26 </code>            <code class="n">buffer</code><code class="o">.</code><code class="n">Size</code> <code class="o">:=</code> <code class="n">bytesToWrite</code><code class="o">;</code>
<code class="lineno">27 </code>            <code class="n">FillBuffer</code><code class="p">(</code><code class="n">buffer</code><code class="o">.</code><code class="n">Memory</code><code class="o">,</code> <code class="n">bytesToWrite</code><code class="o">,</code> <code class="n">randomGen</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">28 </code>            <code class="n">outQueue</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">buffer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">29 </code>          <code class="k">end</code><code class="o">;</code>
<code class="lineno">30 </code>        <code class="k">finally</code> <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">randomGen</code><code class="p">)</code><code class="o">;</code> <code class="k">end</code><code class="o">;</code>
<code class="lineno">31 </code>      <code class="k">end</code>
<code class="lineno">32 </code>    <code class="p">)</code><code class="o">;</code>
<code class="lineno">33 </code>  <code class="k">for</code> <code class="n">buffer</code> <code class="k">in</code> <code class="n">outQueue</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">34 </code>    <code class="n">memStr</code> <code class="o">:=</code> <code class="n">buffer</code><code class="o">.</code><code class="n">AsObject</code> <code class="k">as</code> <code class="n">TMemoryStream</code><code class="o">;</code>
<code class="lineno">35 </code>    <code class="n">output</code><code class="o">.</code><code class="n">CopyFrom</code><code class="p">(</code><code class="n">memStr</code><code class="o">,</code> <code class="mi">0</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">36 </code>    <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">memStr</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">37 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">38 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The parallel part firstly creates a random generator in each task. Because the random generator code is not thread-safe, it cannot be shared between the tasks. Next it uses the above-mentioned <code>Take</code> pattern to grab a bunch of work, generates that much random data (inside the <code>FillBuffer</code> which is not shown here) and adds the buffer to the <code>outQueue</code>.</p>

<p>You may be asking yourself how will this code stop? When the <code>unwritten</code> counter drops to zero, <code>Take</code> will fail in every task and anonymous method running inside the task will exit. When this happens in all tasks, <code>OnStop</code> handler will be called automatically. </p>

<p>The code above passes <code>Parallel.CompleteQueue</code> to the <code>OnStop</code>. This is a special helper which creates a delegate that calls <code>CompleteAdding</code> on its parameter. Therefore, <code>OnStop</code> handler will call <code>outQueue.CompleteAdding</code>, which will cause the <code>for</code> loop in <code>CreateRandomFile</code> to exit after all data is processed.</p>


<div class="page-break"></div>
<h3 id="howto-connectionPool">
<span class="section-number">7.7 </span>Building a connection pool</h3>

<aside>
  <p><em>Is it possible to use OTL to create Connection Pool systems? It seems like OTL solves a lot of the concurrency and communications issues. Is this feasible?</em></p>

</aside>

<p>The <a href="chap07.html#lowlevel-threadpool">thread pool</a> enables connection pooling by providing property <code>ThreadData: IOtlThreadData</code> to each task. This property is bound to a thread – it is created when a thread is created and is destroyed together with the thread.</p>

<p>To facilitate this, <a href="chap05.html#introotl-tasksvsthreads">task</a> implements property <code>ThreadData</code> which contains the user data associated with the thread.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">type</code>
<code class="lineno">2 </code>  <code class="n">IOmniTask</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno">3 </code>    <code class="o">...</code>
<code class="lineno">4 </code>    <code class="k">property</code> <code class="py">ThreadData</code><code class="o">:</code> <code class="n">IInterface</code><code class="o">;</code>
<code class="lineno">5 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>This data is initialized in the thread pool when a new thread is created. It is destroyed automatically when a thread is destroyed.</p>

<p>To initialize the <code>ThreadData</code>, write a ‘factory’ method, a method that creates a thread data interface. The thread pool will call this factory method to create the thread data and will then assign the same object to all tasks running in that thread.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TOTPThreadDataFactoryFunction</code> <code class="o">=</code> <code class="k">function</code><code class="o">:</code> <code class="nf">IInterface</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">TOTPThreadDataFactoryMethod</code> <code class="o">=</code> <code class="k">function</code><code class="o">:</code> <code class="nf">IInterface</code> <code class="k">of</code> <code class="k">object</code><code class="o">;</code>
<code class="lineno"> 4 </code>
<code class="lineno"> 5 </code>  <code class="n">IOmniThreadPool</code> <code class="o">=</code> <code class="k">interface</code>
<code class="lineno"> 6 </code>    <code class="o">...</code>
<code class="lineno"> 7 </code>    <code class="k">procedure</code> <code class="nf">SetThreadDataFactory</code><code class="p">(</code>
<code class="lineno"> 8 </code>      <code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOTPThreadDataFactoryMethod</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">procedure</code> <code class="nf">SetThreadDataFactory</code><code class="p">(</code>
<code class="lineno">10 </code>      <code class="k">const</code> <code class="n">value</code><code class="o">:</code> <code class="n">TOTPThreadDataFactoryFunction</code><code class="p">)</code><code class="o">;</code> <code class="n">overload</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>You can write two kinds of a thread data factories – a ‘normal’ function that returns an <code>IInterface</code> or a method function (a function that belongs to a class) that returns an <code>IInterface</code>. </p>

<h4 id="leanpub-auto-from-theory-to-practice">
<span class="section-number">7.7.1 </span>From theory to practice</h4>

<p>Let’s return to the practical part. In the database connection pool scenario, you’d have to write a connection interface, object and factory (see <a href="chap12.html#demos">demo</a> application <code>24_ConnectionPool</code> for the full code).</p>

<p>In the <code>OnCreate</code> event the code creates a thread pool, assigns it a name and thread data factory. The latter is a function that will create and initialize new connection for each new thread. In the <code>OnClose</code> event the code terminates all waiting tasks (if any), allowing the application to shut down gracefully. <code>FConnectionPool</code> is an interface and its lifetime is managed automatically so we don’t have to do anything explicit with it.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmConnectionPoolDemo</code><code class="o">.</code><code class="nf">FormCreate</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="n">FConnectionPool</code> <code class="o">:=</code> <code class="n">CreateThreadPool</code><code class="p">(</code><code class="s">'Connection pool'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">4 </code>  <code class="n">FConnectionPool</code><code class="o">.</code><code class="n">SetThreadDataFactory</code><code class="p">(</code><code class="n">CreateThreadData</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code>  <code class="n">FConnectionPool</code><code class="o">.</code><code class="n">MaxExecuting</code> <code class="o">:=</code> <code class="mi">3</code><code class="o">;</code>
<code class="lineno">6 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<aside class="tip blurb">
    <p>Thread data factory could also be assigned to the global thread pool by calling <code>GlobalOmniThreadPool.SetThreadDataFactory</code>.</p>

</aside>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmConnectionPoolDemo</code><code class="o">.</code><code class="nf">FormClose</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="o">;</code> 
<code class="lineno">2 </code>  <code class="k">var</code> <code class="n">Action</code><code class="o">:</code> <code class="n">TCloseAction</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">3 </code><code class="k">begin</code>
<code class="lineno">4 </code>  <code class="n">FConnectionPool</code><code class="o">.</code><code class="n">CancelAll</code><code class="o">;</code>
<code class="lineno">5 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The magic <code>CreateThreadData</code> factory just creates a connection object (which would in a real program establish a database connection, for example).</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">function</code> <code class="nc">TfrmConnectionPoolDemo</code><code class="o">.</code><code class="nf">CreateThreadData</code><code class="o">:</code> <code class="n">IInterface</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="bp">Result</code> <code class="o">:=</code> <code class="n">TConnectionPoolData</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>There’s no black magic behind this connection object. It is an object that implements an interface. Any interface. This interface will be used only in your code. In this demo, <code>TConnectionPoolData</code> contains only one field – unique ID, which will help us follow the program execution.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">IConnectionPoolData</code> <code class="o">=</code> <code class="k">interface</code> 
<code class="lineno"> 3 </code>    <code class="k">function</code> <code class="nf">ConnectionID</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code>  <code class="n">TConnectionPoolData</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TInterfacedObject</code><code class="o">,</code> <code class="n">IConnectionPoolData</code><code class="p">)</code>
<code class="lineno"> 7 </code>  <code class="n">strict</code> <code class="kp">private</code>
<code class="lineno"> 8 </code>    <code class="n">cpID</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="kp">public</code>
<code class="lineno">10 </code>    <code class="k">constructor</code> <code class="nf">Create</code><code class="o">;</code>
<code class="lineno">11 </code>    <code class="k">destructor</code>  <code class="nf">Destroy</code><code class="o">;</code> <code class="kp">override</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">function</code> <code class="nf">ConnectionID</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>As this is not a code from a real world application, I didn’t bother connecting it to any specific database. <code>TConnectionPoolData</code> constructor will just notify the main form it has begun its job, generate a new ID and sleep for five seconds (to emulate establishing a slow connection). The destructor is even simpler, it just sends a notification to the main form. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">constructor</code> <code class="nc">TConnectionPoolData</code><code class="o">.</code><code class="nf">Create</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="n">PostToForm</code><code class="p">(</code><code class="n">WM_USER</code><code class="o">,</code> <code class="n">MSG_CREATING_CONNECTION</code><code class="o">,</code> 
<code class="lineno"> 4 </code>    <code class="kt">integer</code><code class="p">(</code><code class="n">GetCurrentThreadID</code><code class="p">))</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="n">cpID</code> <code class="o">:=</code> <code class="n">GConnPoolID</code><code class="o">.</code><code class="n">Increment</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="nb">Sleep</code><code class="p">(</code><code class="mi">5000</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="n">PostToForm</code><code class="p">(</code><code class="n">WM_USER</code><code class="o">,</code> <code class="n">MSG_CREATED_CONNECTION</code><code class="o">,</code> <code class="n">cpID</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 8 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno"> 9 </code>
<code class="lineno">10 </code><code class="k">destructor</code> <code class="nc">TConnectionPoolData</code><code class="o">.</code><code class="nf">Destroy</code><code class="o">;</code>
<code class="lineno">11 </code><code class="k">begin</code>
<code class="lineno">12 </code>  <code class="n">PostToForm</code><code class="p">(</code><code class="n">WM_USER</code><code class="o">,</code> <code class="n">MSG_DESTROY_CONNECTION</code><code class="o">,</code> <code class="n">cpID</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>Creating and running a task is simple with the OmniThreadLibrary.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmConnectionPoolDemo</code><code class="o">.</code><code class="nf">btnScheduleClick</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="n">Log</code><code class="p">(</code><code class="s">'Creating task'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">4 </code>  <code class="n">CreateTask</code><code class="p">(</code><code class="n">TaskProc</code><code class="p">)</code><code class="o">.</code><code class="n">MonitorWith</code><code class="p">(</code><code class="n">OTLMonitor</code><code class="p">)</code><code class="o">.</code><code class="n">Schedule</code><code class="p">(</code><code class="n">FConnectionPool</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>We are monitoring the task with the <code>TOmniEventMonitor</code> component because a) we want to know when the task will terminate and b) otherwise we would have to store into a global field a reference to the <code>IOmniTaskControl</code> interface returned from the <code>CreateTask</code>. </p>

<p>The task worker procedure <code>TaskProc</code> is again simple. First it pulls the connection data from the task interface (<code>task.ThreadData as IConnectionPoolData</code>), retrieves the connection ID and sends task and connection ID to the main form (for logging) and then it sleeps for three seconds, simulating heavy database activity. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nf">TaskProc</code><code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTask</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="n">PostToForm</code><code class="p">(</code><code class="n">WM_USER</code> <code class="o">+</code> <code class="mi">1</code><code class="o">,</code> <code class="n">task</code><code class="o">.</code><code class="n">UniqueID</code><code class="o">,</code>
<code class="lineno">4 </code>    <code class="p">(</code><code class="n">task</code><code class="o">.</code><code class="n">ThreadData</code> <code class="k">as</code> <code class="n">IConnectionPoolData</code><code class="p">)</code><code class="o">.</code><code class="n">ConnectionID</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code>  <code class="nb">Sleep</code><code class="p">(</code><code class="mi">3000</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">6 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>Then … but wait! There’s no more! Believe it or not, that’s all. OK, there is some infrastructure code that is used only for logging but that you can look up by yourself.</p>

<p>There is also a code assigned to the second button (<em>Schedule and wait</em>) but it only shows how you can schedule a task and wait on its execution. This is useful if you’re running the task from a background thread.</p>

<h4 id="leanpub-auto-running-the-demo">
<span class="section-number">7.7.2 </span>Running the demo</h4>

<p>Let’s run the demo and click on the <em>Schedule</em> key. </p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 70%;">
    <img src="images/connectionPool1.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<p>What happened here?</p>

<ul>
  <li>Task was created.</li>
  <li>It was immediately scheduled for execution and thread pool called our thread data factory.</li>
  <li>Thread data object constructor waited for five seconds and returned.</li>
  <li>Thread pool immediately started executing the task.</li>
  <li>Task waited for three seconds and exited.</li>
</ul>

<p>OK, nothing special. Let’s click the <em>Schedule</em> button again.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 70%;">
    <img src="images/connectionPool2.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<p>Now a new task was created (with ID 4), was scheduled for execution in the same thread as the previous task and reused the connection that was created when the first task was scheduled. There is no 5 second wait, just the 3 second wait implemented in the task worker procedure.</p>

<p>If you now let the program run for 10 seconds, a message ‘Destroying connection 1’ will appear. The reason for this is that the default thread idle timeout in a thread pool is 10 seconds. In other words, if a thread does nothing for 10 seconds, it will be stopped. You are, of course, free to set this value to any number or even to 0, which would disable the idle thread termination mechanism.</p>

<p>If you now click the <em>Schedule</em> button again, a new thread will be created in the thread pool and a new connection will be created in our factory function (spending 5 seconds doing nothing). </p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 70%;">
    <img src="images/connectionPool3.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<p>Let’s try something else. I was running the demo on my laptop with a dual core CPU, which caused the thread pool to limit maximum number of concurrently executing threads to two. By default, thread pool uses as much threads as there are cores in the system, but again you can override the value. (In releases up to <sup>[3.03]</sup>, you could use at most 60 concurrently executing threads. Starting from release <sup>[3.04]</sup>, this number is only limited by the system resources.) </p>

<p>To recap – when running the demo, the thread pool was limited to two concurrent threads. When I clicked the <em>Schedule</em> button two times in a quick succession, the first task was scheduled and the first connection started being established (has entered the <code>Sleep</code> function). Then the second task was created (as the connection is being established from the worker thread, GUI is not blocked) and the second connection started being established in the second thread. Five seconds later, connections are created and tasks start running (and wait three seconds, and exit).</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 70%;">
    <img src="images/connectionPool4.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<p>Then I clicked the <em>Schedule</em> button two more times. Two tasks were scheduled, and they immediately started execution in two worker threads.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 70%;">
    <img src="images/connectionPool5.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<p>For the third demo, I restarted the app and clicked the <em>Schedule</em> button three times. Only two worker threads were created and two connections established and two tasks started execution. The third task entered the thread pool queue and waited for the first task to terminate, after which it was immediately scheduled.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 70%;">
    <img src="images/connectionPool6.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<p>So here you have it – a very simple way to build a connection pool.</p>


<div class="page-break"></div>
<h3 id="howto-quickSortParallelMax">
<span class="section-number">7.8 </span>QuickSort and parallel max</h3>

<aside>
  <p><em>I would like to sort a big array of data, but my comparison function is quite convoluted and sorting takes a long time. Can I use OmniThreadLibrary to speed up sorting?</em></p>

  <p><em>On a similar topic – sometimes I’d also like to find a maximum data element in this big array, without doing the sorting. How would I approach this problem?</em></p>

</aside>

<p>The answer to both parts of the problem is the same – use the <a href="chap06.html#highlevel-forkjoin"><em>Fork/Join</em></a> abstraction.</p>

<h4 id="leanpub-auto-quicksort">
<span class="section-number">7.8.1 </span>QuickSort</h4>

<p>The first part of this how-to implements a well-known <a href="https://en.wikipedia.org/wiki/Quicksort">quicksort</a> algorithm in a parallel way (see <a href="chap12.html#demos">demo</a> application <code>44_Fork-Join QuickSort</code> for the full code).</p>

<p>Let’s start with a non-optimized single-threaded sorter. This simple implementation is easy to convert to the multi-threaded form.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TSequentialSorter</code><code class="o">.</code><code class="nf">QuickSort</code><code class="p">(</code><code class="n">left</code><code class="o">,</code> <code class="n">right</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">pivotIndex</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 4 </code><code class="k">begin</code>
<code class="lineno"> 5 </code>  <code class="k">if</code> <code class="n">right</code> <code class="o">&gt;</code> <code class="n">left</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno"> 6 </code>    <code class="k">if</code> <code class="p">(</code><code class="n">right</code> <code class="o">-</code> <code class="n">left</code><code class="p">)</code> <code class="o">&lt;=</code> <code class="n">CSortThreshold</code> <code class="k">then</code>
<code class="lineno"> 7 </code>      <code class="n">InsertionSort</code><code class="p">(</code><code class="n">left</code><code class="o">,</code> <code class="n">right</code><code class="p">)</code>
<code class="lineno"> 8 </code>    <code class="k">else</code> <code class="k">begin</code>
<code class="lineno"> 9 </code>      <code class="n">pivotIndex</code> <code class="o">:=</code> <code class="n">Partition</code><code class="p">(</code><code class="n">left</code><code class="o">,</code> <code class="n">right</code><code class="o">,</code> <code class="p">(</code><code class="n">left</code> <code class="o">+</code> <code class="n">right</code><code class="p">)</code> <code class="k">div</code> <code class="mi">2</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">10 </code>      <code class="n">QuickSort</code><code class="p">(</code><code class="n">left</code><code class="o">,</code> <code class="n">pivotIndex</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">11 </code>      <code class="n">QuickSort</code><code class="p">(</code><code class="n">pivotIndex</code> <code class="o">+</code> <code class="mi">1</code><code class="o">,</code> <code class="n">right</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">14 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>As you can see, the code switches to an insertion sort when the dimension of the array drops below some threshold. This is not important for the single-threaded version (it only brings a small speedup) but it will help immensely with the multi-threaded version.</p>

<p>Converting this quicksort to a multi-threaded version is simple.</p>

<p>Firstly, we have to create a <em>Fork/Join</em> computation pool. In this example, it is stored in a global field.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FForkJoin</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">ForkJoin</code><code class="o">;</code>
</pre></div>

</figure>

<p>Secondly, we have to adapt the <code>QuickSort</code> method.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TParallelSorter</code><code class="o">.</code><code class="nf">QuickSort</code><code class="p">(</code><code class="n">left</code><code class="o">,</code> <code class="n">right</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">pivotIndex</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">sortLeft</code>  <code class="o">:</code> <code class="n">IOmniCompute</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="n">sortRight</code> <code class="o">:</code> <code class="n">IOmniCompute</code><code class="o">;</code>
<code class="lineno"> 6 </code><code class="k">begin</code>
<code class="lineno"> 7 </code>  <code class="k">if</code> <code class="n">right</code> <code class="o">&gt;</code> <code class="n">left</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno"> 8 </code>    <code class="k">if</code> <code class="p">(</code><code class="n">right</code> <code class="o">-</code> <code class="n">left</code><code class="p">)</code> <code class="o">&lt;=</code> <code class="n">CSortThreshold</code> <code class="k">then</code>
<code class="lineno"> 9 </code>      <code class="n">InsertionSort</code><code class="p">(</code><code class="n">left</code><code class="o">,</code> <code class="n">right</code><code class="p">)</code>
<code class="lineno">10 </code>    <code class="k">else</code> <code class="k">begin</code>
<code class="lineno">11 </code>      <code class="n">pivotIndex</code> <code class="o">:=</code> <code class="n">Partition</code><code class="p">(</code><code class="n">left</code><code class="o">,</code> <code class="n">right</code><code class="o">,</code> <code class="p">(</code><code class="n">left</code> <code class="o">+</code> <code class="n">right</code><code class="p">)</code> <code class="k">div</code> <code class="mi">2</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>      <code class="n">sortLeft</code> <code class="o">:=</code> <code class="n">FForkJoin</code><code class="o">.</code><code class="n">Compute</code><code class="p">(</code>
<code class="lineno">13 </code>        <code class="k">procedure</code>
<code class="lineno">14 </code>        <code class="k">begin</code>
<code class="lineno">15 </code>          <code class="nf">QuickSort</code><code class="p">(</code><code class="n">left</code><code class="o">,</code> <code class="n">pivotIndex</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">16 </code>        <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">17 </code>      <code class="n">sortRight</code> <code class="o">:=</code> <code class="n">FForkJoin</code><code class="o">.</code><code class="n">Compute</code><code class="p">(</code>
<code class="lineno">18 </code>        <code class="k">procedure</code>
<code class="lineno">19 </code>        <code class="k">begin</code>
<code class="lineno">20 </code>          <code class="nf">QuickSort</code><code class="p">(</code><code class="n">pivotIndex</code> <code class="o">+</code> <code class="mi">1</code><code class="o">,</code> <code class="n">right</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">21 </code>        <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">22 </code>      <code class="n">sortLeft</code><code class="o">.</code><code class="n">Await</code><code class="o">;</code>
<code class="lineno">23 </code>      <code class="n">sortRight</code><code class="o">.</code><code class="n">Await</code><code class="o">;</code>
<code class="lineno">24 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">25 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">26 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The code looks much longer but changes are simple. Each recursive call to <code>QuickSort</code> is replaced with the call to <code>Compute</code> …</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">sortLeft</code> <code class="o">:=</code> <code class="n">FForkJoin</code><code class="o">.</code><code class="n">Compute</code><code class="p">(</code>
<code class="lineno">2 </code>  <code class="k">procedure</code>
<code class="lineno">3 </code>  <code class="k">begin</code>
<code class="lineno">4 </code>    <code class="nf">QuickSort</code><code class="p">(</code><code class="n">left</code><code class="o">,</code> <code class="n">pivotIndex</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code>  <code class="k">end</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>… and the code <code>Await</code>s on both subtasks.</p>

<p>Instead of calling <code>QuickSort</code> directly, parallel version creates <code>IOmniCompute</code> interface by calling <code>FForkJoin.Compute</code>. This creates a subtask wrapping the anonymous function which was passed to the <code>Compute</code> and puts this subtask into the <em>Fork/Join</em> computation pool. </p>

<p>The subtask is later read from this pool by one of the <em>Fork/Join</em> workers and is processed in the background thread.</p>

<p>Calling <code>Await</code> checks if the subtask has finished its work. In that case, <code>Await</code> returns and the code can proceed. Otherwise (subtask is still working), <code>Await</code> tries to get one subtask from the computation pool, executes it, and then repeats from the beginning (by checking if the subtask has finished its work). This way, all threads are always busy either with executing their own code or a subtask from the computation pool.</p>

<p>Because two <code>IOmniCompute</code> interfaces are stored on the stack in each <code>QuickSort</code> call, this code uses more stack space than the single-threaded version. That is the main reason the parallel execution is stopped at some level and simple sequential version is used to sort remaining fields.</p>

<h4 id="leanpub-auto-parallel-max">
<span class="section-number">7.8.2 </span>Parallel max</h4>

<p>The second part of this how-to finds a maximum element of an array in a parallel way (see <a href="chap12.html#demos">demo</a> application <code>45_Fork-Join max</code> for the full code).</p>

<p>The parallel solution is similar to the quicksort example above with few important differences related to the fact that the code must return a value (the quicksort code merely sorted the array returning nothing).</p>

<p>This directly affects the interface usage – instead of working with <code>IOmniForkJoin</code> and <code>IOmniCompute</code> the code uses <code>IOmniForkJoin&lt;T&gt;</code> and <code>IOmniCompute&lt;T&gt;</code>. As our example array contains integers, the parallel code creates <code>IOmniForkJoin&lt;integer&gt;</code> and passes it to the <code>ParallelMax</code> function.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="nb">max</code> <code class="o">:=</code> <code class="n">ParallelMax</code><code class="p">(</code><code class="n">Parallel</code><code class="o">.</code><code class="n">ForkJoin</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;,</code> <code class="nb">Low</code><code class="p">(</code><code class="n">FData</code><code class="p">)</code><code class="o">,</code> <code class="nb">High</code><code class="p">(</code><code class="n">FData</code><code class="p">))</code><code class="o">;</code>
</pre></div>

</figure>

<p>In this example <em>Fork/Join</em> computation pool is passed as a parameter. This approach is more flexible but is also slightly slower and – more importantly – uses more stack space.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">function</code> <code class="nf">ParallelMax</code><code class="p">(</code>
<code class="lineno"> 2 </code>  <code class="k">const</code> <code class="n">forkJoin</code><code class="o">:</code> <code class="n">IOmniForkJoin</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;;</code> 
<code class="lineno"> 3 </code>  <code class="n">left</code><code class="o">,</code> <code class="n">right</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 4 </code>
<code class="lineno"> 5 </code><code class="k">var</code>
<code class="lineno"> 6 </code>  <code class="n">computeLeft</code> <code class="o">:</code> <code class="n">IOmniCompute</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;;</code>
<code class="lineno"> 7 </code>  <code class="n">computeRight</code><code class="o">:</code> <code class="n">IOmniCompute</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;;</code>
<code class="lineno"> 8 </code>  <code class="n">mid</code>         <code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 9 </code>
<code class="lineno">10 </code>  <code class="k">function</code> <code class="nf">Compute</code><code class="p">(</code><code class="n">left</code><code class="o">,</code> <code class="n">right</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">IOmniCompute</code><code class="o">&lt;</code><code class="kt">integer</code><code class="o">&gt;;</code>
<code class="lineno">11 </code>  <code class="k">begin</code>
<code class="lineno">12 </code>    <code class="bp">Result</code> <code class="o">:=</code> <code class="n">forkJoin</code><code class="o">.</code><code class="n">Compute</code><code class="p">(</code>
<code class="lineno">13 </code>      <code class="k">function</code><code class="o">:</code> <code class="nf">integer</code>
<code class="lineno">14 </code>      <code class="k">begin</code>
<code class="lineno">15 </code>        <code class="bp">Result</code> <code class="o">:=</code> <code class="n">ParallelMax</code><code class="p">(</code><code class="n">forkJoin</code><code class="o">,</code> <code class="n">left</code><code class="o">,</code> <code class="n">right</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">16 </code>      <code class="k">end</code>
<code class="lineno">17 </code>    <code class="p">)</code><code class="o">;</code>
<code class="lineno">18 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">19 </code>
<code class="lineno">20 </code><code class="k">begin</code>
<code class="lineno">21 </code>  <code class="k">if</code> <code class="p">(</code><code class="n">right</code> <code class="o">-</code> <code class="n">left</code><code class="p">)</code> <code class="o">&lt;</code> <code class="n">CSeqThreshold</code> <code class="k">then</code>
<code class="lineno">22 </code>    <code class="bp">Result</code> <code class="o">:=</code> <code class="n">SequentialMax</code><code class="p">(</code><code class="n">left</code><code class="o">,</code> <code class="n">right</code><code class="p">)</code>
<code class="lineno">23 </code>  <code class="k">else</code> <code class="k">begin</code>
<code class="lineno">24 </code>    <code class="n">mid</code> <code class="o">:=</code> <code class="p">(</code><code class="n">left</code> <code class="o">+</code> <code class="n">right</code><code class="p">)</code> <code class="k">div</code> <code class="mi">2</code><code class="o">;</code>
<code class="lineno">25 </code>    <code class="n">computeLeft</code> <code class="o">:=</code> <code class="n">Compute</code><code class="p">(</code><code class="n">left</code><code class="o">,</code> <code class="n">mid</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">26 </code>    <code class="n">computeRight</code> <code class="o">:=</code> <code class="n">Compute</code><code class="p">(</code><code class="n">mid</code> <code class="o">+</code> <code class="mi">1</code><code class="o">,</code> <code class="n">right</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">27 </code>    <code class="bp">Result</code> <code class="o">:=</code> <code class="nb">Max</code><code class="p">(</code><code class="n">computeLeft</code><code class="o">.</code><code class="n">Value</code><code class="o">,</code> <code class="n">computeRight</code><code class="o">.</code><code class="n">Value</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">28 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">29 </code><code class="k">end</code><code class="o">;</code> 
</pre></div>

</figure>

<p>When the array subrange is small enough, <code>ParallelMax</code> calls the sequential (single threaded) version – just as the parallel QuickSort did, and because of the same reason – not to run out of stack space.</p>

<p>With a big subrange, the code creates two <code>IOmniCompute&lt;integer&gt;</code> subtasks each wrapping a function returning an <code>integer</code>. This function calls back <code>ParallelMax</code> (but with a smaller range). To get the result of the anonymous function wrapped by the <code>Compute</code>, the code calls the <code>Value</code> function. Just as with the <code>Await</code>, <code>Value</code> either returns a result (if it was already computed) or executes other <em>Fork/Join</em> subtasks from the computation pool.</p>

<aside class="tip blurb">
    <p>While creating <em>Fork/Join</em> programs, keep in mind this anti-pattern. The following code fragment is wrong!</p>

  <figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="bp">Result</code> <code class="o">:=</code> <code class="nb">Max</code><code class="p">(</code><code class="n">Compute</code><code class="p">(</code><code class="n">left</code><code class="o">,</code> <code class="n">mid</code><code class="p">)</code><code class="o">.</code><code class="n">Value</code><code class="o">,</code> 
<code class="lineno">2 </code> <code class="n">Compute</code><code class="p">(</code><code class="n">mid</code> <code class="o">+</code> <code class="mi">1</code><code class="o">,</code> <code class="n">right</code><code class="p">)</code><code class="o">.</code><code class="n">Value</code><code class="p">)</code><code class="o">;</code>
</pre></div>

  </figure>

  <p>You must always create all subtasks before calling <code>Await</code> or <code>Value</code>! Otherwise, your code will not execute in parallel at all – it will all be processed by a single thread.</p>

</aside>


<div class="page-break"></div>
<h3 id="howto-parallelSearch">
<span class="section-number">7.9 </span>Parallel search in a tree</h3>

<aside>
  <p><em>My program often searches for data in a large tree structure. The comparison function is pretty convoluted, and the search takes a lot of time. Could it be sped up by using parallelization?</em></p>

</aside>

<p>The <a href="chap06.html#highlevel-foreach"><em>For Each</em></a> abstraction can be used to iterate over complicated structures such as trees. The biggest problem is to assure that the code will always stop.  The solution below achieves this by using special features of the <a href="chap06.html#highlevel-blocking-collection">blocking collection</a>.</p>

<blockquote>
  <p><em>The solution to this problem is available as a <a href="chap12.html#demos">demo</a> application 35_ParallelFor.</em></p>
</blockquote>

<p>The code in the demo application creates a big tree of <code>TNode</code> nodes. Each node contains a value (<code>Value</code>) and a list of child nodes (<code>Child</code>). <code>TNode</code> also implements a function to return the number of children (<code>NumChild</code>), a function that converts the node into a textual representation (<code>ToString</code>; used for printing out the result) and an enumerator that will allow us to access child nodes in a nice structured fashion (<code>Children</code>). To learn more about the implementation of <code>TNode</code> and its enumerator, see the demo program.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">type</code>
<code class="lineno">2 </code>  <code class="n">Node</code> <code class="o">=</code> <code class="k">class</code>
<code class="lineno">3 </code>    <code class="n">Value</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">4 </code>    <code class="n">Child</code><code class="o">:</code> <code class="k">array</code> <code class="k">of</code> <code class="n">TNode</code><code class="o">;</code>
<code class="lineno">5 </code>    <code class="k">function</code>  <code class="nf">NumChild</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">6 </code>    <code class="k">function</code>  <code class="nf">ToString</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code> <code class="k">reintroduce</code><code class="o">;</code>
<code class="lineno">7 </code>    <code class="k">function</code>  <code class="nf">Children</code><code class="o">:</code> <code class="n">TNodeChildEnumeratorFactory</code><code class="o">;</code>
<code class="lineno">8 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>For comparison the demo program implements sequential search function <code>SeqScan</code> which uses recursion to traverse the tree.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">function</code> <code class="nc">TfrmParallelForDemo</code><code class="o">.</code><code class="nf">SeqScan</code><code class="p">(</code><code class="n">node</code><code class="o">:</code> <code class="n">TNode</code><code class="o">;</code> 
<code class="lineno"> 2 </code>  <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">TNode</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="k">var</code>
<code class="lineno"> 4 </code>  <code class="n">iNode</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="k">if</code> <code class="n">node</code><code class="o">.</code><code class="n">Value</code> <code class="o">=</code> <code class="n">value</code> <code class="k">then</code>
<code class="lineno"> 7 </code>    <code class="bp">Result</code> <code class="o">:=</code> <code class="n">node</code>
<code class="lineno"> 8 </code>  <code class="k">else</code> <code class="k">begin</code>
<code class="lineno"> 9 </code>    <code class="bp">Result</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">for</code> <code class="n">iNode</code> <code class="o">:=</code> <code class="mi">0</code> <code class="k">to</code> <code class="n">node</code><code class="o">.</code><code class="n">NumChild</code> <code class="o">-</code> <code class="mi">1</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">11 </code>      <code class="bp">Result</code> <code class="o">:=</code> <code class="n">SeqScan</code><code class="p">(</code><code class="n">node</code><code class="o">.</code><code class="n">Child</code><code class="p">[</code><code class="n">iNode</code><code class="p">]</code><code class="o">,</code> <code class="n">value</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>      <code class="k">if</code> <code class="nb">assigned</code><code class="p">(</code><code class="bp">Result</code><code class="p">)</code> <code class="k">then</code>
<code class="lineno">13 </code>        <code class="k">break</code><code class="o">;</code> <code class="c1">//for iNode</code>
<code class="lineno">14 </code>    <code class="k">end</code><code class="o">;</code>
<code class="lineno">15 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">16 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The parallel version of this function is more complicated. It uses a blocking collection that is shared between all <code>ForEach</code> tasks. This blocking collection contains all nodes that have yet to be traversed. At the beginning, it contains only the root node. Each task executes the following pseudo-code:</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code>while &lt;there are nodes in the blocking collection&gt;
<code class="lineno">2 </code>  &lt;take one node from the blocking collection&gt;
<code class="lineno">3 </code>  &lt;if the node contains the value we're searching for, stop&gt;
<code class="lineno">4 </code>  &lt;put all children of this node into the blocking collection&gt;
</pre></div>

</figure>

<p>The real code is more complicated because of two complications. Firstly, when a value is found, all <code>ForEach</code> tasks must stop, not just the one that had found the value. Secondly, the code must stop if the value we’re searching for is not present in the tree. In the pseudo-code above this is automatically achieved by the condition in the <code>while</code> statement but in reality this is not so easy. At some time the blocking collection may be empty when there is still data to be processed. (For example, just at the beginning when the first task takes out the root node of the tree. Yes, this does mean that the condition in the <code>while</code> statement above is not completely valid.) </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">function</code> <code class="nc">TfrmParallelForDemo</code><code class="o">.</code><code class="nf">ParaScan</code><code class="p">(</code><code class="n">rootNode</code><code class="o">:</code> <code class="n">TNode</code><code class="o">;</code> <code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">:</code> <code class="n">TNode</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">cancelToken</code><code class="o">:</code> <code class="n">IOmniCancellationToken</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">nodeQueue</code>  <code class="o">:</code> <code class="n">IOmniBlockingCollection</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="n">nodeResult</code> <code class="o">:</code> <code class="n">TNode</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="n">numTasks</code>   <code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 7 </code><code class="k">begin</code>
<code class="lineno"> 8 </code>  <code class="n">nodeResult</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="n">cancelToken</code> <code class="o">:=</code> <code class="n">CreateOmniCancellationToken</code><code class="o">;</code>
<code class="lineno">10 </code>  <code class="n">numTasks</code> <code class="o">:=</code> <code class="n">Environment</code><code class="o">.</code><code class="n">Process</code><code class="o">.</code><code class="n">Affinity</code><code class="o">.</code><code class="n">Count</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="n">nodeQueue</code> <code class="o">:=</code> <code class="n">TOmniBlockingCollection</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="n">numTasks</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="n">nodeQueue</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">rootNode</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="n">Parallel</code><code class="o">.</code><code class="n">ForEach</code><code class="p">(</code><code class="n">nodeQueue</code> <code class="k">as</code> <code class="n">IOmniValueEnumerable</code><code class="p">)</code>
<code class="lineno">14 </code>    <code class="o">.</code><code class="n">NumTasks</code><code class="p">(</code><code class="n">numTasks</code><code class="p">)</code> <code class="c1">// must be same number of task as in</code>
<code class="lineno">15 </code>                        <code class="c1">// nodeQueue to ensure stopping</code>
<code class="lineno">16 </code>    <code class="o">.</code><code class="n">CancelWith</code><code class="p">(</code><code class="n">cancelToken</code><code class="p">)</code>
<code class="lineno">17 </code>    <code class="o">.</code><code class="n">Execute</code><code class="p">(</code>
<code class="lineno">18 </code>      <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">elem</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno">19 </code>      <code class="k">var</code>
<code class="lineno">20 </code>        <code class="n">childNode</code><code class="o">:</code> <code class="n">TNode</code><code class="o">;</code>
<code class="lineno">21 </code>        <code class="n">node</code>     <code class="o">:</code> <code class="n">TNode</code><code class="o">;</code>
<code class="lineno">22 </code>      <code class="k">begin</code>
<code class="lineno">23 </code>        <code class="n">node</code> <code class="o">:=</code> <code class="n">TNode</code><code class="p">(</code><code class="n">elem</code><code class="o">.</code><code class="n">AsObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">24 </code>        <code class="k">if</code> <code class="n">node</code><code class="o">.</code><code class="n">Value</code> <code class="o">=</code> <code class="n">value</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno">25 </code>          <code class="n">nodeResult</code> <code class="o">:=</code> <code class="n">node</code><code class="o">;</code>
<code class="lineno">26 </code>          <code class="n">nodeQueue</code><code class="o">.</code><code class="n">CompleteAdding</code><code class="o">;</code>
<code class="lineno">27 </code>          <code class="n">cancelToken</code><code class="o">.</code><code class="n">Signal</code><code class="o">;</code>
<code class="lineno">28 </code>        <code class="k">end</code>
<code class="lineno">29 </code>        <code class="k">else</code> <code class="k">for</code> <code class="n">childNode</code> <code class="k">in</code> <code class="n">node</code><code class="o">.</code><code class="n">Children</code> <code class="k">do</code>
<code class="lineno">30 </code>          <code class="n">nodeQueue</code><code class="o">.</code><code class="n">TryAdd</code><code class="p">(</code><code class="n">childNode</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">31 </code>      <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">32 </code>  <code class="bp">Result</code> <code class="o">:=</code> <code class="n">nodeResult</code><code class="o">;</code>
<code class="lineno">33 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The code first creates a <a href="chap07.html#lowlevel-simpletasks-cancellationtoken"><em>cancellation token</em></a> which will be used to stop the <code>ForEach</code> loop. Number of tasks is set to number of cores accessible from the process and a blocking collection is created.</p>

<p>Resource count for this collection is initialized to the number of tasks (<code>numTasks</code> parameter to the <code>TOmniBlockingCollection.Create</code>). This assures that the blocking collection will be automatically put into the ‘completed’ mode (as if the <code>CompleteAdding</code> had been called) if <code>numTasks</code> threads are simultaneously calling <code>Take</code> and the collection is empty. This prevents the ‘resource exhaustion’ scenario – if all workers are waiting for new data and the collection is empty, then there’s no way for new data to appear and the waiting is stopped by putting the collection into <em>completed</em> state.</p>

<p>The root node of the tree is added to the blocking collection. Then the <code>Parallel.ForEach</code> is called, enumerating the blocking collection.</p>

<p>The code also passes cancellation token to the <code>ForEach</code> loop and starts the parallel execution. In each parallel task, the following code is executed (this code is copied from the full <code>ParaScan</code> example above):</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">elem</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">childNode</code><code class="o">:</code> <code class="n">TNode</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">node</code>     <code class="o">:</code> <code class="n">TNode</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="n">node</code> <code class="o">:=</code> <code class="n">TNode</code><code class="p">(</code><code class="n">elem</code><code class="o">.</code><code class="n">AsObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="k">if</code> <code class="n">node</code><code class="o">.</code><code class="n">Value</code> <code class="o">=</code> <code class="n">value</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno"> 8 </code>    <code class="n">nodeResult</code> <code class="o">:=</code> <code class="n">node</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="n">nodeQueue</code><code class="o">.</code><code class="n">CompleteAdding</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="n">cancelToken</code><code class="o">.</code><code class="n">Signal</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="k">end</code>
<code class="lineno">12 </code>  <code class="k">else</code> <code class="k">for</code> <code class="n">childNode</code> <code class="k">in</code> <code class="n">node</code><code class="o">.</code><code class="n">Children</code> <code class="k">do</code>
<code class="lineno">13 </code>    <code class="n">nodeQueue</code><code class="o">.</code><code class="n">TryAdd</code><code class="p">(</code><code class="n">childNode</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">14 </code><code class="k">end</code>
</pre></div>

</figure>

<p>The code is provided with one element from the blocking collection at a time. If the <code>Value</code> field is the value we’re searching for, <code>nodeResult</code> is set, blocking collection is put into <code>CompleteAdding</code> state (so that enumerators in other tasks will terminate blocking wait (if any)) and cancellation token is signalled to stop other tasks that are not blocked.</p>

<p>Otherwise (not the value we’re looking for), all the children of the current node are added to the blocking collection. <code>TryAdd</code> is used (and its return value ignored) because another thread may call <code>CompleteAdding</code> while the <code>for childNode</code> loop is being executed.</p>

<p>Parallel for loop is therefore iterating over a blocking collection into which nodes are put (via the <code>for childNode</code> loop) and from which they are removed (via the <code>ForEach</code> implementation). If child nodes are not provided fast enough, blocking collection will block on <code>Take</code> and one or more tasks may sleep for some time until new values appear. Only when the value is found, the blocking collection and <code>ForEach</code> loop are completed/cancelled.</p>


<div class="page-break"></div>
<h3 id="howto-multiFrame">
<span class="section-number">7.10 </span>Multiple workers with multiple frames</h3>

<aside>
  <p><em>I am running multiple background tasks implemented with OmniThreadLibrary’s <code>CreateTask</code> function and they are all interacting with the same form in the program. I want to separate user interface into separate frames, each interacting with one task but I can’t find a good way to do it.</em></p>

</aside>

<p>The solution to this problem can be split into three parts – the worker, the frame and the binding code in the form unit.</p>

<blockquote>
  <p><em>The solution to this problem is available as a <a href="chap12.html#demos">demo</a> application 49_FramedWorkers.</em></p>
</blockquote>

<h4 id="leanpub-auto-the-worker">
<span class="section-number">7.10.1 </span>The worker</h4>

<p>In this example (unit <code>test_49_Worker</code> in the demo application), the worker code is intentionally simple. It implements a timer which, triggered approximately every second, sends a message to the owner. This message is received in a <code>Msg</code> parameter when the task is created. The worker can also respond to a <code>MSG_HELLO</code> message with a <code>'Hello'</code> response.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TFramedWorker</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TOmniWorker</code><code class="p">)</code>
<code class="lineno"> 3 </code>  <code class="n">strict</code> <code class="kp">private</code>
<code class="lineno"> 4 </code>    <code class="n">FMessage</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="kp">public</code>
<code class="lineno"> 6 </code>    <code class="k">function</code> <code class="nf">Initialize</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code> <code class="kp">override</code><code class="o">;</code>
<code class="lineno"> 7 </code>    <code class="k">procedure</code> <code class="nf">MsgHello</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code> <code class="n">message</code> <code class="n">MSG_HELLO</code><code class="o">;</code>
<code class="lineno"> 8 </code>    <code class="k">procedure</code> <code class="nf">Timer1</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">10 </code>
<code class="lineno">11 </code><code class="k">function</code> <code class="nc">TFramedWorker</code><code class="o">.</code><code class="nf">Initialize</code><code class="o">:</code> <code class="kt">boolean</code><code class="o">;</code>
<code class="lineno">12 </code><code class="k">begin</code>
<code class="lineno">13 </code>  <code class="bp">Result</code> <code class="o">:=</code> <code class="k">inherited</code> <code class="nb">Initialize</code><code class="o">;</code>
<code class="lineno">14 </code>  <code class="k">if</code> <code class="bp">Result</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno">15 </code>    <code class="n">FMessage</code> <code class="o">:=</code> <code class="n">Task</code><code class="o">.</code><code class="n">Param</code><code class="p">[</code><code class="s">'Msg'</code><code class="p">]</code><code class="o">;</code>
<code class="lineno">16 </code>    <code class="n">Task</code><code class="o">.</code><code class="n">SetTimer</code><code class="p">(</code><code class="mi">1</code><code class="o">,</code> <code class="mi">1000</code> <code class="o">+</code> <code class="nb">Random</code><code class="p">(</code><code class="mi">500</code><code class="p">)</code><code class="o">,</code> <code class="o">@</code><code class="n">TFramedWorker</code><code class="o">.</code><code class="n">Timer1</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">17 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">18 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">19 </code>
<code class="lineno">20 </code><code class="k">procedure</code> <code class="nc">TFramedWorker</code><code class="o">.</code><code class="nf">MsgHello</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">21 </code><code class="k">begin</code>
<code class="lineno">22 </code>  <code class="n">Task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="n">MSG_NOTIFY</code><code class="o">,</code> <code class="s">'Hello, '</code> <code class="o">+</code> <code class="n">msg</code><code class="o">.</code><code class="n">MsgData</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">23 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">24 </code>
<code class="lineno">25 </code><code class="k">procedure</code> <code class="nc">TFramedWorker</code><code class="o">.</code><code class="nf">Timer1</code><code class="o">;</code>
<code class="lineno">26 </code><code class="k">begin</code>
<code class="lineno">27 </code>  <code class="n">Task</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="n">MSG_NOTIFY</code><code class="o">,</code> <code class="s">'... '</code> <code class="o">+</code> <code class="n">FMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">28 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>Message ID’s (<code>MSG_HELLO</code>, <code>MSG_NOTIFY</code>) are defined in unit <code>test_49_Common</code> as they are shared with the frame implementation.</p>

<h4 id="leanpub-auto-the-frame">
<span class="section-number">7.10.2 </span>The frame</h4>

<p>The frame (unit <code>test_49_FrameWithWorker</code>) contains a listbox and a button. It implements a response function for the <code>MSG_NOTIFY</code> message – <code>MsgNotify</code> – and it contains a reference to the worker task. This reference will be set in the main form when the task and the frame are constructed.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">type</code>
<code class="lineno"> 2 </code>  <code class="n">TfrmFrameWithWorker</code> <code class="o">=</code> <code class="k">class</code><code class="p">(</code><code class="n">TFrame</code><code class="p">)</code>
<code class="lineno"> 3 </code>    <code class="n">lbLog</code><code class="o">:</code> <code class="n">TListBox</code><code class="o">;</code>
<code class="lineno"> 4 </code>    <code class="n">btnHello</code><code class="o">:</code> <code class="n">TButton</code><code class="o">;</code>
<code class="lineno"> 5 </code>    <code class="k">procedure</code> <code class="nf">btnHelloClick</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="kp">private</code>
<code class="lineno"> 7 </code>    <code class="n">FWorker</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="kp">public</code>
<code class="lineno"> 9 </code>    <code class="k">property</code> <code class="py">Worker</code><code class="o">:</code> <code class="n">IOmniTaskControl</code> <code class="kp">read</code> <code class="nf">FWorker</code> <code class="kp">write</code> <code class="nf">FWorker</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="k">procedure</code> <code class="nf">MsgNotify</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code> <code class="n">message</code> <code class="n">MSG_NOTIFY</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The <code>MsgNotify</code> method is automatically called whenever the <code>MSG_NOTIFY</code> message is received by the frame. It merely shows the message contents.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmFrameWithWorker</code><code class="o">.</code><code class="nf">MsgNotify</code><code class="p">(</code><code class="k">var</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="n">lbLog</code><code class="o">.</code><code class="n">ItemIndex</code> <code class="o">:=</code> <code class="n">lbLog</code><code class="o">.</code><code class="n">Items</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">msg</code><code class="o">.</code><code class="n">MsgData</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>A click on the button sends a <code>MSG_HELLO</code> message to the worker. A name of the frame is sent as a parameter. The worker will include this name in the response so we can verify that the response is indeed sent to the correct frame.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmFrameWithWorker</code><code class="o">.</code><code class="nf">btnHelloClick</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="n">Worker</code><code class="o">.</code><code class="n">Comm</code><code class="o">.</code><code class="n">Send</code><code class="p">(</code><code class="n">MSG_HELLO</code><code class="o">,</code> <code class="n">Name</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-the-form">
<span class="section-number">7.10.3 </span>The form</h4>

<p>Five frame/worker pairs are created in the form while it is being created. The code in <code>FormCreate</code> creates and positions each frame and then creates a worker named <code>Frame #%d</code> (where <code>%d</code> is replaced with the sequential number of the frame). Workers are created in the <code>CreateWorker</code> method.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">const</code>
<code class="lineno"> 2 </code>  <code class="n">CNumFrames</code> <code class="o">=</code> <code class="mi">5</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">CFrameWidth</code> <code class="o">=</code> <code class="mi">150</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">CFrameHeight</code> <code class="o">=</code> <code class="mi">200</code><code class="o">;</code>
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code><code class="k">function</code> <code class="nc">TfrmFramedWorkers</code><code class="o">.</code><code class="nf">CreateFrame</code><code class="p">(</code><code class="n">left</code><code class="o">,</code> <code class="n">top</code><code class="o">,</code> <code class="n">width</code><code class="o">,</code> <code class="n">height</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="k">const</code> <code class="kp">name</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">:</code> <code class="n">TfrmFrameWithWorker</code><code class="o">;</code>
<code class="lineno"> 8 </code><code class="k">begin</code>
<code class="lineno"> 9 </code>  <code class="bp">Result</code> <code class="o">:=</code> <code class="n">TfrmFrameWithWorker</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="k">Self</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">10 </code>  <code class="bp">Result</code><code class="o">.</code><code class="n">Parent</code> <code class="o">:=</code> <code class="k">Self</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="bp">Result</code><code class="o">.</code><code class="n">Left</code> <code class="o">:=</code> <code class="n">left</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="bp">Result</code><code class="o">.</code><code class="n">Top</code> <code class="o">:=</code> <code class="n">top</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="bp">Result</code><code class="o">.</code><code class="n">Width</code> <code class="o">:=</code> <code class="n">width</code><code class="o">;</code>
<code class="lineno">14 </code>  <code class="bp">Result</code><code class="o">.</code><code class="n">Height</code> <code class="o">:=</code> <code class="n">height</code><code class="o">;</code>
<code class="lineno">15 </code>  <code class="bp">Result</code><code class="o">.</code><code class="n">Name</code> <code class="o">:=</code> <code class="n">name</code><code class="o">;</code>
<code class="lineno">16 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">17 </code>
<code class="lineno">18 </code><code class="k">procedure</code> <code class="nc">TfrmFramedWorkers</code><code class="o">.</code><code class="nf">FormCreate</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">19 </code><code class="k">var</code>
<code class="lineno">20 </code>  <code class="n">frame</code> <code class="o">:</code> <code class="n">TfrmFrameWithWorker</code><code class="o">;</code>
<code class="lineno">21 </code>  <code class="n">iFrame</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno">22 </code><code class="k">begin</code>
<code class="lineno">23 </code>  <code class="n">FTaskGroup</code> <code class="o">:=</code> <code class="n">CreateTaskGroup</code><code class="o">;</code>
<code class="lineno">24 </code>  <code class="k">for</code> <code class="n">iFrame</code> <code class="o">:=</code> <code class="mi">1</code> <code class="k">to</code> <code class="n">CNumFrames</code> <code class="k">do</code> <code class="k">begin</code>
<code class="lineno">25 </code>    <code class="n">frame</code> <code class="o">:=</code> <code class="n">CreateFrame</code><code class="p">(</code>
<code class="lineno">26 </code>      <code class="n">CFrameWidth</code> <code class="o">*</code> <code class="p">(</code><code class="n">iFrame</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code><code class="o">,</code> <code class="mi">0</code><code class="o">,</code> <code class="n">CFrameWidth</code><code class="o">,</code> <code class="n">CFrameHeight</code><code class="o">,</code>
<code class="lineno">27 </code>      <code class="nb">Format</code><code class="p">(</code><code class="s">'Frame%d'</code><code class="o">,</code> <code class="p">[</code><code class="n">iFrame</code><code class="p">]))</code><code class="o">;</code>
<code class="lineno">28 </code>    <code class="n">CreateWorker</code><code class="p">(</code><code class="n">frame</code><code class="o">,</code> <code class="nb">Format</code><code class="p">(</code><code class="s">'Frame #%d'</code><code class="o">,</code> <code class="p">[</code><code class="n">iFrame</code><code class="p">]))</code><code class="o">;</code>
<code class="lineno">29 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">30 </code>  <code class="n">ClientWidth</code> <code class="o">:=</code> <code class="n">CNumFrames</code> <code class="o">*</code> <code class="n">CFrameWidth</code><code class="o">;</code>
<code class="lineno">31 </code>  <code class="n">ClientHeight</code> <code class="o">:=</code> <code class="n">CFrameHeight</code><code class="o">;</code>
<code class="lineno">32 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The <code>FormCreate</code> method also creates a <a href="chap07.html#lowlevel-taskgroup">task group</a> which is used to terminate all workers when a form is closed.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmFramedWorkers</code><code class="o">.</code><code class="nf">FormDestroy</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="n">FTaskGroup</code><code class="o">.</code><code class="n">TerminateAll</code><code class="o">;</code>
<code class="lineno">4 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The final piece of the puzzle is the <code>CreateWorker</code> method. It creates a low-level task and sets its name. The same name is assigned to the <code>Msg</code> parameter so that it will be used in messages sent from the task. The <code>OnMessage</code> call assigns the frame to function as a ‘message-processor’ for the tasks – all messages from the task will be dispatched to the frame. That’s how the <code>MSG_NOTIFY</code> message ends up being processed by the frame’s <code>MsgNotify</code> method. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmFramedWorkers</code><code class="o">.</code><code class="nf">CreateWorker</code><code class="p">(</code><code class="n">frame</code><code class="o">:</code> <code class="n">TfrmFrameWithWorker</code><code class="o">;</code>
<code class="lineno"> 2 </code>  <code class="k">const</code> <code class="n">caption</code><code class="o">:</code> <code class="k">string</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="k">var</code>
<code class="lineno"> 4 </code>  <code class="n">worker</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="n">worker</code> <code class="o">:=</code> <code class="n">CreateTask</code><code class="p">(</code><code class="n">TFramedWorker</code><code class="o">.</code><code class="n">Create</code><code class="p">()</code><code class="o">,</code> <code class="n">caption</code><code class="p">)</code>
<code class="lineno"> 7 </code>    <code class="o">.</code><code class="n">SetParameter</code><code class="p">(</code><code class="s">'Msg'</code><code class="o">,</code> <code class="n">caption</code><code class="p">)</code>
<code class="lineno"> 8 </code>    <code class="o">.</code><code class="n">OnMessage</code><code class="p">(</code><code class="n">frame</code><code class="p">)</code>
<code class="lineno"> 9 </code>    <code class="o">.</code><code class="n">Run</code><code class="o">;</code>
<code class="lineno">10 </code>  <code class="n">frame</code><code class="o">.</code><code class="n">Worker</code> <code class="o">:=</code> <code class="n">worker</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="n">FTaskGroup</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">worker</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The code above also assigns the worker to the frame and adds the worker to the task group.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 468px;">
    <img src="images/framedWorkers.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<blockquote>
  <p>For a different approach to multiple workers problem see <a href="chap10.html#howto-databases">OmniThreadLibrary and databases</a>.</p>
</blockquote>


<div class="page-break"></div>
<h3 id="howto-databases">
<span class="section-number">7.11 </span>OmniThreadLibrary and databases</h3>

<aside>
  <p><em>Can you tell me how to use databases in combination with OmniThreadLibrary?</em></p>

</aside>

<p>Using databases with the OmniThreadLibrary can be quite simple at times; on the other hand, it can also be quite tricky. The main problem with databases is that you have to create database components in the thread that will be using them. As the visual components (as the TDBGrid) <strong>must</strong> be initialized from the main thread, this implies that you can’t directly connect database-aware GUI controls to database components. </p>

<p>Because of that, you have to devise a mechanism that transfers database data from the task to the main thread (and also – if the database access is not read-only – a mechanism that will send updates to the task so they can be applied to the database). In most cases this means you should ignore database-aware components and just build the GUI without them. In some cases, however, you could do a lot with splitting the existing database infrastructure at the correct point and leaving the GUI part almost unmodified. This example explores such an option.</p>

<blockquote>
  <p><em>An example is included with the OmniThreadLibrary distribution in the <code>examples/twofish</code> folder.</em></p>
</blockquote>

<p>The basis for this article is the well-known <em>Fish Facts</em> demo program, included in Delphi’s <em>Samples</em><sup id="fnref-delphi-samples-fishfact"><a href="chap17.html#fn-delphi-samples-fishfact" rel="footnote">18</a></sup> folder. This is a simple application that uses database-aware controls to display data from an InterBase database.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 80%;">
    <img src="images/fishFacts.png" alt="The Fish Facts demo" style="width: 100%;" />
    <figcaption>The Fish Facts demo</figcaption>
  </figure>
</div>


<p>I have built a view-only version of <em>Fish Facts</em> called <em>TwoFish</em> which uses two frames, each containing data-aware controls and a background thread which accesses the InterBase data. Both frames are running in parallel and accessing the data at the same time.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 468px;">
    <img src="images/twoFish.png" alt="The TwoFish demo" style="width: 100%;" />
    <figcaption>The TwoFish demo</figcaption>
  </figure>
</div>


<h4 id="leanpub-auto-database-model">
<span class="section-number">7.11.1 </span>Database model</h4>

<p>To create the <em>TwoFish</em>, I have copied <em>Fish Facts</em> components <code>IBDatabase1</code>, <code>IBTransaction1</code> and <code>IBTable1</code> into a data module <code>twoFishDB</code>. This data module contains no code, only these three components. I have also set <code>IBDatabase1.Connected</code> and <code>IBTable1.Active</code> to <code>False</code>. </p>

<p>Then I created the frame <code>twoFishDB_GUI</code> which uses the data module <code>twoFishDB</code>. This frame contains an unconnected <code>TDataSource</code> component <code>DataSource1</code> and all data-aware components that are placed on the <em>Fish Facts</em> form – <code>TDBGrid</code>, <code>TDBImage</code>, <code>TDBText</code> and <code>TDBMemo</code>. They are all connected to the <code>DataSource1</code>.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 468px;">
    <img src="images/howto-database.png" alt="TwoFish data model" style="width: 100%;" />
    <figcaption>TwoFish data model</figcaption>
  </figure>
</div>


<p>Main <em>TwoFish</em> program creates two frames. Each frame creates a <a href="chap06.html#highlevel-backgroundworker"><em>Background Worker</em></a> abstraction that (inside the worker task) creates the data module and activates database and database table (more details are given below).</p>

<p>When data is to be retrieved, the task creates a <code>TClientDataSet</code> and a <code>TDataSetProvider</code> which ‘pumps’ all data from the <code>IBTable1</code> to the <code>TClientDataSet</code>. This client data set is then sent to the main form which connects it to the <code>DataSource1</code>. This automatically causes the data to be displayed in the data-aware controls. To keep the example simple, I have disabled data editing.</p>

<p>The most important points of this example are:</p>

<ul>
  <li>Data module is initialized from the task, not from the frame’s event handlers. This way it is initialized in the thread that uses it.</li>
  <li>Data module is destroyed before the <code>OnDestroy</code> is called (<code>OnCloseQuery</code> is used for this purpose). If you try to destroy the data module from the <code>OnDestroy</code>, a deadlock will occur inside the Delphi RTL code.</li>
</ul>

<p>This example shows a different approach to frame-task interaction than the <a href="chap10.html#howto-multiFrame">Multiple workers with multiple frames</a> – here the background worker is managed by the frame itself, not by the main form.</p>

<h4 id="leanpub-auto-frame-and-worker">
<span class="section-number">7.11.2 </span>Frame and worker</h4>

<p>The frame wraps one background task that operates on the database and contains database-aware controls displaying the database data.</p>

<p>The <em>Background Worker</em> abstraction is created in the <code>AfterConstruction</code> method and destroyed in the <code>BeforeDestruction</code> method. <code>AfterConstruction</code> creates a background worker and specifies task initializer and finalizer (<code>.Initialize</code> and <code>.Finalize</code>). Delegates provided to these two functions (<code>InitializeDatabase</code> and <code>FinalizeDatabase</code>) are called when background worker task is created and before it is destroyed.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmTwoFishDB_GUI</code><code class="o">.</code><code class="nf">AfterConstruction</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="k">inherited</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">FWorker</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">BackgroundWorker</code>
<code class="lineno"> 5 </code>    <code class="o">.</code><code class="n">Initialize</code><code class="p">(</code><code class="n">InitializeDatabase</code><code class="p">)</code>
<code class="lineno"> 6 </code>    <code class="o">.</code><code class="n">Finalize</code><code class="p">(</code><code class="n">FinalizeDatabase</code><code class="p">)</code>
<code class="lineno"> 7 </code>    <code class="o">.</code><code class="n">Execute</code><code class="o">;</code>
<code class="lineno"> 8 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno"> 9 </code>
<code class="lineno">10 </code><code class="k">procedure</code> <code class="nc">TfrmTwoFishDB_GUI</code><code class="o">.</code><code class="nf">BeforeDestruction</code><code class="o">;</code>
<code class="lineno">11 </code><code class="k">begin</code>
<code class="lineno">12 </code>  <code class="n">CloseConnection</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="k">inherited</code><code class="o">;</code>
<code class="lineno">14 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">15 </code>
<code class="lineno">16 </code><code class="k">procedure</code> <code class="nc">TfrmTwoFishDB_GUI</code><code class="o">.</code><code class="nf">CloseConnection</code><code class="o">;</code>
<code class="lineno">17 </code><code class="k">begin</code>
<code class="lineno">18 </code>  <code class="k">if</code> <code class="nb">assigned</code><code class="p">(</code><code class="n">FWorker</code><code class="p">)</code> <code class="k">then</code> <code class="k">begin</code>
<code class="lineno">19 </code>    <code class="n">FWorker</code><code class="o">.</code><code class="n">Terminate</code><code class="p">(</code><code class="n">INFINITE</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">20 </code>    <code class="n">FWorker</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
<code class="lineno">21 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">22 </code>  <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">FDataSet</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">23 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>You may have noticed that no code was provided to execute work items. The reason behind this is that the background worker will execute different types of requests. Instead of writing <code>if ... then</code> tests to detect the work item type and trigger appropriate code, we’ll pass the executor function together with each request.</p>

<p><code>BeforeDestruction</code> destroys the background worker and destroys the <code>FDataSet</code> component (we’ll see later why it is used).</p>

<p>Task initializer and finalizer are also very simple – they just create and destroy the data module. The data module is accessible to the background worker through the <code>taskState</code> variable.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmTwoFishDB_GUI</code><code class="o">.</code><code class="nf">FinalizeDatabase</code><code class="p">(</code><code class="k">const</code> <code class="n">taskState</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">FDataModule</code><code class="p">)</code>
<code class="lineno"> 4 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno"> 5 </code>
<code class="lineno"> 6 </code><code class="k">procedure</code> <code class="nc">TfrmTwoFishDB_GUI</code><code class="o">.</code><code class="nf">InitializeDatabase</code><code class="p">(</code><code class="k">var</code> <code class="n">taskState</code><code class="o">:</code> <code class="n">TOmniValue</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code><code class="k">begin</code>
<code class="lineno"> 8 </code>  <code class="n">FDataModule</code> <code class="o">:=</code> <code class="n">TdmTwoFishDB</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="k">nil</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 9 </code>  <code class="n">taskState</code> <code class="o">:=</code> <code class="n">FDataModule</code><code class="o">;</code>
<code class="lineno">10 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h5 id="leanpub-auto-connecting-to-the-database">
<span class="section-number">7.11.2.1 </span>Connecting to the database</h5>

<p>Data controls are initially in an unconnected state. They are only connected when the public method <code>OpenConnection</code> is called.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmTwoFishDB_GUI</code><code class="o">.</code><code class="nf">OpenConnection</code><code class="p">(</code><code class="k">const</code> <code class="n">databaseName</code><code class="o">:</code> <code class="k">string</code><code class="o">;</code>
<code class="lineno"> 2 </code>  <code class="n">onConnectionOpen</code><code class="o">:</code> <code class="n">TNotify</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="k">begin</code>
<code class="lineno"> 4 </code>  <code class="n">FWorker</code><code class="o">.</code><code class="n">Schedule</code><code class="p">(</code>
<code class="lineno"> 5 </code>    <code class="n">FWorker</code><code class="o">.</code><code class="n">CreateWorkItem</code><code class="p">(</code><code class="n">databaseName</code><code class="p">)</code><code class="o">,</code>
<code class="lineno"> 6 </code>    <code class="n">FWorker</code><code class="o">.</code><code class="n">Config</code><code class="o">.</code><code class="n">OnExecute</code><code class="p">(</code><code class="n">ConnectToDatabase</code><code class="p">)</code><code class="o">.</code><code class="n">OnRequestDone</code><code class="p">(</code>
<code class="lineno"> 7 </code>      <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">Sender</code><code class="o">:</code> <code class="n">IOmniBackgroundWorker</code><code class="o">;</code> 
<code class="lineno"> 8 </code>        <code class="k">const</code> <code class="n">workItem</code><code class="o">:</code> <code class="n">IOmniWorkItem</code><code class="p">)</code>
<code class="lineno"> 9 </code>      <code class="k">begin</code>
<code class="lineno">10 </code>        <code class="k">if</code> <code class="nb">assigned</code><code class="p">(</code><code class="n">onConnectionOpen</code><code class="p">)</code> <code class="k">then</code>
<code class="lineno">11 </code>          <code class="n">onConnectionOpen</code><code class="p">(</code><code class="k">Self</code><code class="o">,</code> <code class="n">workItem</code><code class="o">.</code><code class="n">FatalException</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">12 </code>      <code class="k">end</code>
<code class="lineno">13 </code>    <code class="p">))</code><code class="o">;</code>
<code class="lineno">14 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>OpenConnection</code> schedules a work request that contains the database name as a parameter. It also sets the executor function (<code>ConnectToDatabase</code>) and an anonymous function that will be executed after the request is processed (<code>OnRequestDone</code>). This anonymous function returns the result of the request to the <code>OpenConnection</code> caller by calling the <code>onConnectionOpen</code> parameter. [Result in this case is exposed as an exception that is triggered if the database connection cannot be established. If the connection can be made, the <code>workItem.FatalException</code> function will return <code>nil</code>.]</p>

<p>The important fact to note is that the <code>OnExecute</code> parameter (<code>ConnectToDatabase</code>) is called from the worker thread and the <code>OnRequestDone</code> parameter (the anonymous function) is called from the thread that created the frame (the main thread). </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmTwoFishDB_GUI</code><code class="o">.</code><code class="nf">ConnectToDatabase</code><code class="p">(</code>
<code class="lineno"> 2 </code>  <code class="k">const</code> <code class="n">workItem</code><code class="o">:</code> <code class="n">IOmniWorkItem</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 3 </code><code class="k">var</code>
<code class="lineno"> 4 </code>  <code class="n">dataModule</code><code class="o">:</code> <code class="n">TdmTwoFishDB</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>
<code class="lineno"> 6 </code>  <code class="n">dataModule</code> <code class="o">:=</code> <code class="p">(</code><code class="n">workItem</code><code class="o">.</code><code class="n">TaskState</code><code class="o">.</code><code class="n">AsObject</code> <code class="k">as</code> <code class="n">TdmTwoFishDB</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 7 </code>  <code class="n">GTwoFishLock</code><code class="o">.</code><code class="n">Acquire</code><code class="o">;</code> <code class="c1">//probably only necessary if using InterBase driver</code>
<code class="lineno"> 8 </code>  <code class="k">try</code>
<code class="lineno"> 9 </code>    <code class="n">dataModule</code><code class="o">.</code><code class="n">IBDatabase1</code><code class="o">.</code><code class="n">DatabaseName</code> <code class="o">:=</code> <code class="n">workItem</code><code class="o">.</code><code class="n">Data</code><code class="o">.</code><code class="n">AsString</code><code class="o">;</code>
<code class="lineno">10 </code>    <code class="n">dataModule</code><code class="o">.</code><code class="n">IBDatabase1</code><code class="o">.</code><code class="n">Connected</code> <code class="o">:=</code> <code class="k">true</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="k">finally</code> <code class="n">GTwoFishLock</code><code class="o">.</code><code class="n">Release</code><code class="o">;</code> <code class="k">end</code><code class="o">;</code>
<code class="lineno">12 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The data module associated with the worker is accessed through the <code>workItem.TaskState</code> property which gives you access to the <code>taskState</code> variable initialized in the <code>InitializeDatabase</code> method. Database name is taken from the work item parameter (<code>workItem.Data</code>). The database name is set in the <code>IBDatabase</code> component and connection is established (<code>Connected := true</code>). If the connection fails, an exception will be raised. This exception is caught by the OmniThreadLibrary and stored in the <code>workItem</code> object where it is later processed by the anonymous method in the <code>OpenConnection</code> method.</p>

<p>The weird <code>Acquire</code>/<code>Release</code> pair is here because of bugs in the <em>gds32.dll</em> – the dynamic library that handles connection to the InterBase. It turns out that <em>gds32</em> handles parallel connections to the database perfectly well – as long as they are not established at the same time. In other words – you can communicate with the database on multiple connections at the same time (get data, put data, execute SQL commands …) but you cannot establish connections in parallel. Sometimes it will work, sometimes it will fail with a mysterious access violation error in the <em>gds32</em> code. That’s why the <em>twoFishDB_GUI</em> unit uses a global <a href="chap08.html#synch-criticalsections">critical section</a> to prevent multiple connections to be established at the same time. <sup id="fnref-how-db-gds"><a href="chap17.html#fn-how-db-gds" rel="footnote">19</a></sup></p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">var</code>
<code class="lineno">2 </code>  <code class="n">GTwoFishLock</code><code class="o">:</code> <code class="n">TOmniCS</code><code class="o">;</code>
</pre></div>

</figure>

<h5 id="leanpub-auto-retrieving-the-data">
<span class="section-number">7.11.2.2 </span>Retrieving the data</h5>

<p>To retrieve data from the database, main unit calls the <code>Reload</code> function. This function is also called inside the frame from the click event on the <em>Reload</em> button.</p>

<p><code>Reload</code> just schedules a work request without any input. To process the request, <code>LoadData</code> will be called.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmTwoFishDB_GUI</code><code class="o">.</code><code class="nf">Reload</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="n">FWorker</code><code class="o">.</code><code class="n">Schedule</code><code class="p">(</code>
<code class="lineno">4 </code>    <code class="n">FWorker</code><code class="o">.</code><code class="n">CreateWorkItem</code><code class="p">(</code><code class="n">TOmniValue</code><code class="o">.</code><code class="n">Null</code><code class="p">)</code><code class="o">,</code>
<code class="lineno">5 </code>    <code class="n">FWorker</code><code class="o">.</code><code class="n">Config</code><code class="o">.</code><code class="n">OnExecute</code><code class="p">(</code><code class="n">LoadData</code><code class="p">)</code><code class="o">.</code><code class="n">OnRequestDone</code><code class="p">(</code><code class="n">DisplayData</code><code class="p">)</code>
<code class="lineno">6 </code>  <code class="p">)</code><code class="o">;</code>
<code class="lineno">7 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>LoadData</code> executes in the background worker thread. It uses a temporary <code>TDataSetProvider</code> to copy data to a freshly created <code>TClientDataSet</code><sup id="fnref-embd-copy-db"><a href="chap17.html#fn-embd-copy-db" rel="footnote">20</a></sup>. During this process, a ‘Field not found’<sup id="fnref-db-copy-exception"><a href="chap17.html#fn-db-copy-exception" rel="footnote">21</a></sup> exception is raised twice. If you run the program in the debugger, you’ll see this exception four times (twice for each frame). You can safely ignore the exception as it is handled internally in the Delphi RTL and is not visible to the end-user.</p>

<p>At the end, the <code>TClientDataSet</code> that was created inside the <code>LoadData</code> is assigned to the <code>workItem.Result</code>. It will be processed (and eventually destroyed) in the main thread.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmTwoFishDB_GUI</code><code class="o">.</code><code class="nf">LoadData</code><code class="p">(</code><code class="k">const</code> <code class="n">workItem</code><code class="o">:</code> <code class="n">IOmniWorkItem</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">dataModule</code>  <code class="o">:</code> <code class="n">TdmTwoFishDB</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">resultDS</code>    <code class="o">:</code> <code class="n">TClientDataSet</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="n">tempProvider</code><code class="o">:</code> <code class="n">TDataSetProvider</code><code class="o">;</code>
<code class="lineno"> 6 </code><code class="k">begin</code>
<code class="lineno"> 7 </code>  <code class="n">dataModule</code> <code class="o">:=</code> <code class="p">(</code><code class="n">workItem</code><code class="o">.</code><code class="n">TaskState</code><code class="o">.</code><code class="n">AsObject</code> <code class="k">as</code> <code class="n">TdmTwoFishDB</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 8 </code>  <code class="k">if</code> <code class="k">not</code> <code class="n">dataModule</code><code class="o">.</code><code class="n">IBTable1</code><code class="o">.</code><code class="n">Active</code> <code class="k">then</code>
<code class="lineno"> 9 </code>    <code class="n">dataModule</code><code class="o">.</code><code class="n">IBTable1</code><code class="o">.</code><code class="n">Active</code> <code class="o">:=</code> <code class="k">true</code>
<code class="lineno">10 </code>  <code class="k">else</code>
<code class="lineno">11 </code>    <code class="n">dataModule</code><code class="o">.</code><code class="n">IBTable1</code><code class="o">.</code><code class="n">Refresh</code><code class="o">;</code>
<code class="lineno">12 </code>
<code class="lineno">13 </code>  <code class="n">resultDS</code> <code class="o">:=</code> <code class="n">TClientDataSet</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="k">nil</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">14 </code>
<code class="lineno">15 </code>  <code class="n">tempProvider</code> <code class="o">:=</code> <code class="n">TDataSetProvider</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="k">nil</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">16 </code>  <code class="k">try</code>
<code class="lineno">17 </code>    <code class="n">tempProvider</code><code class="o">.</code><code class="n">DataSet</code> <code class="o">:=</code> <code class="n">dataModule</code><code class="o">.</code><code class="n">IBTable1</code><code class="o">;</code>
<code class="lineno">18 </code>    <code class="n">resultDS</code><code class="o">.</code><code class="n">Data</code> <code class="o">:=</code> <code class="n">tempProvider</code><code class="o">.</code><code class="n">Data</code><code class="o">;</code> 
<code class="lineno">19 </code>  <code class="k">finally</code> <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">tempProvider</code><code class="p">)</code><code class="o">;</code> <code class="k">end</code><code class="o">;</code>
<code class="lineno">20 </code>
<code class="lineno">21 </code>  <code class="n">workItem</code><code class="o">.</code><code class="bp">Result</code> <code class="o">:=</code> <code class="n">resultDS</code><code class="o">;</code> <code class="c1">// receiver will take ownership</code>
<code class="lineno">22 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>The <code>DisplayData</code> method executes in the main thread after the request was processed (i.e., the data was retrieved). If there was an exception inside the work item processing code (<code>LoadData</code>), it is displayed. Otherwise, the <code>TClientDataSet</code> is copied from the <code>workItem.Result</code> into an internal <code>TfrmTwoFishDB_GUI</code> field and assigned to the <code>DataSource1.DataSet</code>. By doing that, all data-aware controls on the frame can access the data.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmTwoFishDB_GUI</code><code class="o">.</code><code class="nf">DisplayData</code><code class="p">(</code>
<code class="lineno"> 2 </code>  <code class="k">const</code> <code class="n">Sender</code><code class="o">:</code> <code class="n">IOmniBackgroundWorker</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="k">const</code> <code class="n">workItem</code><code class="o">:</code> <code class="n">IOmniWorkItem</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 4 </code><code class="k">begin</code>
<code class="lineno"> 5 </code>  <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">FDataSet</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 6 </code>
<code class="lineno"> 7 </code>  <code class="k">if</code> <code class="n">workItem</code><code class="o">.</code><code class="n">IsExceptional</code> <code class="k">then</code>
<code class="lineno"> 8 </code>    <code class="n">ShowMessage</code><code class="p">(</code><code class="s">'Failed to retrieve data. '</code> <code class="o">+</code> 
<code class="lineno"> 9 </code>      <code class="n">workItem</code><code class="o">.</code><code class="n">FatalException</code><code class="o">.</code><code class="n">Message</code><code class="p">)</code>
<code class="lineno">10 </code>  <code class="k">else</code> <code class="k">begin</code>
<code class="lineno">11 </code>    <code class="n">FDataSet</code> <code class="o">:=</code> <code class="n">workItem</code><code class="o">.</code><code class="bp">Result</code><code class="o">.</code><code class="n">AsObject</code> <code class="k">as</code> <code class="n">TClientDataSet</code><code class="o">;</code>
<code class="lineno">12 </code>    <code class="n">DataSource1</code><code class="o">.</code><code class="n">DataSet</code> <code class="o">:=</code> <code class="n">FDataSet</code><code class="o">;</code>
<code class="lineno">13 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">14 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-main-program">
<span class="section-number">7.11.3 </span>Main program</h4>

<p>The main program is fairly simple. In the <code>OnCreateEvent</code> two frames are created. Frame references are stored in the <code>FFrames</code> form field, declared as <code>array of TfrmTwoFishDB_GUI</code>. </p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmTwoFish</code><code class="o">.</code><code class="nf">FormCreate</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">iFrame</code><code class="o">:</code> <code class="kt">integer</code><code class="o">;</code>
<code class="lineno"> 4 </code><code class="k">begin</code>
<code class="lineno"> 5 </code>  <code class="nb">SetLength</code><code class="p">(</code><code class="n">FFrames</code><code class="o">,</code> <code class="n">CNumFrames</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 6 </code>  <code class="k">for</code> <code class="n">iFrame</code> <code class="o">:=</code> <code class="mi">0</code> <code class="k">to</code> <code class="n">CNumFrames</code><code class="o">-</code><code class="mi">1</code> <code class="k">do</code>
<code class="lineno"> 7 </code>    <code class="n">FFrames</code><code class="p">[</code><code class="n">iFrame</code><code class="p">]</code> <code class="o">:=</code> <code class="n">CreateFrame</code><code class="p">(</code>
<code class="lineno"> 8 </code>      <code class="n">CFrameWidth</code> <code class="o">*</code> <code class="n">iFrame</code><code class="o">,</code> <code class="mi">0</code><code class="o">,</code> <code class="n">CFrameWidth</code><code class="o">,</code> <code class="n">CFrameHeight</code><code class="o">,</code>
<code class="lineno"> 9 </code>      <code class="nb">Format</code><code class="p">(</code><code class="s">'Frame%d'</code><code class="o">,</code> <code class="p">[</code><code class="n">iFrame</code><code class="o">+</code><code class="mi">1</code><code class="p">]))</code><code class="o">;</code>
<code class="lineno">10 </code>  <code class="n">ClientWidth</code> <code class="o">:=</code> <code class="n">CNumFrames</code> <code class="o">*</code> <code class="n">CFrameWidth</code><code class="o">;</code>
<code class="lineno">11 </code>  <code class="n">ClientHeight</code> <code class="o">:=</code> <code class="n">CFrameHeight</code><code class="o">;</code>
<code class="lineno">12 </code>  <code class="n">OpenConnections</code><code class="o">;</code>
<code class="lineno">13 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>Next, the form is resized to twice the frame size and <code>OpenConnections</code> is called to establish database connections in all frames.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmTwoFish</code><code class="o">.</code><code class="nf">OpenConnections</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">frame</code><code class="o">:</code> <code class="n">TfrmTwoFishDB_GUI</code><code class="o">;</code>
<code class="lineno"> 4 </code><code class="k">begin</code>
<code class="lineno"> 5 </code>  <code class="k">for</code> <code class="n">frame</code> <code class="k">in</code> <code class="n">FFrames</code> <code class="k">do</code>
<code class="lineno"> 6 </code>    <code class="n">frame</code><code class="o">.</code><code class="n">OpenConnection</code><code class="p">(</code><code class="n">CDatabaseName</code> <code class="o">,</code>
<code class="lineno"> 7 </code>      <code class="k">procedure</code> <code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="o">;</code> <code class="n">FatalException</code><code class="o">:</code> <code class="n">Exception</code><code class="p">)</code>
<code class="lineno"> 8 </code>      <code class="k">begin</code>
<code class="lineno"> 9 </code>        <code class="k">if</code> <code class="nb">assigned</code><code class="p">(</code><code class="n">FatalException</code><code class="p">)</code> <code class="k">then</code>
<code class="lineno">10 </code>          <code class="n">ShowMessage</code><code class="p">(</code><code class="s">'Failed to connect to the database!'</code><code class="p">)</code>
<code class="lineno">11 </code>        <code class="k">else</code>
<code class="lineno">12 </code>          <code class="p">(</code><code class="n">Sender</code> <code class="k">as</code> <code class="n">TfrmTwoFishDB_GUI</code><code class="p">)</code><code class="o">.</code><code class="n">Reload</code><code class="o">;</code>
<code class="lineno">13 </code>      <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">14 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>OpenConnections</code> iterates over all frames and calls <code>OpenConnection</code> method in each one. Two parameters are passed to it – the database name and an anonymous method that will be executed after the connection has been established.</p>

<p>If the connection fails, the <code>FatalException</code> field will contain the exception object raised inside the background worker’s <code>OpenConnection</code> code. In such a case, it will be logged. Otherwise, the connection was established successfully and <code>Reload</code> is called to load data into the frame.</p>

<p>Frames are destroyed from <code>OnCloseQuery</code>. It turns out that Delphi (at least XE2) will deadlock if data modules are destroyed in background threads while <code>OnDestroy</code> is running.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmTwoFish</code><code class="o">.</code><code class="nf">FormCloseQuery</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="o">;</code> 
<code class="lineno">2 </code>  <code class="k">var</code> <code class="n">CanClose</code><code class="o">:</code> <code class="kt">boolean</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">3 </code><code class="k">var</code>
<code class="lineno">4 </code>  <code class="n">frame</code><code class="o">:</code> <code class="n">TfrmTwoFishDB_GUI</code><code class="o">;</code>
<code class="lineno">5 </code><code class="k">begin</code>
<code class="lineno">6 </code>  <code class="k">for</code> <code class="n">frame</code> <code class="k">in</code> <code class="n">FFrames</code> <code class="k">do</code>
<code class="lineno">7 </code>    <code class="n">frame</code><code class="o">.</code><code class="n">CloseConnection</code><code class="o">;</code>
<code class="lineno">8 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>To recapitulate, most important facts about using databases from secondary threads are:</p>

<ul>
  <li>Always create non-visual database components in the thread that will be using them.</li>
  <li>Always create data-aware controls in the main thread.</li>
  <li>Never connect data-aware controls to non-visual database components that were created in a secondary thread.</li>
  <li>Wrap <code>TIBDatabase.Connected := true</code> in a critical section because of <em>gds32</em> bugs.</li>
  <li>Destroy database tasks from <code>OnCloseQuery</code>, not from <code>OnDestroy</code> if you are using data modules in a secondary thread.</li>
  <li>Establish some mechanism of data passing between the database (secondary thread) and the view (main thread).</li>
</ul>


<div class="page-break"></div>
<h3 id="howto-com">
<span class="section-number">7.12 </span>OmniThreadLibrary and COM/OLE</h3>

<aside>
  <p><em>Can you give me any tips on how to use COM services from background threads?</em></p>

</aside>

<p>It is actually very simple – you have to remember to call <code>CoInitializeEx</code> and <code>CoUninitialize</code> from the task code and then you won’t have any problems. </p>

<p>I have put together a simple example that uses SOAP to retrieve VAT info for European companies using the SOAP service at <a href="http://ec.europa.eu/taxation_customs/vies/checkVatService.wsdl"><code>ec.europa.eu</code></a>. It is included with the OmniThreadLibrary distribution in the <code>examples/checkVat</code> folder.  </p>

<p>The program has two input fields, one for the country code (<code>inpCC</code>) and one for the VAT number (<code>inpVat</code>), a button that triggers the SOAP request (<code>btnCheckVat</code>) and a memo that displays the result (<code>outVatInfo</code>).</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 60%;">
    <img src="images/checkVat.png" alt="" style="width: 100%;" />
    <figcaption></figcaption>
  </figure>
</div>


<p>There’s only one method – the <code>btnCheckVat.OnClick</code> handler.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TfrmCheckVat</code><code class="o">.</code><code class="nf">btnCheckVatClick</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="p">)</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">begin</code>
<code class="lineno"> 3 </code>  <code class="n">btnCheckVat</code><code class="o">.</code><code class="n">Enabled</code> <code class="o">:=</code> <code class="k">false</code><code class="o">;</code>
<code class="lineno"> 4 </code>  <code class="n">outVatInfo</code><code class="o">.</code><code class="n">Lines</code><code class="o">.</code><code class="n">Clear</code><code class="o">;</code>
<code class="lineno"> 5 </code>  <code class="n">FRequest</code> <code class="o">:=</code> <code class="n">Parallel</code><code class="o">.</code><code class="n">Future</code><code class="o">&lt;</code><code class="n">checkVatResponse</code><code class="o">&gt;</code><code class="p">(</code>
<code class="lineno"> 6 </code>    <code class="k">function</code><code class="o">:</code> <code class="nf">checkVatResponse</code>
<code class="lineno"> 7 </code>    <code class="k">var</code>
<code class="lineno"> 8 </code>      <code class="n">request</code><code class="o">:</code> <code class="n">checkVat</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">begin</code>
<code class="lineno">10 </code>      <code class="n">OleCheck</code><code class="p">(</code><code class="n">CoInitializeEx</code><code class="p">(</code><code class="k">nil</code><code class="o">,</code> <code class="n">COINIT_MULTITHREADED</code><code class="p">))</code><code class="o">;</code>
<code class="lineno">11 </code>      <code class="k">try</code>
<code class="lineno">12 </code>        <code class="n">request</code> <code class="o">:=</code> <code class="n">checkVat</code><code class="o">.</code><code class="n">Create</code><code class="o">;</code>
<code class="lineno">13 </code>        <code class="k">try</code>
<code class="lineno">14 </code>          <code class="n">request</code><code class="o">.</code><code class="n">countryCode</code> <code class="o">:=</code> <code class="nb">Trim</code><code class="p">(</code><code class="n">inpCC</code><code class="o">.</code><code class="n">Text</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">15 </code>          <code class="n">request</code><code class="o">.</code><code class="n">vatNumber</code> <code class="o">:=</code> <code class="nb">Trim</code><code class="p">(</code><code class="n">inpVat</code><code class="o">.</code><code class="n">Text</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">16 </code>          <code class="bp">Result</code> <code class="o">:=</code> <code class="n">checkVatService</code><code class="o">.</code><code class="n">GetcheckVatPortType</code><code class="o">.</code><code class="n">checkVat</code><code class="p">(</code><code class="n">request</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">17 </code>        <code class="k">finally</code> <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">request</code><code class="p">)</code><code class="o">;</code> <code class="k">end</code><code class="o">;</code>
<code class="lineno">18 </code>      <code class="k">finally</code> <code class="n">CoUninitialize</code><code class="o">;</code> <code class="k">end</code><code class="o">;</code>
<code class="lineno">19 </code>    <code class="k">end</code><code class="o">,</code>
<code class="lineno">20 </code>    <code class="n">Parallel</code><code class="o">.</code><code class="n">TaskConfig</code><code class="o">.</code><code class="n">OnTerminated</code><code class="p">(</code>
<code class="lineno">21 </code>      <code class="k">procedure</code> <code class="p">(</code><code class="k">const</code> <code class="n">task</code><code class="o">:</code> <code class="n">IOmniTaskControl</code><code class="p">)</code>
<code class="lineno">22 </code>      <code class="k">begin</code>
<code class="lineno">23 </code>        <code class="n">outVatInfo</code><code class="o">.</code><code class="n">Text</code> <code class="o">:=</code> <code class="n">FRequest</code><code class="o">.</code><code class="n">Value</code><code class="o">.</code><code class="n">name_</code> <code class="o">+</code> <code class="sc">#13#10</code> <code class="o">+</code> 
<code class="lineno">24 </code>          <code class="n">FRequest</code><code class="o">.</code><code class="n">Value</code><code class="o">.</code><code class="n">address</code><code class="o">;</code>
<code class="lineno">25 </code>        <code class="n">FRequest</code> <code class="o">:=</code> <code class="k">nil</code><code class="o">;</code>
<code class="lineno">26 </code>        <code class="n">btnCheckVat</code><code class="o">.</code><code class="n">Enabled</code> <code class="o">:=</code> <code class="k">true</code><code class="o">;</code>
<code class="lineno">27 </code>      <code class="k">end</code>
<code class="lineno">28 </code>    <code class="p">)</code>
<code class="lineno">29 </code>  <code class="p">)</code><code class="o">;</code>
<code class="lineno">30 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p>This method firstly disables the button (so that only one request at a time can be active) and clears the output. Then it uses a <a href="chap06.html#highlevel-future"><em>Future</em></a> returning a <code>checkVatResponse</code> (a type defined in the <code>checkVatService</code> unit which was generating by importing the WSDL specification). This <em>Future</em> will execute the SOAP request in a background task and after that the anonymous method in <code>Parallel.TaskConfig.OnTerminated</code> will be called in the main thread. This anonymous method displays the result in the <code>outVatInfo</code> control, destroys the <code>FRequest</code> <em>Future</em> object and enables the button.</p>

<p>The main <em>Future</em> method looks just the same as if it would be executed from the main thread except that the SOAP stuff is wrapped in <code>CoInitializeEx</code>/<code>CoUninitialize</code> calls that make sure that everything is correctly initialized for COM/OLE.</p>


<div class="page-break"></div>
<h3 id="howto-mqtthread">
<span class="section-number">7.13 </span>Using a message queue with a TThread worker</h3>

<aside>
  <p><em>I’m not yet using OmniThreadLibrary for multi-threading, just normal <code>TThread</code>-based threads, but I would like to add OmniThreadLibrary’s messaging model to my threads. How can I use OmniThreadLibrary to send and receive data to/from a thread?</em></p>

</aside>

<p>The simplest way is to create two <a href="chap07.html#lowlevel-lockfree-messagequeue"><code>TOmniMessageQueue</code></a> objects, one to send data to a thread and one to receive data. Alternatively, you could create a <a href="chap09.html#misc-tOmniTwoWayChannel"><code>TOmniTwoWayChannel</code></a>, which is just a simple pair of two <code>TOmniMessageQueue</code> instances. The solution below uses a former approach.</p>

<blockquote>
  <p><em>A solution to this problem is included with the OmniThreadLibrary distribution in the <code>examples/TThread communication</code> folder.</em></p>
</blockquote>

<p>We have to handle two very similar but not identical parts:</p>

<ul>
  <li>Sending data from any thread (main or background) to a <code>TThread</code> based worker.</li>
  <li>Sending data from any <code>TThread</code> based worker or from a form to the main thread (to a form).</li>
</ul>

<p>Let’s deal with them one by one.</p>

<h4 id="leanpub-auto-sending-data-from-multiple-producers-to-a-single-worker">
<span class="section-number">7.13.1 </span>Sending data from multiple producers to a single worker</h4>

<p>To send data form a form to a thread, we need a message queue. This example uses a <code>TOmniMessageQueue</code> object for that purpose. An instance of this object is created in the main thread. All threads – the main thread, the worker threads, and potential other data-producing threads – use the same shared object which is written with thread-safety in mind.</p>

<h5 id="leanpub-auto-initialization-and-cleanup">
<span class="section-number">7.13.1.1 </span>Initialization and cleanup</h5>

<p>The <code>TOmniMessageQueue</code> constructor takes a maximum queue size for a parameter. <code>TWorker</code> is just a simple <code>TThread</code> descendant which accepts the instance of the message queue as a parameter so it can read from the queue.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FCommandQueue</code> <code class="o">:=</code> <code class="n">TOmniMessageQueue</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="mi">1000</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">FWorker</code> <code class="o">:=</code> <code class="n">TWorker</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="n">FCommandQueue</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<p>The shutdown sequence is fairly standard. <code>Stop</code> is used instead of <code>Terminate</code> so it can set internal event which is used to signal the thread to stop.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">if</code> <code class="nb">assigned</code><code class="p">(</code><code class="n">FWorker</code><code class="p">)</code> <code class="k">then</code> <code class="k">begin</code>  
<code class="lineno">2 </code>  <code class="n">FWorker</code><code class="o">.</code><code class="n">Stop</code><code class="o">;</code>
<code class="lineno">3 </code>  <code class="n">FWorker</code><code class="o">.</code><code class="n">WaitFor</code><code class="o">;</code>
<code class="lineno">4 </code>  <code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">FWorker</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code><code class="k">end</code><code class="o">;</code>
<code class="lineno">6 </code><code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">FCommandQueue</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<h5 id="leanpub-auto-sending-data-to-the-worker">
<span class="section-number">7.13.1.2 </span>Sending data to the worker</h5>

<p>To put data into a queue, use its <code>Enqueue</code> method. It accepts a <code>TOmniMessage</code> record. Each <code>TOmniMessage</code> contains an integer <em>message ID</em> (not used in this example) and a <a href="chap05.html#introotl-tomnivalue"><code>TOmniValue</code></a> <em>data</em> which, in turn, can hold any data type.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmTThreadComm</code><code class="o">.</code><code class="nf">Query</code><code class="p">(</code><code class="n">value</code><code class="o">:</code> <code class="kt">integer</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="k">if</code> <code class="k">not</code> <code class="n">FCommandQueue</code><code class="o">.</code><code class="n">Enqueue</code><code class="p">(</code><code class="n">TOmniMessage</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="mi">0</code> <code class="cm">{ignored}</code><code class="o">,</code> <code class="n">value</code><code class="p">))</code> <code class="k">then</code>
<code class="lineno">4 </code>    <code class="k">raise</code> <code class="n">Exception</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="s">'Command queue is full!'</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">5 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<p><code>Enqueue</code> returns <code>False</code> if the queue is full. (A <code>TOmniMessageQueue</code> can only hold as much elements as specified in the constructor call.)</p>

<p>The example below shows how everything works correctly if two threads are started (almost) at the same time and both write to the message queue.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">var</code>
<code class="lineno"> 2 </code>  <code class="n">th1</code><code class="o">:</code> <code class="n">TThread</code><code class="o">;</code>
<code class="lineno"> 3 </code>  <code class="n">th2</code><code class="o">:</code> <code class="n">TThread</code><code class="o">;</code>
<code class="lineno"> 4 </code><code class="k">begin</code>
<code class="lineno"> 5 </code>  <code class="n">th1</code> <code class="o">:=</code> <code class="n">TThread</code><code class="o">.</code><code class="n">CreateAnonymousThread</code><code class="p">(</code>
<code class="lineno"> 6 </code>    <code class="k">procedure</code>
<code class="lineno"> 7 </code>    <code class="k">begin</code>
<code class="lineno"> 8 </code>      <code class="nf">Query</code><code class="p">(</code><code class="nb">Random</code><code class="p">(</code><code class="mi">1000</code><code class="p">))</code><code class="o">;</code>
<code class="lineno"> 9 </code>    <code class="k">end</code><code class="p">)</code><code class="o">;</code>  
<code class="lineno">10 </code>  <code class="n">th2</code> <code class="o">:=</code> <code class="n">TThread</code><code class="o">.</code><code class="n">CreateAnonymousThread</code><code class="p">(</code>
<code class="lineno">11 </code>    <code class="k">procedure</code>
<code class="lineno">12 </code>    <code class="k">begin</code>
<code class="lineno">13 </code>      <code class="nf">Query</code><code class="p">(</code><code class="nb">Random</code><code class="p">(</code><code class="mi">1000</code><code class="p">))</code><code class="o">;</code>
<code class="lineno">14 </code>    <code class="k">end</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">15 </code>  
<code class="lineno">16 </code>  <code class="n">th1</code><code class="o">.</code><code class="n">Start</code><code class="o">;</code>
<code class="lineno">17 </code>  <code class="n">th2</code><code class="o">.</code><code class="n">Start</code><code class="o">;</code>
<code class="lineno">18 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h5 id="leanpub-auto-receiving-the-data">
<span class="section-number">7.13.1.3 </span>Receiving the data</h5>

<p>The worker’s <code>Execute</code> method waits on two handles in a loop. If a <code>FStopEvent</code> (an internal event) is signalled, the loop will exit. If the message queue’s <code>GetNewMessageEvent</code> (a <code>THandle</code>-returning method) gets signalled, a new data has arrived to the queue. In that case, the code loops to empty the message queue and then waits again for something to happen.</p>

<aside class="tip blurb">
    <p>It is not a good idea to just read one element from the queue when a handle is signalled and then wait until a handle is  signalled again before reading the next element. If elements are added to the queue in a quick succession, the queue will slowly fill up and overflow. </p>

  <p>The proper way is to always read all data from the queue when a handle is signalled. </p>

</aside>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno"> 1 </code><code class="k">procedure</code> <code class="nc">TWorker</code><code class="o">.</code><code class="nf">Execute</code><code class="o">;</code>
<code class="lineno"> 2 </code><code class="k">var</code>
<code class="lineno"> 3 </code>  <code class="n">handles</code><code class="o">:</code> <code class="k">array</code> <code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="mi">1</code><code class="p">]</code> <code class="k">of</code> <code class="kt">THandle</code><code class="o">;</code>  
<code class="lineno"> 4 </code>  <code class="n">msg</code>    <code class="o">:</code> <code class="n">TOmniMessage</code><code class="o">;</code>
<code class="lineno"> 5 </code><code class="k">begin</code>  
<code class="lineno"> 6 </code>  <code class="n">handles</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">:=</code> <code class="n">FStopEvent</code><code class="o">.</code><code class="n">Handle</code><code class="o">;</code>  
<code class="lineno"> 7 </code>  <code class="n">handles</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">:=</code> <code class="n">FCommandQueue</code><code class="o">.</code><code class="n">GetNewMessageEvent</code><code class="o">;</code>  
<code class="lineno"> 8 </code>  <code class="k">while</code> <code class="n">WaitForMultipleObjects</code><code class="p">(</code><code class="mi">2</code><code class="o">,</code> <code class="o">@</code><code class="n">handles</code><code class="o">,</code> <code class="k">false</code><code class="o">,</code> <code class="n">INFINITE</code><code class="p">)</code> <code class="o">=</code> 
<code class="lineno"> 9 </code>          <code class="p">(</code><code class="n">WAIT_OBJECT_0</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)</code> <code class="k">do</code> 
<code class="lineno">10 </code>  <code class="k">begin</code>    
<code class="lineno">11 </code>    <code class="k">while</code> <code class="n">FCommandQueue</code><code class="o">.</code><code class="n">TryDequeue</code><code class="p">(</code><code class="n">msg</code><code class="p">)</code> <code class="k">do</code> <code class="k">begin</code>      
<code class="lineno">12 </code>      <code class="c1">//process the message ... </code>
<code class="lineno">13 </code>    <code class="k">end</code><code class="o">;</code>  
<code class="lineno">14 </code>  <code class="k">end</code><code class="o">;</code>
<code class="lineno">15 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-sending-data-from-a-worker-to-a-form">
<span class="section-number">7.13.2 </span>Sending data from a worker to a form</h4>

<p>To send messages from a worker thread to a form, we need another instance of <code>TOmniMessageQueue</code>. As we can’t wait on a handle in the main thread (that would block the user interface), we’ll use a different notification mechanism – a <a href="chap07.html#lowlevel-lockfree-observing">window message observer</a>. </p>

<h5 id="leanpub-auto-initialization-and-cleanup-1">
<span class="section-number">7.13.2.1 </span>Initialization and cleanup</h5>

<p>We create the queue just as in the first part. To use a <em>window message observer</em> we then just have to assign a message handler to the queue’s <code>OnMessage</code> event. An observer will be set up automatically in the background.</p>

<p>After that, the event handler will be called once for each message that is inserted into the queue from any thread (or from the form itself).</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="n">FResponseQueue</code> <code class="o">:=</code> <code class="n">TOmniMessageQueue</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="mi">1000</code><code class="o">,</code> <code class="k">false</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="n">FResponseQueue</code><code class="o">.</code><code class="n">OnMessage</code> <code class="o">:=</code> <code class="n">HandleThreadMessage</code><code class="o">;</code>
</pre></div>

</figure>

<p>While shutting down, we just have to destroy the queue.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="nb">FreeAndNil</code><code class="p">(</code><code class="n">FResponseQueue</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<h5 id="leanpub-auto-sending-data-to-the-form">
<span class="section-number">7.13.2.2 </span>Sending data to the form</h5>

<p>To send a data, we use exactly the same approach as in the first part (sending data to a worker).</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">if</code> <code class="k">not</code> <code class="n">FResponseQueue</code><code class="o">.</code><code class="n">Enqueue</code><code class="p">(</code><code class="n">TOmniMessage</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="mi">0</code> <code class="cm">{ignored}</code><code class="o">,</code>
<code class="lineno">2 </code>         <code class="nb">Format</code><code class="p">(</code><code class="s">'= %d'</code><code class="o">,</code> <code class="p">[</code><code class="n">msg</code><code class="o">.</code><code class="n">MsgData</code><code class="o">.</code><code class="n">AsInteger</code> <code class="o">*</code> <code class="mi">2</code><code class="p">])))</code> 
<code class="lineno">3 </code><code class="k">then</code>  
<code class="lineno">4 </code>  <code class="k">raise</code> <code class="n">Exception</code><code class="o">.</code><code class="n">Create</code><code class="p">(</code><code class="s">'Response queue is full!'</code><code class="p">)</code><code class="o">;</code>
</pre></div>

</figure>

<h5 id="leanpub-auto-receiving-the-data-1">
<span class="section-number">7.13.2.3 </span>Receiving the data</h5>

<p>On the receiving side (the form) we have to write an event handler that is called for each message.</p>

<figure class="code" dir="ltr">
<div class="highlight"><pre><code></code><code class="lineno">1 </code><code class="k">procedure</code> <code class="nc">TfrmTThreadComm</code><code class="o">.</code><code class="nf">HandleThreadMessage</code><code class="p">(</code><code class="n">Sender</code><code class="o">:</code> <code class="kt">TObject</code><code class="o">;</code> <code class="k">const</code> <code class="n">msg</code><code class="o">:</code> <code class="n">TOmniMessage</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">2 </code><code class="k">begin</code>
<code class="lineno">3 </code>  <code class="c1">//msg.MsgID is ignored in this demo</code>
<code class="lineno">4 </code>  <code class="c1">//msg.MsgData contains a string, generated by the worker</code>
<code class="lineno">5 </code>  <code class="n">lbLog</code><code class="o">.</code><code class="n">ItemIndex</code> <code class="o">:=</code> <code class="n">lbLog</code><code class="o">.</code><code class="n">Items</code><code class="o">.</code><code class="n">Add</code><code class="p">(</code><code class="n">msg</code><code class="o">.</code><code class="n">MsgData</code><code class="p">)</code><code class="o">;</code>
<code class="lineno">6 </code><code class="k">end</code><code class="o">;</code>
</pre></div>

</figure>

<!-- begin backmatter -->


</div>
</body>

<!-- Mirrored from www.omnithreadlibrary.com/book/chap10.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 19 Oct 2025 22:29:14 GMT -->
</html>
